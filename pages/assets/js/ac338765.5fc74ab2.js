"use strict";(self.webpackChunkspr_docs=self.webpackChunkspr_docs||[]).push([[4255],{71303:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>u});var o=t(85893),s=t(11151);const i={slug:"loading-your-own-rust-kernel-modules",title:"Loading Out of Tree Rust in Linux",authors:["jgoldberger"],tags:["rust","kernel","linux","wifi"]},r=void 0,a={permalink:"/pages/blog/loading-your-own-rust-kernel-modules",source:"@site/blog/2024-08-19-rust.md",title:"Loading Out of Tree Rust in Linux",description:"Rust is taking off in the Linux Kernel and improved support and features make it possible to develop drivers with Rust.",date:"2024-08-19T00:00:00.000Z",tags:[{inline:!0,label:"rust",permalink:"/pages/blog/tags/rust"},{inline:!0,label:"kernel",permalink:"/pages/blog/tags/kernel"},{inline:!0,label:"linux",permalink:"/pages/blog/tags/linux"},{inline:!0,label:"wifi",permalink:"/pages/blog/tags/wifi"}],readingTime:9.845,hasTruncateMarker:!0,authors:[{name:"Jeremy Goldberger",url:"https://github.com/jgoldberger26",key:"jgoldberger",page:null}],frontMatter:{slug:"loading-your-own-rust-kernel-modules",title:"Loading Out of Tree Rust in Linux",authors:["jgoldberger"],tags:["rust","kernel","linux","wifi"]},unlisted:!1,nextItem:{title:"BSSID Randomization",permalink:"/pages/blog/bssid-randomization"}},l={authorsImageUrls:[void 0]},u=[{value:"TL;DR",id:"tldr",level:2},{value:"Out of Tree Modules",id:"out-of-tree-modules",level:2},{value:"What are abstractions?",id:"what-are-abstractions",level:2},{value:"Why Bindgen isn&#39;t a problem",id:"why-bindgen-isnt-a-problem",level:2},{value:"Macros and Inlines",id:"macros-and-inlines",level:2},{value:"Depending on an external module",id:"depending-on-an-external-module",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Rust is ",(0,o.jsx)(n.a,{href:"https://blog.rust-lang.org/2024/08/12/Project-goals.html",children:"taking off"})," in the Linux Kernel and improved support and features make it possible to develop drivers with Rust."]}),"\n",(0,o.jsxs)(n.p,{children:["It's no secret that C is not a memory-safe language. In the router world, there are ",(0,o.jsx)(n.a,{href:"https://x.com/router_bugs",children:"tons of bugs"})," that surface, many related to memory safety. These bugs are often rooted in low-level device firmware and kernel drivers, making them very dangerous and difficult to work with. Supernetworks is exploring ways of moving wireless protocol parsing out of firmware and drivers and pushing them into userland, with a minimal custom kernel module. Writing this module in Rust would avoid many of the safety pitfalls of C."]}),"\n",(0,o.jsx)(n.p,{children:"The 6.9 Linux release landed Rust support for arm64 which opens the door for us to use Rust for our arm64 based hardware."}),"\n",(0,o.jsx)(n.p,{children:"One challenge is how to distribute kernel code to users. It\u2019s difficult to maintain a kernel branch so we\u2019d like to explore distributing an out of tree kernel module instead. So when Ubuntu finally lands kernels with Rust for ARM64 (expected to be this year), we\u2019ll be able to distribute a Rust module to load in directly."}),"\n",(0,o.jsx)(n.h2,{id:"tldr",children:"TL;DR"}),"\n",(0,o.jsx)(n.p,{children:"Rust abstractions can be put out of tree with your module, they don't need to be compiled in with the kernel. Bindgen still works, since it doesn't change the kernel ABI. Helper functions that wrap inlined functions and macros can just be put inside of another external module, and the compiler will figure out the dependency chain."}),"\n",(0,o.jsx)(n.h2,{id:"out-of-tree-modules",children:"Out of Tree Modules"}),"\n",(0,o.jsx)(n.p,{children:"With Out of Tree Modules, developers can build Linux Kernel Modules and ship them separately from the loaded Linux kernel build. These modules aren't baked into the Linux kernel. Instead, they rely on symbols that the kernel exports to call into kernel code, allowing them to draw on the vast capabilities of the Linux kernel. With Rust, however, calling into the kernel is a little more complicated."}),"\n",(0,o.jsxs)(n.p,{children:["One of the main problems with writing external modules in Rust is that individual subsystems have little built-in support for Rust, as of the time of writing this article. Each subsystem has many functions that drivers can expect to exist in the kernel ABI, but these functions don't have Rust abstractions written for them, at least not ones rolled into the kernel. The Linux kernel developers are hopeful that coverage for Rust ",(0,o.jsx)(n.a,{href:"https://www.kernel.org/doc/html/latest/rust/general-information.html#abstractions",children:"abstractions"})," will increase in time, but for now, it is not feasible to write a safe external module for the mainline Linux kernel without these abstractions. To understand how we can use Rust in external kernel modules, let's first explore what Rust abstractions are and why they're important."]}),"\n",(0,o.jsx)(n.h2,{id:"what-are-abstractions",children:"What are abstractions?"}),"\n",(0,o.jsxs)(n.p,{children:["Rust, as a systems programming language, has essentially seamless integration with C through a Foreign Function Interface (FFI). Using the ",(0,o.jsx)(n.code,{children:"extern"})," keyword, Rust can make a call to any C function in the kernel as if it were a normal Rust function, with no changes to the kernel. There is only one notable exception: Memory safety guarantees are dropped."]}),"\n",(0,o.jsxs)(n.p,{children:["When C code is compiled, all functions except for inline functions and macros are given symbols. These symbols are exposed through the Application Binary Interface (ABI), allowing other code to call those functions. The ABI contains information such as parameter types, return types, and more, but no information about memory safety. If we want to use Rust's memory safety model, we need to specify these guarantees ourselves, with Rust code. By writing abstraction layers around FFI calls, we can manually define what Rust should expect regarding memory safety. Take this example, based on a similar one from ",(0,o.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code",children:"The Rust Book"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C",children:"int c_abs(int num) {\n\treturn abs(num);\n}\n// EXPORT_SYMBOL_GPL(c_abs);\n\nvoid c_abs_in_place(int* num) {\n\t*num = abs(*num);\n}\n// EXPORT_SYMBOL_GPL(c_abs_in_place);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Rust",children:"extern \"C\" {\n\t// Define our extern functions. This doesn't compile to anything, it just\n\t// tells Rust to expect that it will be able to use these functions with\n\t// these symbols\n\tfn c_abs(num: i32) -> i32;\n\t// Note that 'mut' isn't strictly required. Omitting it would still compile,\n\t// but it would break Rust's memory safety guarantees, allowing the programmer\n\t// to make a mistake.\n\tfn c_abs_in_place(num: *mut i32);\n}\n\n// We wrap the FFI call in an abstraction, so that we can isolate the unsafe call\n// here. If we didn't have this, we would have to use unsafe in our main function,\n// which would make it hard to figure out where memory safety bugs happen.\nfn rust_abs(num: i32) -> i32 {\n\t// SAFETY: This is just an FFI call.\n\tunsafe { c_abs(num) }\n}\n\nfn rust_abs_in_place(num: &mut i32) {\n\t// SAFETY: Since num is a reference, we know its pointer is still valid.\n\t// Otherwise, this is just an FFI call.\n\tunsafe { c_abs_in_place(num as *mut i32) }\n}\n\nfn main() {\n\t// Since we used safe abstractions, we don't need to use unsafe code\n\t// in our main function.\n\tlet foo = rust_abs(-5);\n\tlet mut bar = -5;\n\trust_abs_in_place(&mut bar); // Note that rust forces us to use mut because\n\t\t\t\t\t\t\t\t // of how we defined our safe wrapper.\n\tprintln!(\"Foo is {} and bar is {}!\", foo, bar);\n\t\t   // Foo is 5 and bar is 5!\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Since abstractions are wrappers around essential subsystem functions, they would normally be rolled into the kernel so any driver could access them. That way, each C subsystem function only needs to be wrapped once. Any module or driver, out-of-tree or not, could then use them without having to rewrite the abstraction for every single driver."}),"\n",(0,o.jsxs)(n.p,{children:["As we saw before, abstractions are just normal Rust code that wraps an ",(0,o.jsx)(n.code,{children:"unsafe"})," function. So, what's the problem with just moving it out-of-tree and putting it with your other code? There's none, it really is that easy! While abstractions solve most of our issues, there are some issues that it doesn't solve. To understand why, let's look at bindgen and how it works."]}),"\n",(0,o.jsx)(n.h2,{id:"why-bindgen-isnt-a-problem",children:"Why Bindgen isn't a problem"}),"\n",(0,o.jsxs)(n.p,{children:["As the name implies, bindgen automatically generates bindings for Rust code. These bindings are the same as the ",(0,o.jsx)(n.code,{children:"extern"})," block above, only a lot more complicated. The only confusion is that bindgen must be compiled with the kernel, but it doesn't change the ABI. The only things that go in the ",(0,o.jsx)(n.code,{children:"extern"})," block are definitions: function prototypes, constants, and structure definitions that don't compile to anything. Instead, in the case of function prototypes, they're used by the Rust compiler to place symbols. When the linker links all the object files together, it will find the C function symbols that were exposed by bindgen, and call it from Rust. Bindgen doesn't create anything new; it just exposes existing symbols to Rust."]}),"\n",(0,o.jsx)(n.p,{children:"Now, can call into any exported symbol that exists in the C kernel. But there is one more challenge: Handling macros and inline functions in our Rust modules."}),"\n",(0,o.jsx)(n.h2,{id:"macros-and-inlines",children:"Macros and Inlines"}),"\n",(0,o.jsx)(n.p,{children:"Macros and inline functions are different from regular functions in that they don't get assigned a symbol. Instead, they are directly inserted during pre-processing or compilation. These functions aren't in the kernel ABI, so we don't have any way to access them from Rust!"}),"\n",(0,o.jsx)(n.p,{children:"The way this is normally handled in the kernel is by generating helper functions, like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C",children:"void rust_helper_mutex_lock(struct mutex *lock)\n{\n    mutex_lock(lock);\n}\nEXPORT_SYMBOL_GPL(rust_helper_mutex_lock);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Each of these helper functions is compiled into the kernel and given a symbol so that they can be used from Rust. This is convenient for making use of commonly used macros and inline functions from multiple places. However, our focus is on distributing the external module without having to distribute a kernel as well. Since these helper functions generate symbols that would not be present in the mainline kernel, running our driver would require a custom kernel."}),"\n",(0,o.jsx)(n.p,{children:"To generate these symbols externally, we must write our own helpers with our external module. Unlike abstractions, these helpers aren't just more Rust code. They're C code that needs to be compiled first. We can compile these helper functions using another external module."}),"\n",(0,o.jsx)(n.h2,{id:"depending-on-an-external-module",children:"Depending on an external module"}),"\n",(0,o.jsx)(n.p,{children:"By simply writing these functions in a C file and specifying it as a module, we can generate symbols for C functions. Then, by compiling both the Rust and C modules together, the Linux kernel's build system will automatically figure out that the Rust module depends on the C helper module!"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C",children:'// SPDX-License-Identifier: GPL-2.0\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n\nint linux_version_code(void);\nint linux_version_code(void) {\n\t// We can\'t access LINUX_VERSION_CODE in Rust because it\'s defined\n\t// using #define. This helper function exports it to rust. This\n\t// works with macros and inline functions as well.\n    return LINUX_VERSION_CODE;\n}\nEXPORT_SYMBOL_GPL(linux_version_code);\n\nMODULE_LICENSE("GPL");\nMODULE_AUTHOR("Jeremy Goldberger");\nMODULE_DESCRIPTION("A simple helper module.");\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Rust",children:'// SPDX-License-Identifier: GPL-2.0\n\n//! Inspired by Rust hello world example by Adrea Righi\n\nuse kernel::prelude::*;\n\nmodule! {\n    type: ModuleExample,\n    name: "oot_example",\n    author: "Jeremy Goldberger",\n    description: "Rust external module example",\n    license: "GPL",\n}\n\nstruct ModuleExample {\n}\n\nimpl kernel::Module for ModuleExample {\n    fn init(_module: &\'static ThisModule) -> Result<Self> {\n        pr_info!("Hello from Rust\\n");\n        pr_info!("The current time according to C is {}.\\n", rust_ktime_get());\n        pr_info!("The current linux version according to C is {}.\\n", rust_linux_version_code());\n        Ok(ModuleExample { })\n    }\n}\n\nfn rust_ktime_get() -> i64 {\n    // Note that we don\'t need to define ktime_get() in an extern block anywhere;\n    // it was already done in bindgen! Even if it wasn\'t, we could add whatever\n    // header we wanted to bindings_helper, and we could use it without messing\n    // up the kernel ABI.\n    unsafe { kernel::bindings::ktime_get() }\n}\n\nextern "C" {\n    // We define this extern block ourselves. Because it\'s a helper function\n    // that doesn\'t exist in the Linux kernel, bindgen wouldn\'t be able\n    // to generate it without doing some weird stuff.\n    fn linux_version_code() -> core::ffi::c_int;\n}\n\nfn rust_linux_version_code() -> i32 {\n    unsafe { linux_version_code() }\n}\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["There is already a ",(0,o.jsx)(n.a,{href:"https://github.com/torvalds/linux/blob/master/rust/kernel/time.rs",children:"ktime abstraction"})," written for Rust. I was running 6.9 here, so it wasn't available here. That abstraction leverages Rust types to make it more robust, a common theme in abstractions more complex than the ones above."]})}),"\n",(0,o.jsx)(n.p,{children:"Running the module in a qemu instance:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"ubuntu@ubuntu-24-cloud-image:~$ ls\nhelpers.ko  rust_module.ko\nubuntu@ubuntu-24-cloud-image:~$ uname -r\n6.9.0\nubuntu@ubuntu-24-cloud-image:~$ lsmod\nModule                  Size  Used by\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod rust_module.ko\ninsmod: ERROR: could not insert module rust_module.ko: Unknown symbol in module\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod helpers.ko\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod rust_module.ko\nubuntu@ubuntu-24-cloud-image:~$ lsmod\nModule                  Size  Used by\nrust_module            12288  0\nhelpers                12288  1 rust_module\nubuntu@ubuntu-24-cloud-image:~$ sudo dmesg\n\n...\n\n[   37.728226] rust_module: loading out-of-tree module taints kernel.\n[   37.729919] rust_module: Unknown symbol linux_version_code (err -2)\n[   62.071684] oot_example: Hello from Rust\n[   62.073836] oot_example: The current time according to C is 62047385799.\n[   62.074243] oot_example: The current linux version according to C is 395520.\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the first time we tried to load the module, it threw an error because our ",(0,o.jsx)(n.code,{children:"helpers"})," module wasn't loaded. The second time, it loaded correctly, since it found the ",(0,o.jsx)(n.code,{children:"linux_version_code"})," symbol in our helper module. Additionally, when we ran ",(0,o.jsx)(n.code,{children:"lsmod"}),", we saw that ",(0,o.jsx)(n.code,{children:"helpers"})," was listed as a dependency of ",(0,o.jsx)(n.code,{children:"rust_module"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Now, we have an external module written in Rust, but we can make full use of existing C infrastructure even if it's not baked into the kernel yet! By leveraging external modules, we can start benefiting from Rust's safety features in kernel development without waiting for full mainline support. The rapid development of Rust support in the Linux kernel means that many of these workarounds will become unnecessary over time. As more subsystems gain native Rust abstractions, writing Rust kernel modules will become increasingly straightforward and powerful."}),"\n",(0,o.jsx)(n.p,{children:"The potential for Rust in the Linux kernel is vast, and we're just at the beginning. Whether you're a seasoned kernel developer or new to systems programming like I am, now is an exciting time to get involved and contribute to open-source development."})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var o=t(67294);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);