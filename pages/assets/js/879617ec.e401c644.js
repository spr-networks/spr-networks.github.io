"use strict";(self.webpackChunkspr_docs=self.webpackChunkspr_docs||[]).push([[8549],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(96540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},50005:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/firewall-custom-interface-rule-add-6c2885f7af0f5fd0911a4fde33cb4c27.png"},75026:e=>{e.exports=JSON.parse('{"permalink":"/pages/blog/docker-networking-containment","source":"@site/blog/2024-09-16-contain-your-container-blast-radius.md","title":"Locking Down Docker Networks with SPR","description":"Envision a homelab scenario with a feature-rich router that\'s suitable as a container host with storage and memory. Locking down the router\'s container network policy is surprisingly difficult to set up and manage.","date":"2024-09-16T00:00:00.000Z","tags":[{"inline":true,"label":"container","permalink":"/pages/blog/tags/container"},{"inline":true,"label":"firewall","permalink":"/pages/blog/tags/firewall"}],"readingTime":7.88,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"docker-networking-containment","title":"Locking Down Docker Networks with SPR","authors":["ltsrad"],"tags":["container","firewall"]},"unlisted":false,"prevItem":{"title":"Locking Down Multicast Services with SPR","permalink":"/pages/blog/spr-and-cups-multicast-vulnerability"},"nextItem":{"title":"Authentication, Association, and Authorization in 802.11 WiFi","permalink":"/pages/blog/80211-authentication-association-authorization-wifi"}}')},88455:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var o=n(75026),s=n(74848),r=n(28453);const i={slug:"docker-networking-containment",title:"Locking Down Docker Networks with SPR",authors:["ltsrad"],tags:["container","firewall"]},a=void 0,c={authorsImageUrls:[void 0]},l=[{value:"First Consider Inbound Access To The Container",id:"first-consider-inbound-access-to-the-container",level:2},{value:"Next Consider The Container&#39;s Outbound Access",id:"next-consider-the-containers-outbound-access",level:2},{value:"Browsers are routers too! (sort of)",id:"browsers-are-routers-too-sort-of",level:2},{value:"How SPR Helps",id:"how-spr-helps",level:2},{value:"How This Makes Integrating Cloud VPNs More Secure",id:"how-this-makes-integrating-cloud-vpns-more-secure",level:2},{value:"Looking to use this on SPR?",id:"looking-to-use-this-on-spr",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components},{Details:o}=t;return o||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Envision a homelab scenario with a feature-rich router that's suitable as a container host with storage and memory. Locking down the router's container network policy is surprisingly difficult to set up and manage."}),"\n",(0,s.jsx)(t.p,{children:"SPR makes it easy with secure by default network controls. Instead of worrying about IP ranges and interfaces,\njoin the interfaces to the groups of devices they can communicate with and set internet access policy."}),"\n",(0,s.jsx)(t.h2,{id:"first-consider-inbound-access-to-the-container",children:"First Consider Inbound Access To The Container"}),"\n",(0,s.jsx)(t.p,{children:"Let's assume the container has a webserver running on a typical port ( 8000), which is exposed to the host network on the same port (8000) in the host network.  But we don't want any client device to get access to it, only localhost."}),"\n",(0,s.jsxs)(t.p,{children:["Okay so launch docker with an IP to bind on, and set a firewall rule to restrict access right and drop other address inputs? ",(0,s.jsx)(t.code,{children:"docker run -p 127.0.0.1:8000:8000 ...."})]}),"\n",(0,s.jsxs)(t.p,{children:["Well it turns out that even if you apply standard rules to drop incoming packets: docker makes it ",(0,s.jsx)(t.a,{href:"https://github.com/moby/moby/issues/22054",children:"impossibly hard to actually firewall correctly"})," when Docker inserts in its own firewall rules. To do this more correctly, ",(0,s.jsx)(t.a,{href:"https://docs.docker.com/engine/network/packet-filtering-firewalls/",children:"docker recommends inserting rules into the DOCKER-USER chain"}),". A default-deny policy works best here."]}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("video",{width:"100%",height:"100%",playsInline:!0,controls:!0,src:"/pages/video/blogs/containers-09-24/docker-firewall-override.mp4",type:"video/mp4"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that attackers that are only a single-hop away can forward packets to the direct IP of the container and the docker host will forward the traffic, by default. This applies to all docker hosts, by the way, not just hosts that are also routers, for how docker exposes ports. Setting a source address in docker has no impact against one-hop attacks, and if a ",(0,s.jsx)(t.code,{children:"DOCKER-USER"})," chain is applied it must block interfaces with spoofing outright or have some way to authenticate the IP Addresses to be filtered by the firewall."]}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("video",{width:"100%",height:"100%",playsInline:!0,controls:!0,src:"/pages/video/blogs/containers-09-24/one-hop-docker.mp4",type:"video/mp4"})}),"\n",(0,s.jsxs)(o,{children:[(0,s.jsx)("summary",{children:(0,s.jsxs)(t.p,{children:["To better understand how the single hop attacks work, consider the firewall rules docker creates when starting a container with: ",(0,s.jsx)(t.code,{children:"docker run -p 192.168.1.2:8000:8000 -it ubuntu bash"}),". The container has an internal IP on the docker bridge of ",(0,s.jsx)(t.code,{children:"172.17.0.2"}),"."]})}),(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["The rules permissively forward traffic to ",(0,s.jsx)(t.code,{children:"172.17.0.2"}),", from all interfaces, and the host to bind on is mainly for ",(0,s.jsx)(t.code,{children:"dnat"}),". It does not constrain access to the interface the ",(0,s.jsx)(t.code,{children:"192.168.1.2"})," IP belongs to."]}),(0,s.jsx)(t.p,{children:"To leverage this an attacker one hop away could run something like:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"# arp -i wlan1 -s 172.17.0.2 44:44:44:44:44:44 #where 44:44:44:44:44:44 is the MAC ADDR of the docker host\n# ip route add 172.17.0.2 dev wlan1\n# nc 172.17.0.2 8000\nConnection to 172.20.0.2 8000 port [tcp/*] succeeded!\n\n"})}),(0,s.jsxs)(t.p,{children:["This also holds true if the container launch had specified ",(0,s.jsx)(t.code,{children:" -p 127.0.0.1:8000:8000"})]}),(0,s.jsx)(t.p,{children:"And adding an INPUT rule to drop packets on port 8000 does not help either because forwarding is in play,\nrather than input. The below rule does not block the attack."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"# iptables -A INPUT -p tcp --dport 8000 -j DROP\n# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nDROP       tcp  --  anywhere             anywhere             tcp dpt:8000\n...\n"})}),(0,s.jsxs)(t.p,{children:["Again, ",(0,s.jsx)(t.code,{children:"DOCKER-USER"})," should be used instead."]}),(0,s.jsx)(t.p,{children:"See the full rules below for what docker typically establishes"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\nnet.ipv4.conf.all.forwarding=1\nnet.ipv4.conf.docker0.forwarding=1\n\niptables -n -L -v\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination         \n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 DOCKER-USER  0    --  *      *       0.0.0.0/0            0.0.0.0/0           \n    0     0 DOCKER-ISOLATION-STAGE-1  0    --  *      *       0.0.0.0/0            0.0.0.0/0           \n    0     0 ACCEPT     0    --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED\n    0     0 DOCKER     0    --  *      docker0  0.0.0.0/0            0.0.0.0/0           \n    0     0 ACCEPT     0    --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           \n    0     0 ACCEPT     0    --  docker0 docker0  0.0.0.0/0            0.0.0.0/0           \n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination         \n\nChain DOCKER (1 references)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 ACCEPT     6    --  !docker0 docker0  0.0.0.0/0            172.17.0.2           tcp dpt:8000\n\nChain DOCKER-ISOLATION-STAGE-1 (1 references)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 DOCKER-ISOLATION-STAGE-2  0    --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           \n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0           \n\nChain DOCKER-ISOLATION-STAGE-2 (1 references)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 DROP       0    --  *      docker0  0.0.0.0/0            0.0.0.0/0           \n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0           \n\nChain DOCKER-USER (1 references)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0  \n\n\niptables -n -L -t nat -v\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target     prot opt in     out     source               destination         \n 115 19578 DOCKER     0    --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL\n\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target     prot opt in     out     source               destination         \n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target     prot opt in     out     source               destination         \n   0     0 DOCKER     0    --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL\n\nChain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target     prot opt in     out     source               destination         \n   0     0 MASQUERADE  0    --  *      !docker0  172.17.0.0/16        0.0.0.0/0           \n   0     0 MASQUERADE  6    --  *      *       172.17.0.2           172.17.0.2           tcp dpt:8000\n\nChain DOCKER (2 references)\npkts bytes target     prot opt in     out     source               destination         \n   0     0 RETURN     0    --  docker0 *       0.0.0.0/0            0.0.0.0/0           \n   0     0 DNAT       6    --  !docker0 *       0.0.0.0/0            192.168.1.2          tcp dpt:8000 to:172.17.0.2:8000:::\n\n"})})]})]}),"\n",(0,s.jsx)(t.h2,{id:"next-consider-the-containers-outbound-access",children:"Next Consider The Container's Outbound Access"}),"\n",(0,s.jsx)(t.p,{children:"Typically the containers also have unrestricted outbound access. The container would have full network access to all client devices, as well as all of the upstream networks including any private subnets, in addition to DNS and the internet."}),"\n",(0,s.jsx)(t.p,{children:"Consider the following setup. A HomeLab router may be meant for running docker containers, and networking IOT gadgets. Upstream from the HomeLab router is the main router router that handles the trusted network devices. The container would be able to route packets upstream to all devices on the main network too."}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("video",{width:"100%",height:"100%",playsInline:!0,controls:!0,src:"/pages/video/blogs/containers-09-24/docker-private-upstream.mp4",type:"video/mp4"})}),"\n",(0,s.jsx)(t.p,{children:"Custom firewall rules can help here."}),"\n",(0,s.jsx)(t.h2,{id:"browsers-are-routers-too-sort-of",children:"Browsers are routers too! (sort of)"}),"\n",(0,s.jsx)(t.p,{children:"One last thing to keep in mind is that, increasingly, browsers are a springboard for breaking into insecure NAS, Routers, and IOT devices. Malicious websites and web-ads can make requests to the internal network to try to compromise devices with default credentials and vulnerabilities."}),"\n",(0,s.jsx)(t.p,{children:"When a container is hosted on a router, malicious websites visited by trusted device on the network would be able to potentially access the container too."}),"\n",(0,s.jsxs)(t.p,{children:["Google's Chrome employs ",(0,s.jsx)(t.a,{href:"https://developer.chrome.com/blog/private-network-access-update-2024-03",children:"Private Network Access"})," controls but not all browsers support this hardening. Even then, it's not perfect and there are limiting factors to how effective these controls are. See this ",(0,s.jsx)(t.a,{href:"https://github.com/adc/ctf-midnightsun2022quals-writeups/tree/main/blyatblaster",children:"ctf challenge which bypasses chrome's private network access to exploit a frontier speaker"})]}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("video",{width:"100%",height:"100%",playsInline:!0,controls:!0,src:"/pages/video/blogs/containers-09-24/browserspringboard.mp4",type:"video/mp4"})}),"\n",(0,s.jsx)(t.p,{children:"If the Docker Host is reachable from the user's device, malicious websites are also able to communicate with any reachable container ports."}),"\n",(0,s.jsx)(t.h2,{id:"how-spr-helps",children:"How SPR Helps"}),"\n",(0,s.jsx)(t.p,{children:"Out of the box: SPR as a router solves these challenges. SPR establishes routing and firewall policy for containers as well as interfaces in general."}),"\n",(0,s.jsx)(t.p,{children:"By default, containers on the docker bridge only have outbound internet access & DNS. They can not talk to client devices on the network, and furthermore they are blocked from accessing private networks upstream."}),"\n",(0,s.jsx)(t.p,{children:"If a user wants to set policy for the container to access client devices, they can choose to do so.\nCreate a docker network bridge for your container service, and use the built-in firewall to set policy.\nJoin the interface to a group to give it access. Similarly, policy can be set to completely block outbound network access altogether."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"#docker-comopse Example\n\nnetworks:\n  containernet:\n    driver_opts:\n      com.docker.network.bridge.name: spr-containernet\n"})}),"\n",(0,s.jsx)(t.h2,{id:"how-this-makes-integrating-cloud-vpns-more-secure",children:"How This Makes Integrating Cloud VPNs More Secure"}),"\n",(0,s.jsxs)(t.p,{children:["We take advantage of this in our ",(0,s.jsx)(t.a,{href:"https://github.com/spr-networks/spr-tailscale",children:"tailscale integration"}),". It's possible to connect Tailscale's overlay network to your home network with SPR as the bridge with fine grained access control. Policy ensures not all devices on the network see Tailscale devices and vice versa."]}),"\n",(0,s.jsx)(t.p,{children:"SPR's firewall:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Prevents the entire tailscale overlay from accessing the local devices without explicit policy, even if tailscale's access control is broken or misconfigured"}),"\n",(0,s.jsx)(t.li,{children:"Prevents the local devices from accessing the tailscale overlay devices without explicit policy"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Normally this kind of fine grained access control is only possible with devices directly connecting into Tailscale but leveraging SPR it can be enforced by the router's firewall policy too."}),"\n",(0,s.jsx)(t.h2,{id:"looking-to-use-this-on-spr",children:"Looking to use this on SPR?"}),"\n",(0,s.jsxs)(t.p,{children:["Get started with the interface rules on ",(0,s.jsx)(t.a,{href:"/pages/docs/guides/firewall#custom-interface-access",children:"SPR see the User Manual's Firewall Page"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"firewall-custom-interface-rule-add",src:n(50005).A+"",width:"1280",height:"599"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);