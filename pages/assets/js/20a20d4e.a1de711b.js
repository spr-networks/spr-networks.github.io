"use strict";(self.webpackChunkspr_docs=self.webpackChunkspr_docs||[]).push([[5335],{93733:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=n(85893),r=n(11151);const s={slug:"spr-conntrack-hardening",title:"Security Fixes & Conntrack Hardening in SPR",authors:["ltsrad"],tags:["firewall","conntrack"]},a=void 0,o={permalink:"/pages/blog/spr-conntrack-hardening",source:"@site/blog/2024-10-16-conntrack-hardening.md",title:"Security Fixes & Conntrack Hardening in SPR",description:"Anvil Secure recently published a post and whitepaper covering conntrack flaws that are common with many linux routers and linux \"multihomed\" devices. In this post we'll cover SPR, how our process mitigated the highest risk vulnerabilities, how we fixed the rest and other improvements we're making to be resilient against attacks like this in the future.",date:"2024-10-16T00:00:00.000Z",tags:[{inline:!0,label:"firewall",permalink:"/pages/blog/tags/firewall"},{inline:!0,label:"conntrack",permalink:"/pages/blog/tags/conntrack"}],readingTime:7.46,hasTruncateMarker:!0,authors:[{name:"Alex Radocea",url:"https://twitter.com/defendtheworld",key:"ltsrad",page:null}],frontMatter:{slug:"spr-conntrack-hardening",title:"Security Fixes & Conntrack Hardening in SPR",authors:["ltsrad"],tags:["firewall","conntrack"]},unlisted:!1,nextItem:{title:"Locking Down Multicast Services with SPR",permalink:"/pages/blog/spr-and-cups-multicast-vulnerability"}},c={authorsImageUrls:[void 0]},l=[{value:"Overview",id:"overview",level:2},{value:"Potential Attacks",id:"potential-attacks",level:2},{value:"Attack #1: The uplink interface reaching internal services on the router that are not meant to be accessible to the outside",id:"attack-1-the-uplink-interface-reaching-internal-services-on-the-router-that-are-not-meant-to-be-accessible-to-the-outside",level:3},{value:"Attack #2: Punching holes in a router firewall with NAT-PMP",id:"attack-2-punching-holes-in-a-router-firewall-with-nat-pmp",level:3},{value:"Attack #3: IP Spoofing On External Service Ports",id:"attack-3-ip-spoofing-on-external-service-ports",level:3},{value:"Attack #4: VLAN Routing with Spoofed IPs against Service Ports",id:"attack-4-vlan-routing-with-spoofed-ips-against-service-ports",level:3},{value:"Attack Indicators",id:"attack-indicators",level:3},{value:"On VPN/Docker",id:"on-vpndocker",level:2},{value:"On Wi-Fi",id:"on-wi-fi",level:2},{value:"The fixes",id:"the-fixes",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Anvil Secure recently published a ",(0,i.jsx)(t.a,{href:"https://anvilsecure.com/blog/spoofing-internal-packets-for-multihomed-linux-devices.html",children:"post"})," and ",(0,i.jsx)(t.a,{href:"https://www.anvilsecure.com/wp-content/uploads/2024/10/Conntrack-Spoofing-Internal-Packets-Whitepaper-1.pdf",children:"whitepaper"})," covering conntrack flaws that are common with many linux routers and linux \"multihomed\" devices. In this post we'll cover SPR, how our process mitigated the highest risk vulnerabilities, how we fixed the rest and other improvements we're making to be resilient against attacks like this in the future."]}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://conntrack-tools.netfilter.org/manual.html",children:"Conntrack"})," is part of Linux Netfilter and is an integral part of a stateful firewall for allowing Network Address Translation on a network.  A router uses it to allow clients to establish connections through the uplink interfaces."]}),"\n",(0,i.jsx)(t.p,{children:"Anvil Secure published details on how devices often fail to lock down their firewalls correctly since Conntrack operates at layer 3. External attackers that are one hop away can abuse this to spoof IP addresses and send traffic to internal interfaces on devices and routers for an established connection managed with conntrack.  For most of our users, this limits the attack to compromised or hostile ISP providers, which is an uncommon (but not unheard of attack vector).  However, since the WiFi Pod can be used as a travel router, it's important to us that they are can withstand being attached to a hostile network."}),"\n",(0,i.jsx)(t.p,{children:"The riskiest of the attacks happen to not affect SPR."}),"\n",(0,i.jsx)(t.h2,{id:"potential-attacks",children:"Potential Attacks"}),"\n",(0,i.jsx)(t.h3,{id:"attack-1-the-uplink-interface-reaching-internal-services-on-the-router-that-are-not-meant-to-be-accessible-to-the-outside",children:"Attack #1: The uplink interface reaching internal services on the router that are not meant to be accessible to the outside"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Severity: High"}),"\n",(0,i.jsx)(t.li,{children:"Status: Not Vulnerable"}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"SPR's firewall explicitly matches interfaces to the service ports on the router, so the uplink interface can only connect to service ports if they're explicitly set to be externally facing, even with IP spoofing."})}),"\n",(0,i.jsx)(t.h3,{id:"attack-2-punching-holes-in-a-router-firewall-with-nat-pmp",children:"Attack #2: Punching holes in a router firewall with NAT-PMP"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Severity: High"}),"\n",(0,i.jsx)(t.li,{children:"Status: Not Vulnerable"}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"SPR does not run NAT-PMP."})}),"\n",(0,i.jsx)(t.h3,{id:"attack-3-ip-spoofing-on-external-service-ports",children:"Attack #3: IP Spoofing On External Service Ports"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Severity: Medium"}),"\n",(0,i.jsx)(t.li,{children:"Status: Patched in v1.0.1"}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"The uplink connection to an externally exposed service port could spoof the IP address to match an established connection and blindly send UDP packets by spamming source ports or the same for TCP (if they can guess the sequence numbers plus the source port). This traffic could then present itself on a connection between SPR and a LAN client."})}),"\n",(0,i.jsx)(t.h3,{id:"attack-4-vlan-routing-with-spoofed-ips-against-service-ports",children:"Attack #4: VLAN Routing with Spoofed IPs against Service Ports"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Severity: Low"}),"\n",(0,i.jsx)(t.li,{children:"Status: Patched in v1.0.1"}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"Similarly, VLANs could also perform the same attack against each other internally to attempt to inject traffic into an established connection."})}),"\n",(0,i.jsx)(t.h3,{id:"attack-indicators",children:"Attack Indicators"}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["SPR logs dropped packets and has ",(0,i.jsx)(t.a,{href:"/pages/docs/guides/alerts",children:"alerts"})," for MAC spoofing. In the process of running the attack, the source ports must be enumerated to match the established internal connection. This would create ",(0,i.jsx)(t.code,{children:"nft:drop:mac"})," events when the attacker scans for an established source port. Users can see dropped packets under the alerts pane. To filter the external interface, the filter can be set to ",(0,i.jsx)(t.code,{children:'Event.InDev=="eth0"'})," for example if the uplink interface is ",(0,i.jsx)(t.code,{children:"eth0"}),"."]})}),"\n",(0,i.jsx)(t.h2,{id:"on-vpndocker",children:"On VPN/Docker"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://citizenlab.ca/2024/07/vulnerabilities-in-vpns-paper-presented-at-the-privacy-enhancing-technologies-symposium-2024/",children:"Port Shadow"})," attacks are a similar issue. On a shared VPN host with multiple users a malicious adversary could use the VPN's destination port as the source port to confuse stateful firewall rules into redirecting traffic to set up a MITM attack. SPR hardens against this attack by blocking source ports on the ",(0,i.jsx)(t.a,{href:"https://github.com/spr-networks/super/blob/1f3799ffb82dd758bb9936c05e8812bbe5870063/base/scripts/nft_rules.sh#L256",children:"wireguard port"})]}),"\n",(0,i.jsxs)(t.p,{children:["SPR also runs as a VPN under a virtualized docker network. In this scenario SPR does not manage the host firewall, and relies on Docker's host rules for forwarding services. We cover network attacks against ",(0,i.jsx)(t.a,{href:"https://www.supernetworks.org/pages/blog/docker-networking-containment",children:"Container Networks"})," in a prior post.  In SPR we harden against attacks on Docker's overly premissive networking rules by ",(0,i.jsx)(t.a,{href:"https://github.com/spr-networks/super/blob/1f3799ffb82dd758bb9936c05e8812bbe5870063/base/scripts/nft_rules.sh#L271",children:"limiting API access to the container network"})," interface and subnets."]}),"\n",(0,i.jsx)(t.h2,{id:"on-wi-fi",children:"On Wi-Fi"}),"\n",(0,i.jsx)(t.p,{children:"Anvils' writeups have great information, and one especially good gem of wisdom in the whitepaper is as follows:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:'"For example, on NAT router[s] supporting both Wi\u2011Fi and Ethernet, a communications between two Wi\u2011Fi clients are likely to stay on the Wi\u2011Fi chip."'})}),"\n",(0,i.jsx)(t.p,{children:"This is because with WPA the typical operation is that when station PeerA transmits to PeerB it will encrypt with it's unicast pariwise temporal key (PTK) and send a packet to the AP with Receiver Address(RA)=BSSID and Destination Address (DA). The AP re-encryptes the traffic with PeerB's PTK and sends it without going through the OS networking stack."}),"\n",(0,i.jsx)(t.p,{children:'Many Guest networks rely on this bridging to be blocked when hostapd has "ap_isolate=1" enabled. Unfortunately most setups don\'t do any hardening against routing. So if an adversary instead transmits with RA=DA=BSSID and the IP Destination of PeerB, the router will happily route the packet to PeerB over the networking stack, and then re-encrypt the traffic with the PeerB PTK .'}),"\n",(0,i.jsx)(t.p,{children:"As this next part from the whitepaper mentions, bridging mediums is even more susceptible since they must go through the routing tables (and in turn imply a round trip is possible with spoofing attacks to also receive traffic)."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:'"A Wi\u2011Fi client communicating with an Ethernet host on the other hand, could pass through the NAT router via the bridge"'})}),"\n",(0,i.jsx)(t.p,{children:"In SPR we defend against WiFi-based attacks as follows:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We set ap_isolate=1 to avoid L2 bridging in the chipset where the AP re-encrypts unicast traffic to the other peer"}),"\n",(0,i.jsx)(t.li,{children:"We use Per-Station VLANs with unique group keys for each to avoid GTK-based communications bypassing the AP"}),"\n",(0,i.jsx)(t.li,{children:"We support unique device WPA2/3 passwords to block rogue AP attacks as well as passive key derivation on WPA2."}),"\n",(0,i.jsx)(t.li,{children:"We use MAC filters to stop IP spoofing without knowing the spoofed device's WiFi password & MAC address."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"With conntrack we had some exposure  (#4 above), where established connections could be spoofed into SPR's service ports across VLANs to bypass the MAC filter."}),"\n",(0,i.jsx)(t.h2,{id:"the-fixes",children:"The fixes"}),"\n",(0,i.jsx)(t.p,{children:"To address the issues we've added rules to explicitly block LAN IP ranges from/to the uplink interfaces on the INPUT tables [1].\nSecondly we've moved the MAC filters [2] before the conntrack rules."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:'diff --git a/base/scripts/nft_rules.sh b/base/scripts/nft_rules.sh\nindex 7b96abd6..b03545fd 100755\n--- a/base/scripts/nft_rules.sh\n+++ b/base/scripts/nft_rules.sh\n@@ -1,8 +1,5 @@\n #!/bin/bash\n\n-#TBD:\n-#- can F_EST_RELATED be moved past MAC spoof check\n-\n # Disable forwarding\n sysctl net.ipv4.ip_forward=0\n\n@@ -246,6 +243,10 @@ table inet filter {\n     iifname @uplink_interfaces log prefix "wan:in " group 0\n     iifname != @uplink_interfaces log prefix "lan:in " group 0\n\n+    # block lan ranges from uplink interfaces #[1]\n+    iifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGINP\n+    iifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGINP\n+\n     # Drop input from the site to site output interfaces. They are only a sink,\n     # Not a source that can connect into SPR services\n     counter iifname @outbound_sites goto DROPLOGINP\n@@ -270,7 +271,6 @@ table inet filter {\n     $(if [ "$VIRTUAL_SPR_API_INTERNET" ]; then echo "" ;  elif [[ "$WAN_NET" ]]; then echo "counter iifname @uplink_interfaces tcp dport 80, 443 ip saddr != $WAN_NET drop"; fi)\n     $(if [ "$VIRTUAL_SPR_API_INTERNET" ]; then echo "" ;  elif [[ "$WAN_NET" ]]; then echo "counter iifname @uplink_interfaces udp dport 53, 67 ip saddr != $WAN_NET drop"; fi)\n\n-    counter jump F_EST_RELATED # [2]\n\n     # DHCP Allow rules\n     # Wired lan\n@@ -284,6 +284,8 @@ table inet filter {\n     # Prevent MAC Spoofing from LANIF, wired interfaces\n     iifname @lan_interfaces jump DROP_MAC_SPOOF\n\n+    counter jump F_EST_RELATED # [2]\n+\n     # DNS Allow rules\n     # Docker can DNS\n     $(if [ "$DOCKERIF" ]; then echo "iif $DOCKERIF ip saddr $DOCKERNET udp dport 53 counter accept"; fi)\n@@ -343,6 +345,15 @@ table inet filter {\n     # Allow DNAT for port forwarding\n     counter ct status dnat accept\n\n+    # block lan ranges from uplink interfaces\n+    # uplinks can not NAT FROM @supernetworks source addresses\n+    iifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGFWD\n+    # uplinks can not receive @supernetworks destination addresses\n+    oifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGFWD\n+\n+    # Verify MAC addresses for LANIF/WIPHYs\n+    iifname @lan_interfaces jump DROP_MAC_SPOOF [2]\n+\n     counter jump F_EST_RELATED\n\n     # Do not forward from uplink interfaces after dnat\n@@ -355,8 +366,6 @@ table inet filter {\n     oifname @uplink_interfaces log prefix "wan:out " group 0\n     oifname != @uplink_interfaces log prefix "lan:out " group 0\n\n-    # Verify MAC addresses for LANIF/WIPHYs\n-    iifname @lan_interfaces jump DROP_MAC_SPOOF  [2]\n\n     # After MAC SPOOF check, but before rfc1918 check\n     # These rules allow permits via endpoint verdict maps\n@@ -432,6 +441,8 @@ table inet filter {\n\n   chain OUTPUT {\n     type filter hook output priority 0; policy accept\n+    oifname @uplink_interfaces ip daddr @supernetworks goto DROPLOGOUTP\n+    oifname @uplink_interfaces ip saddr @supernetworks goto DROPLOGOUTP\n   }\n\n   chain DROPLOGFWD {\n@@ -444,6 +455,11 @@ table inet filter {\n     counter drop\n   }\n\n+  chain DROPLOGOUTP {\n+    counter log prefix "drop:output " group 1\n+    counter drop\n+  }\n+\n   chain F_EST_RELATED {\n     ip protocol udp ct state related,established counter accept\n     ip protocol tcp ct state related,established counter accept\n@@ -472,11 +488,6 @@ table inet nat {\n     $(if [ "$LANIF" ]; then echo "elements = { $LANIF }" ; fi )\n   }\n\n'})})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>a});var i=n(67294);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);